{"version":3,"sources":["src/node_modules/browser-pack/_prelude.js","src/node_modules/leaflet-geocoder-mapzen/dist/leaflet-geocoder-mapzen.js","src/demo.js","src/node_modules/leaflet-hash/leaflet-hash.js","src/node_modules/leaflet.locatecontrol/node_modules/leaflet/dist/leaflet-src.js","src/node_modules/leaflet.locatecontrol/src/L.Control.Locate.js","src/node_modules/leaflet/dist/leaflet-src.js","src/node_modules/whatwg-fetch/fetch.js","src/src/demo.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","factory","L","define","amd","window","throttle","func","wait","options","context","args","result","timeout","previous","later","leading","Date","getTime","apply","now","remaining","this","arguments","clearTimeout","trailing","setTimeout","escapeRegExp","str","replace","MINIMUM_INPUT_LENGTH_FOR_AUTOCOMPLETE","FULL_WIDTH_MARGIN","FULL_WIDTH_TOUCH_ADJUSTED_MARGIN","RESULTS_HEIGHT_MARGIN","API_RATE_LIMIT","Control","Geocoder","extend","version","includes","Mixin","Events","position","attribution","url","placeholder","title","bounds","focus","layers","panToPoint","pointIcon","polygonIcon","fullWidth","markers","expanded","autocomplete","place","initialize","apiKey","XDomainRequest","latlng","console","log","Util","setOptions","marker","getLayers","params","getBoundingBoxParam","makeParamsFromLeaflet","latLngBounds","getWest","getSouth","getEast","getNorth","_map","getBounds","isValid","isArray","getFocusParam","mapCenter","getCenter","lat","lng","latLng","getParams","api_key","newParams","prop","search","input","text","callPelias","id","ids","handlePlaceResponse","response","maxReqTimestampRendered","endpoint","type","DomUtil","addClass","_search","reqStartedAt","AJAX","request","err","results","removeClass","errorMessage","showMessage","fire","requestType","errorCode","geocoding","errors","features","_input","value","showResults","highlight","RegExp","getIconType","layer","classPrefix","match","resultsContainer","_results","innerHTML","style","display","maxHeight","getSize","y","offsetTop","_container","list","create","j","feature","resultItem","properties","coords","geometry","coordinates","icon","layerIcon","layerIconContainer","src","label","messageEl","appendChild","document","createTextNode","removeMarkers","removeLayer","showMarker","setView","getZoom","markerOptions","bindPopup","addLayer","push","openPopup","fitBoundingBox","bbox","fitBounds","animate","maxZoom","setSelectedResult","selected","originalEvent","GeoJSON","coordsToLatLng","innerText","textContent","blur","gid","resetInput","_reset","hasClass","expand","clearResults","collapse","force","setFullWidth","clearFullWidth","invalidateSize","mapWidth","x","touchAdjustment","Browser","touch","width","parseInt","toString","onAdd","map","container","_body","body","getElementsByTagName","spellcheck","DomEvent","on","children","stopPropagation","selectedPosition","querySelectorAll","self","shouldPan","_selected","scrollSelectedResultIntoView","_selectedRect","getBoundingClientRect","_resultsRect","bottom","scrollTop","offsetHeight","top","keyCode","target","srcElement","preventDefault","previousItem","highlighted","nextItem","key","which","_lastValue","findParent","parentElement","_scrollWheelZoomEnabled","scrollWheelZoom","enabled","disable","enable","_onMapInteraction","disableClickPropagation","attributionControl","addAttribution","event","onRemove","removeAttribution","control","geocoder","serialize","data","hasOwnProperty","param","JSON","stringify","join","valueOf","encodeURIComponent","http_request","callback","xdr","xhr","XMLHttpRequest","onerror","onreadystatechange","falseFn","error","status","message","statusText","parse","responseText","readyState","onload","paramString","httpRequest","open","constructor","name","setRequestHeader","send","leaflet","2","HAS_HASHCHANGE","doc_mode","documentMode","undefined","Hash","onHashChange","bind","init","parseHash","hash","indexOf","substr","split","zoom","parseFloat","lon","isNaN","center","LatLng","formatHash","precision","Math","max","ceil","LN2","toFixed","prototype","lastHash","isListening","startListening","removeFrom","changeTimeout","stopListening","onMapMove","movingMap","_loaded","location","update","parsed","changeDefer","that","hashChangeInterval","addListener","clearInterval","setInterval","off","removeListener","Map","addHash","_hash","removeHash","3","oldL","noConflict","dest","len","sources","Array","slice","fn","obj","stamp","lastId","invokeEach","method","concat","limitExecByInterval","time","lock","execOnUnlock","wrapperFn","formatNum","num","digits","pow","round","trim","splitWords","getParamString","existingUrl","uppercase","toUpperCase","template","Object","emptyImageUrl","getPrefixed","prefixes","timeoutDefer","timeToCall","lastTime","requestFn","requestAnimationFrame","cancelFn","cancelAnimationFrame","requestAnimFrame","immediate","element","cancelAnimFrame","Class","props","NewClass","_initHooks","callInitHooks","F","proto","statics","parent","__super__","_initHooksCalled","include","mergeOptions","addInitHook","eventsKey","addEventListener","types","indexKey","indexLenKey","typeIndex","events","contextId","action","hasEventListeners","removeEventListener","clearAllEventListeners","listeners","removed","splice","fireEvent","addOneTimeEventListener","handler","once","ie","ielt9","ua","navigator","userAgent","toLowerCase","webkit","chrome","phantomjs","android","android23","gecko","mobile","orientation","msPointer","PointerEvent","MSPointerEvent","pointer","pointerEnabled","retina","devicePixelRatio","matchMedia","matches","doc","documentElement","ie3d","webkit3d","WebKitCSSMatrix","gecko3d","opera3d","any3d","L_DISABLE_3D","L_NO_TOUCH","DocumentTouch","opera","mobileWebkit","mobileWebkit3d","mobileOpera","Point","clone","add","point","_add","subtract","_subtract","divideBy","_divideBy","multiplyBy","_multiplyBy","_round","floor","_floor","distanceTo","sqrt","equals","contains","abs","Bounds","b","points","min","getBottomLeft","getTopRight","intersects","min2","max2","xIntersects","yIntersects","Transformation","c","d","_a","_b","_c","_d","transform","scale","_transform","untransform","get","getElementById","getStyle","el","currentStyle","defaultView","css","getComputedStyle","getViewportOffset","pos","left","docBody","docEl","offsetLeft","offsetParent","scrollLeft","maxWidth","clientLeft","parentNode","documentIsLtr","_docIsLtrCached","_docIsLtr","tagName","className","createElement","classList","_getClass","test","classes","_setClass","remove","baseVal","setOpacity","opacity","filter","filterName","filters","item","Enabled","Opacity","testProp","getTranslateString","is3d","close","getScaleString","origin","preTranslateStr","scaleStr","setPosition","disable3D","_leaflet_pos","TRANSFORM","getPosition","TRANSITION","TRANSITION_END","disableTextSelection","enableTextSelection","userSelectProperty","_userSelect","disableImageDrag","enableImageDrag","alt","DEG_TO_RAD","PI","RAD_TO_DEG","MAX_MARGIN","margin","other","R","d2r","dLat","dLon","lat1","lat2","sin1","sin","sin2","cos","atan2","wrap","LatLngBounds","southWest","northEast","latlngs","_southWest","_northEast","pad","bufferRatio","sw","ne","heightBuffer","widthBuffer","getSouthWest","getNorthEast","getNorthWest","getSouthEast","sw2","ne2","latIntersects","lngIntersects","toBBoxString","Projection","SphericalMercator","MAX_LATITUDE","project","tan","unproject","atan","exp","LonLat","CRS","latLngToPoint","projectedPoint","projection","transformation","pointToLatLng","untransformedPoint","Simple","EPSG3857","earthRadius","EPSG900913","EPSG4326","crs","fadeAnimation","trackResize","markerZoomAnimation","_initContainer","_initLayout","_onResize","_initEvents","maxBounds","setMaxBounds","reset","_handlers","_layers","_zoomBoundLayers","_tileLayersNum","_addLayers","_resetView","_limitZoom","setZoom","_zoom","zoomIn","delta","zoomOut","setZoomAround","getZoomScale","viewHalf","containerPoint","latLngToContainerPoint","centerOffset","newCenter","containerPointToLatLng","paddingTL","paddingTopLeft","padding","paddingBR","paddingBottomRight","getBoundsZoom","paddingOffset","swPoint","nePoint","fitWorld","panTo","pan","panBy","offset","_rawPanBy","_panInsideMaxBounds","panInsideBounds","_limitCenter","minZoom","_updateZoomLevels","zoomAnimation","TileLayer","_tileLayersToLoad","_onTileLayerLoad","_layerAdd","hasLayer","eachLayer","oldSize","_sizeChanged","_initialCenter","newSize","oldCenter","debounceMoveend","_sizeTimer","addHandler","HandlerClass","_leaflet","_clearPanes","_clearControlPos","_clearHandlers","_checkIfLoaded","_moved","layerPointToLatLng","_getCenterLayerPoint","getPixelBounds","getMinZoom","_layersMinZoom","getMaxZoom","_layersMaxZoom","Infinity","inside","boundsSize","size","nw","se","zoomNotFound","_size","clientWidth","clientHeight","topLeftPoint","_getTopLeftPoint","getPixelOrigin","_initialTopLeftPoint","getPanes","_panes","getContainer","toZoom","getScaleZoom","latLngToLayerPoint","containerPointToLayerPoint","_getMapPanePos","layerPointToContainerPoint","layerPoint","mouseEventToContainerPoint","getMousePosition","mouseEventToLayerPoint","mouseEventToLatLng","_initPanes","_initControlPos","panes","_mapPane","mapPane","_createPane","_tilePane","tilePane","objectsPane","shadowPane","overlayPane","markerPane","popupPane","zoomHide","removeChild","preserveMapOffset","afterZoomAnim","zoomChanged","_getNewTopLeftPoint","loading","hard","_getZoomSpan","oldZoomSpan","onOff","_onMouseClick","_fireMouseEvent","_resizeRequest","_simulated","dragging","moved","boxZoom","_skipped","whenReady","_latLngToNewLayerPoint","newZoom","topLeft","_getCenterOffset","centerPoint","viewBounds","_getBoundsOffset","_limitOffset","newBounds","pxBounds","nwOffset","seOffset","dx","_rebound","dy","right","Mercator","R_MINOR","R_MAJOR","r2","tmp","eccent","con","ts","phi","numIter","tol","dphi","EPSG3395","m","tileSize","subdomains","errorTileUrl","zoomOffset","unloadInvisibleTiles","updateWhenIdle","detectRetina","_url","_animated","_zoomAnimated","viewreset","moveend","_update","zoomanim","_animateZoom","zoomend","_endZoomAnim","_limitedUpdate","addTo","bringToFront","pane","_setAutoZIndex","bringToBack","insertBefore","firstChild","getAttribution","_updateOpacity","setZIndex","zIndex","_updateZIndex","setUrl","noRedraw","redraw","compare","edgeZIndex","isFinite","tiles","_tiles","_bgBuffer","_tileContainer","tile","_tilesToLoad","reuseTiles","_unusedTiles","_clearBgBuffer","_getTileSize","zoomN","maxNativeZoom","tileBounds","_addTilesFromCenterOut","_removeOtherTiles","queue","_tileShouldBeLoaded","tilesToLoad","sort","fragment","createDocumentFragment","_addTile","tilePoint","continuousWorld","limit","_getWrapTileNum","noWrap","nwPoint","sePoint","kArr","_removeTile","tilePos","_getTilePos","_getTile","_loadTile","_getZoomForUrl","zoomReverse","getTileUrl","_getSubdomain","z","_adjustTilePoint","tms","index","pop","_resetTile","_createTile","height","galleryimg","onselectstart","onmousemove","WebkitBackfaceVisibility","_layer","_tileOnLoad","_tileOnError","_tileLoaded","_clearBgBufferTimer","newUrl","tileLayer","WMS","defaultWmsParams","service","styles","format","transparent","wmsParams","_crs","_wmsVersion","projectionKey","setParams","wms","Canvas","async","_redrawTile","drawTile","_tilePoint","tileDrawn","canvas","ImageOverlay","_bounds","_image","_initImage","_onImageLoad","image","imageOverlay","Icon","createIcon","oldIcon","_createIcon","createShadow","_getIconUrl","img","_createImg","_setIconStyles","anchor","shadowAnchor","iconAnchor","marginLeft","marginTop","Default","iconSize","popupAnchor","shadowSize","path","imagePath","scripts","leafletRe","Marker","clickable","draggable","keyboard","zIndexOffset","riseOnHover","riseOffset","_latlng","_initIcon","_removeIcon","_removeShadow","getLatLng","setLatLng","setZIndexOffset","setIcon","_popup","_icon","_setPos","animation","classToAdd","addIcon","tabIndex","_initInteraction","_bringToFront","_resetZIndex","newShadow","_shadow","addShadow","_zIndex","opt","_onKeyPress","Handler","MarkerDrag","wasDragged","_enabled","DivIcon","html","div","bgPos","backgroundPosition","divIcon","closePopupOnClick","Popup","minWidth","autoPan","closeButton","autoPanPadding","keepInView","source","_source","_isOpen","animFade","_getEvents","popup","openOn","offsetWidth","_updatePosition","_adjustPan","getContent","_content","setContent","content","visibility","_updateContent","_updateLayout","_zoomAnimation","closeOnClick","preclick","_close","closePopup","prefix","containerClass","_closeButton","href","_onCloseButtonClick","wrapper","_wrapper","_contentNode","disableScrollPropagation","_tipContainer","_tip","hasChildNodes","whiteSpace","scrolledClass","_containerWidth","animated","_containerBottom","_containerLeft","containerHeight","containerWidth","layerPos","containerPos","autoPanPaddingTopLeft","autoPanPaddingBottomRight","stop","togglePopup","_popupHandlersAdded","_movePopup","setPopupContent","unbindPopup","getPopup","LayerGroup","getLayerId","clearLayers","invoke","methodName","getLayer","layerGroup","FeatureGroup","EVENTS","_propagateEvent","_popupContent","_popupOptions","setStyle","featureGroup","Path","CLIP_PADDING","outerWidth","outerHeight","stroke","color","dashArray","lineCap","lineJoin","weight","fill","fillColor","fillOpacity","_initElements","projectLatlngs","_updatePath","_pathRoot","vml","_stroke","_fill","_updateStyle","_updatePathViewport","p","panePos","_pathViewport","SVG_NS","svg","createElementNS","createSVGRect","SVG","root","lastChild","first","getPathString","_createElement","_initPathRoot","_initPath","_initStyle","_path","setAttribute","pointerEvents","removeAttribute","_animatePathZoom","_endPathZoom","_updateSvgViewport","_pathZooming","vp","_openPopup","_latlngs","shape","behavior","adj","VML","namespaces","coordsize","stroked","filled","endcap","dashStyle","joinstyle","v","getContext","L_PREFER_CANVAS","CANVAS","_requestUpdate","_onClick","_onMouseMove","_updateRequest","_fireMapMoveEnd","_ctx","_canvasCtx","lineWidth","strokeStyle","fillStyle","_drawPath","len2","drawMethod","beginPath","_parts","Polygon","closePath","_checkIfEmpty","ctx","save","globalAlpha","fillRule","restore","_containsPoint","_animatingZoom","cursor","_mouseInside","_updateCanvasViewport","translate","LineUtil","simplify","tolerance","sqTolerance","_reducePoints","_simplifyDP","pointToSegmentDistance","p1","p2","_sqClosestPointOnSegment","closestPointOnSegment","ArrayConstructor","Uint8Array","_simplifyDPStep","newPoints","last","sqDist","maxSqDist","reducedPoints","prev","_sqDist","clipSegment","useLastCode","codeOut","newCode","codeA","_lastCode","_getBitCode","codeB","_getEdgeIntersection","dot","Polyline","_convertLatLngs","smoothFactor","noClip","_originalPoints","_getPathPartStr","getLatLngs","setLatLngs","addLatLng","spliceLatLngs","closestLayerPoint","minDistance","parts","minPoint","jLen","distance","overwrite","_clipPoints","k","segment","lu","_simplifyPoints","polyline","PolyUtil","clipPolygon","clippedPoints","edge","edges","_code","_initWithHoles","hole","_holes","_holePoints","newParts","clipped","polygon","createMulti","Klass","_options","MultiPolyline","MultiPolygon","multiPolyline","multiPolygon","Rectangle","_boundsToLatLngs","setBounds","rectangle","Circle","radius","_mRadius","setRadius","lngRadius","_getLngRadius","pointLeft","_point","_radius","latRadius","getRadius","_getLatRadius","circle","CircleMarker","circleMarker","closed","dist","part","w","arc","w2","geojson","addData","geometries","geometryToLayer","pointToLayer","asFeature","defaultOptions","resetStyle","onEachFeature","_setLayerStyle","vectorOptions","coordsToLatLngs","levelsDeep","latLngToCoords","latLngsToCoords","latLngs","getFeature","newGeometry","geoJSON","PointToGeoJSON","toGeoJSON","multiToGeoJSON","json","jsons","isGeometryCollection","geoJson","originalHandler","newType","_getEvent","addPointerListener","addDoubleTapListener","_checkMouse","_filterClick","attachEvent","removePointerListener","removeDoubleTapListener","detachEvent","cancelBubble","Draggable","START","_fakeStop","returnValue","clientX","clientY","rect","clientTop","getWheelDelta","wheelDelta","detail","_skipEvents","skipped","related","relatedTarget","caller","callee","Event","timeStamp","elapsed","_lastClick","_simulatedClick","END","mousedown","touchstart","pointerdown","MSPointerDown","MOVE","dragStartTarget","_element","_dragStartTarget","_onDown","shiftKey","button","touches","_disabled","_moving","_startPoint","_startPos","_newPos","_onMove","_onUp","newPoint","_lastTarget","_animRequest","addHooks","removeHooks","inertia","inertiaDeceleration","inertiaMaxSpeed","inertiaThreshold","easeLinearity","worldCopyJump","Drag","_draggable","dragstart","_onDragStart","drag","_onDrag","dragend","_onDragEnd","_onPreDrag","_onViewReset","_panAnim","_positions","_times","_lastTime","_lastPos","shift","pxCenter","pxWorldCenter","_initialWorldOffset","_worldWidth","worldWidth","halfWidth","newX1","newX2","newX","delay","noInertia","direction","duration","ease","speedVector","speed","limitedSpeed","limitedSpeedVector","decelerationDuration","noMoveStart","doubleClickZoom","DoubleClickZoom","_onDoubleClick","ScrollWheelZoom","_onWheelScroll","_delta","_lastMousePos","_startTime","_timer","_performZoom","_touchstart","_touchend","onTouchStart","count","trackedTouches","pointerId","doubleTap","onTouchEnd","idx","newTouch","pre","touchend","endElement","POINTER_CANCEL","POINTER_DOWN","POINTER_MOVE","POINTER_UP","_pointers","_pointerDocumentListener","addPointerListenerStart","addPointerListenerEnd","addPointerListenerMove","pointers","cb","pointerType","MSPOINTER_TYPE_MOUSE","alreadyInArray","changedTouches","internalCb","buttons","touchZoom","bounceAtZoomLimits","TouchZoom","_onTouchStart","_zooming","viewCenter","_startCenter","_startDist","_centerOffset","_onTouchMove","_onTouchEnd","_scale","_updateOnMove","_getScaleOrigin","oldZoom","floatZoomDelta","roundZoomDelta","tap","tapTolerance","Tap","_fireClick","_holdTimeout","_isTapValid","_simulateEvent","simulatedEvent","createEvent","initMouseEvent","screenX","screenY","dispatchEvent","BoxZoom","_pane","_onMouseDown","_startLayerPoint","_onMouseUp","_onKeyDown","_box","startPoint","box","newPos","_finish","boxZoomBounds","keyboardPanOffset","keyboardZoomOffset","Keyboard","keyCodes","down","up","_setPanOffset","_setZoomOffset","_onFocus","_onBlur","_addHooks","_removeHooks","_focused","scrollTo","keys","_panKeys","codes","_zoomKeys","_inProgress","_marker","shadow","iconPos","removeControl","addControl","corner","_controlCorners","_refocusOnMap","createCorner","vSide","hSide","corners","_controlContainer","Zoom","zoomInText","zoomInTitle","zoomOutText","zoomOutTitle","zoomName","_zoomInButton","_createButton","_zoomIn","_zoomOutButton","_zoomOut","_updateDisabled","link","zoomControl","Attribution","_attributions","_onLayerAdd","_onLayerRemove","setPrefix","attribs","prefixAndAttribs","Scale","metric","imperial","_addScales","_mScale","_iScale","centerLat","halfWorldMeters","maxMeters","_updateScales","_updateMetric","_updateImperial","meters","_getRoundNum","_getScaleWidth","maxMiles","miles","feet","maxFeet","ratio","pow10","Layers","collapsed","autoZIndex","baseLayers","overlays","_lastZIndex","_handlingClick","_addLayer","_onLayerChange","addBaseLayer","addOverlay","form","_form","_expand","_collapse","_layersLink","_onInputClick","_baseLayersList","_separator","_overlaysList","overlay","baseLayersPresent","overlaysPresent","_addItem","_createRadioElement","checked","radioHtml","radioFragment","defaultChecked","layerId","inputs","inputsLen","PosAnimation","run","_el","_onTransitionEnd","_stepTimer","_onStep","_getPos","stepPos","_transformRe","_tryAnimatedZoom","_tryAnimatedPan","step","_onPanTransitionStep","end","_onPanTransitionEnd","_duration","_easeOutPower","_offset","_animate","_step","_complete","_animId","_runFrame","_easeOut","progress","zoomAnimationThreshold","_catchTransitionEnd","propertyName","_onZoomTransitionEnd","_nothingToAnimate","getElementsByClassName","backwards","forTouchZoom","_animateToCenter","_animateToZoom","_animating","_prepareBgBuffer","bg","initialTransform","front","bgLoaded","_getLoadedTilesPercentage","frontLoaded","_stopLoadingImages","complete","_defaultLocateOptions","watch","maximumAge","enableHighAccuracy","locate","_locateOptions","geolocation","_handleGeolocationError","onResponse","_handleGeolocationResponse","onError","_locationWatchId","watchPosition","getCurrentPosition","stopLocate","clearWatch","latitude","longitude","latAccuracy","accuracy","lngAccuracy","timestamp","4","Locate","LocateControl","keepCurrentZoomLevel","clickBehavior","inView","outOfView","drawCircle","drawMarker","markerClass","circleStyle","markerStyle","followCircleStyle","followMarkerStyle","iconLoading","iconElementTag","circlePadding","onLocationError","alert","onLocationOutsideMapBounds","strings","outsideMapBoundsMsg","showPopup","metersUnit","feetUnit","locateOptions","_event","_link","_resetVariables","_unload","_justClicked","_userPanned","_active","start","_updateContainerStyle","_activate","_drawMarker","_deactivate","_cleanClasses","_removeMarker","_onLocationFound","_onLocationError","_isOutsideMapBounds","_isFollowing","_circle","unit","mStyle","_setClasses","state","removeClasses","addClasses","LDomUtilApplyClassesMethod","classNames","forEach","names","5","expose","_leaflet_id","wrapNum","range","includeMax","templateRe","array","parentProto","Evented","_on","_off","_events","listener","propagate","listens","_eventParents","addEventParent","removeEventParent","opera12","safari","mobileGecko","screen","deviceXDPI","logicalXDPI","scaleBy","unscaleBy","_ceil","overlaps","xOverlaps","yOverlaps","empty","toFront","toBack","getClass","setClass","_setOpacityIE","setTransform","transition","preventOutline","restoreOutline","_outlineElement","_outlineStyle","outline","maxMargin","Earth","wrapLatLng","toBounds","sizeInMeters","latOverlaps","lngOverlaps","getProjectedBounds","infinite","wrapLng","wrapLat","latlng1","latlng2","rad","acos","maxBoundsViscosity","transform3DLimit","_getBoundsCenterZoom","setMinZoom","setMaxZoom","_enforcingBounds","_lastCenter","_flyToFrame","createPane","_pixelOrigin","getPixelWorldBounds","getPane","fromZoom","_onScroll","_fadeAnimated","_paneRenderers","_moveStart","_move","_moveEnd","_getNewPixelOrigin","_targets","_handleDOMEvent","_onMoveEnd","_findEventTargets","targets","isHover","_isExternalTarget","synth","_fireDOMEvent","_stopped","_draggableMoved","isMarker","nonBubblingEvents","pixelOrigin","Layer","_mapToAdd","addInteractiveTarget","targetEl","removeInteractiveTarget","getEvents","beforeAdd","_addZoomLimit","_removeZoomLimit","GridLayer","updateInterval","_levels","_tileZoom","isLoading","_loading","_removeAllTiles","_resetAll","move","createTile","getTileSize","nextFrame","willPrune","current","loaded","fade","active","_noPrune","_pruneTiles","_fadeFrame","_updateLevels","level","_setZoomTransform","_level","retain","_retainParent","_retainChildren","x2","y2","z2","animating","pinch","flyTo","_setView","noUpdate","noPrune","tileZoom","tileZoomChanged","_abortLoading","_resetGrid","_setZoomTransforms","_tileSize","_globalTileRange","_pxBoundsToTileRange","_wrapX","_wrapY","_getTiledPixelBounds","pixelCenter","halfSize","pixelBounds","tileRange","tileCenter","_isValidTile","_tileCoordsToKey","_tileCoordsToBounds","_keyToBounds","_keyToTileCoords","_initTile","_wrapCoords","_tileReady","_noTilesToLoad","newCoords","gridLayer","crossOrigin","_onTileRemove","done","errorUrl","interactive","styleOpts","getElement","oldLatLng","mouseover","mouseout","autoClose","_removeTimeout","isOpen","node","click","_originalPopupOffset","_popupAnchor","isPopupOpen","_getPopupAnchor","offsetToAdd","Renderer","zoomstart","_onZoomStart","_onZoom","_onAnimZoom","ev","_updateTransform","currentCenterPoint","_center","destCenterPoint","topLeftOffset","getRenderer","renderer","_getPaneRenderer","_renderer","preferCanvas","_addPath","_removePath","_project","_bringToBack","_clickTolerance","_setLatLngs","isEmpty","closest","halfDist","segDist","_rings","_defaultShape","_flat","flat","_projectLatlngs","_pxBounds","ring","_updatePoly","area","_updateBounds","_radiusY","_updateCircle","_empty","half","latR","lngR","legacyOptions","_rootGroup","_svgSize","dashOffset","_setPath","pointsToPath","rings","_draw","_handleMouseOut","_drawnLayers","_removed","_requestRedraw","_redrawBounds","_redrawRequest","_redraw","clear","_clear","clip","_fillStroke","globalCompositeOperation","_prevWeight","_fireEvent","_handleMouseHover","_hoveredLayer","multi","holes","toMultiPoint","dblclick","_preventOutline","_dragging","_lastEvent","_onPreDragLimit","_onPreDragWrap","_onZoomEnd","_offsetLimit","_viscosity","_absPos","_viscousLimit","threshold","wheelDebounceTime","mousewheel","MozMousePixelScroll","debounce","_pointersCount","_addPointerStart","_addPointerMove","_addPointerEnd","onDown","_handlePointer","_pointerDocListener","pointerUp","_globalPointerUp","_globalPointerDown","_globalPointerMove","onMove","onUp","_centerPoint","_startLatLng","_pinchStartLatLng","_startZoom","moveFn","touchmove","_resetState","contextmenu","mousemove","mouseup","keydown","altKey","ctrlKey","metaKey","_updateScale","hideSingleBase","_checkDisabledLayers","mouseenter","mouseleave","baseLayersCount","holder","addedLayers","removedLayers","acceptableHeight","disabled","zoomAnimated","_createAnimProxy","_proxy","proxy","startAnim","targetCenter","targetZoom","w1","w0","rho2","u1","sinh","cosh","tanh","r0","rho","easeOut","frame","S","from","to","startZoom","flyToBounds","6","normalizeName","String","TypeError","normalizeValue","iteratorFor","items","iterator","next","support","iterable","Symbol","Headers","headers","append","getOwnPropertyNames","consumed","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","Body","_initBody","_bodyInit","_bodyText","Blob","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","searchParams","URLSearchParams","arrayBuffer","ArrayBuffer","set","rejected","then","decode","normalizeMethod","upcased","methods","Request","credentials","mode","referrer","bytes","decodeURIComponent","head","pairs","getAllResponseHeaders","header","Response","bodyInit","ok","fetch","values","getAll","has","thisArg","entries","redirectStatuses","redirect","RangeError","responseURL","getResponseHeader","ontimeout","withCredentials","responseType","polyfill","7","global","Tangram","SEARCH_API_KEY","follow","leafletLayer","scene","reverse","postMessage","leaflet-geocoder-mapzen","leaflet-hash","leaflet.locatecontrol","whatwg-fetch"],"mappings":"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","file":"demo.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n * leaflet-geocoder-mapzen\n * Leaflet plugin to search (geocode) using Mapzen Search or your\n * own hosted version of the Pelias Geocoder API.\n *\n * License: MIT\n * (c) Mapzen\n */\n;(function (factory) { // eslint-disable-line no-extra-semi\n  var L;\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['leaflet'], factory);\n  } else if (typeof module !== 'undefined') {\n    // Node/CommonJS\n    L = require('leaflet');\n    module.exports = factory(L);\n  } else {\n    // Browser globals\n    if (typeof window.L === 'undefined') {\n      throw new Error('Leaflet must be loaded first');\n    }\n    factory(window.L);\n  }\n}(function (L) {\n  'use strict';\n\n  var MINIMUM_INPUT_LENGTH_FOR_AUTOCOMPLETE = 1;\n  var FULL_WIDTH_MARGIN = 20; // in pixels\n  var FULL_WIDTH_TOUCH_ADJUSTED_MARGIN = 4; // in pixels\n  var RESULTS_HEIGHT_MARGIN = 20; // in pixels\n  var API_RATE_LIMIT = 250; // in ms, throttled time between subsequent requests to API\n\n  L.Control.Geocoder = L.Control.extend({\n\n    version: '1.6.2',\n\n    includes: L.Mixin.Events,\n\n    options: {\n      position: 'topleft',\n      attribution: 'Geocoding by <a href=\"https://mapzen.com/projects/search/\">Mapzen</a>',\n      url: 'https://search.mapzen.com/v1',\n      placeholder: 'Search',\n      title: 'Search',\n      bounds: false,\n      focus: true,\n      layers: null,\n      panToPoint: true,\n      pointIcon: true, // 'images/point_icon.png',\n      polygonIcon: true, // 'images/polygon_icon.png',\n      fullWidth: 650,\n      markers: true,\n      expanded: false,\n      autocomplete: true,\n      place: false\n    },\n\n    initialize: function (apiKey, options) {\n      // For IE8 compatibility (if XDomainRequest is present),\n      // we set the default value of options.url to the protocol-relative\n      // version, because XDomainRequest does not allow http-to-https requests\n      // This is set first so it can always be overridden by the user\n      if (window.XDomainRequest) {\n        this.options.url = '//search.mapzen.com/v1';\n      }\n\n      // If the apiKey is omitted entirely and the\n      // first parameter is actually the options\n      if (typeof apiKey === 'object' && !!apiKey) {\n        options = apiKey;\n      } else {\n        this.apiKey = apiKey;\n      }\n\n      // Deprecation warnings\n      // If options.latlng is defined, warn. (Do not check for falsy values, because it can be set to false.)\n      if (options && typeof options.latlng !== 'undefined') {\n        // Set user-specified latlng to focus option, but don't overwrite if it's already there\n        if (typeof options.focus === 'undefined') {\n          options.focus = options.latlng;\n        }\n        console.log('[leaflet-geocoder-mapzen] DEPRECATION WARNING:',\n          'As of v1.6.0, the `latlng` option is deprecated. It has been renamed to `focus`. `latlng` will be removed in a future version.');\n      }\n\n      // Now merge user-specified options\n      L.Util.setOptions(this, options);\n      this.marker;\n      this.markers = [];\n    },\n\n    getLayers: function (params) {\n      var layers = this.options.layers;\n\n      if (!layers) {\n        return params;\n      }\n\n      params.layers = layers;\n      return params;\n    },\n\n    getBoundingBoxParam: function (params) {\n      /*\n       * this.options.bounds can be one of the following\n       * true //Boolean - take the map bounds\n       * false //Boolean - no bounds\n       * L.latLngBounds(...) //Object\n       * [[10, 10], [40, 60]] //Array\n      */\n      var bounds = this.options.bounds;\n\n      // If falsy, bail\n      if (!bounds) {\n        return params;\n      }\n\n      // If set to true, use map bounds\n      // If it is a valid L.LatLngBounds object, get its values\n      // If it is an array, try running it through L.LatLngBounds\n      if (bounds === true) {\n        bounds = this._map.getBounds();\n        params = makeParamsFromLeaflet(params, bounds);\n      } else if (typeof bounds === 'object' && bounds.isValid && bounds.isValid()) {\n        params = makeParamsFromLeaflet(params, bounds);\n      } else if (L.Util.isArray(bounds)) {\n        var latLngBounds = L.latLngBounds(bounds);\n        if (latLngBounds.isValid && latLngBounds.isValid()) {\n          params = makeParamsFromLeaflet(params, latLngBounds);\n        }\n      }\n\n      function makeParamsFromLeaflet (params, latLngBounds) {\n        params['boundary.rect.min_lon'] = latLngBounds.getWest();\n        params['boundary.rect.min_lat'] = latLngBounds.getSouth();\n        params['boundary.rect.max_lon'] = latLngBounds.getEast();\n        params['boundary.rect.max_lat'] = latLngBounds.getNorth();\n        return params;\n      }\n\n      return params;\n    },\n\n    getFocusParam: function (params) {\n      /**\n       * this.options.focus can be one of the following\n       * [50, 30]           // Array\n       * {lon: 30, lat: 50} // Object\n       * {lat: 50, lng: 30} // Object\n       * L.latLng(50, 30)   // Object\n       * true               // Boolean - take the map center\n       * false              // Boolean - No latlng to be considered\n       */\n      var focus = this.options.focus;\n\n      if (!focus) {\n        return params;\n      }\n\n      if (focus === true) {\n        // If focus option is Boolean true, use current map center\n        var mapCenter = this._map.getCenter();\n        params['focus.point.lat'] = mapCenter.lat;\n        params['focus.point.lon'] = mapCenter.lng;\n      } else if (typeof focus === 'object') {\n        // Accepts array, object and L.latLng form\n        // Constructs the latlng object using Leaflet's L.latLng()\n        // [50, 30]\n        // {lon: 30, lat: 50}\n        // {lat: 50, lng: 30}\n        // L.latLng(50, 30)\n        var latlng = L.latLng(focus);\n        params['focus.point.lat'] = latlng.lat;\n        params['focus.point.lon'] = latlng.lng;\n      }\n\n      return params;\n    },\n\n    // @method getParams(params: Object)\n    // Collects all the parameters in a single object from various options,\n    // including options.bounds, options.focus, options.layers, the api key,\n    // and any params that are provided as a argument to this function.\n    // Note that options.params will overwrite any of these\n    getParams: function (params) {\n      params = params || {};\n      params = this.getBoundingBoxParam(params);\n      params = this.getFocusParam(params);\n      params = this.getLayers(params);\n\n      // Search API key\n      if (this.apiKey) {\n        params.api_key = this.apiKey;\n      }\n\n      var newParams = this.options.params;\n\n      if (!newParams) {\n        return params;\n      }\n\n      if (typeof newParams === 'object') {\n        for (var prop in newParams) {\n          params[prop] = newParams[prop];\n        }\n      }\n\n      return params;\n    },\n\n    search: function (input) {\n      // Prevent lack of input from sending a malformed query to Pelias\n      if (!input) return;\n\n      var url = this.options.url + '/search';\n      var params = {\n        text: input\n      };\n\n      this.callPelias(url, params, 'search');\n    },\n\n    autocomplete: throttle(function (input) {\n      // Prevent lack of input from sending a malformed query to Pelias\n      if (!input) return;\n\n      var url = this.options.url + '/autocomplete';\n      var params = {\n        text: input\n      };\n\n      this.callPelias(url, params, 'autocomplete');\n    }, API_RATE_LIMIT),\n\n    place: function (id) {\n      // Prevent lack of input from sending a malformed query to Pelias\n      if (!id) return;\n\n      var url = this.options.url + '/place';\n      var params = {\n        ids: id\n      };\n\n      this.callPelias(url, params, 'place');\n    },\n\n    handlePlaceResponse: function (response) {\n      // Placeholder for handling place response\n    },\n\n    // Timestamp of the last response which was successfully rendered to the UI.\n    // The time represents when the request was *sent*, not when it was recieved.\n    maxReqTimestampRendered: new Date().getTime(),\n\n    callPelias: function (endpoint, params, type) {\n      params = this.getParams(params);\n\n      L.DomUtil.addClass(this._search, 'leaflet-pelias-loading');\n\n      // Track when the request began\n      var reqStartedAt = new Date().getTime();\n\n      AJAX.request(endpoint, params, function (err, results) {\n        L.DomUtil.removeClass(this._search, 'leaflet-pelias-loading');\n\n        if (err) {\n          var errorMessage;\n          switch (err.code) {\n            // Error codes.\n            // https://mapzen.com/documentation/search/http-status-codes/\n            case 403:\n              errorMessage = 'A valid API key is needed for this search feature.';\n              break;\n            case 404:\n              errorMessage = 'The search service cannot be found. :-(';\n              break;\n            case 408:\n              errorMessage = 'The search service took too long to respond. Try again in a second.';\n              break;\n            case 429:\n              errorMessage = 'There were too many requests. Try again in a second.';\n              break;\n            case 500:\n              errorMessage = 'The search service is not working right now. Please try again later.';\n              break;\n            case 502:\n              errorMessage = 'Connection lost. Please try again later.';\n              break;\n            // Note the status code is 0 if CORS is not enabled on the error response\n            default:\n              errorMessage = 'The search service is having problems :-(';\n              break;\n          }\n          this.showMessage(errorMessage);\n          this.fire('error', {\n            results: results,\n            endpoint: endpoint,\n            requestType: type,\n            params: params,\n            errorCode: err.code,\n            errorMessage: errorMessage\n          });\n        }\n\n        // There might be an error message from the geocoding service itself\n        if (results && results.geocoding && results.geocoding.errors) {\n          errorMessage = results.geocoding.errors[0];\n          this.showMessage(errorMessage);\n          this.fire('error', {\n            results: results,\n            endpoint: endpoint,\n            requestType: type,\n            params: params,\n            errorCode: err.code,\n            errorMessage: errorMessage\n          });\n          return;\n        }\n\n        // Autocomplete and search responses\n        if (results && results.features) {\n          // Check if request is stale:\n          // Only for autocomplete or search endpoints\n          // Ignore requests if input is currently blank\n          // Ignore requests that started before a request which has already\n          // been successfully rendered on to the UI.\n          if (type === 'autocomplete' || type === 'search') {\n            if (this._input.value === '' || this.maxReqTimestampRendered >= reqStartedAt) {\n              return;\n            } else {\n              // Record the timestamp of the request.\n              this.maxReqTimestampRendered = reqStartedAt;\n            }\n          }\n\n          // Placeholder: handle place response\n          if (type === 'place') {\n            this.handlePlaceResponse(results);\n          }\n\n          // Show results\n          if (type === 'autocomplete' || type === 'search') {\n            this.showResults(results.features, params.text);\n          }\n\n          // Fire event\n          this.fire('results', {\n            results: results,\n            endpoint: endpoint,\n            requestType: type,\n            params: params\n          });\n        }\n      }, this);\n    },\n\n    highlight: function (text, focus) {\n      var r = RegExp('(' + escapeRegExp(focus) + ')', 'gi');\n      return text.replace(r, '<strong>$1</strong>');\n    },\n\n    getIconType: function (layer) {\n      var pointIcon = this.options.pointIcon;\n      var polygonIcon = this.options.polygonIcon;\n      var classPrefix = 'leaflet-pelias-layer-icon-';\n\n      if (layer.match('venue') || layer.match('address')) {\n        if (pointIcon === true) {\n          return {\n            type: 'class',\n            value: classPrefix + 'point'\n          };\n        } else if (pointIcon === false) {\n          return false;\n        } else {\n          return {\n            type: 'image',\n            value: pointIcon\n          };\n        }\n      } else {\n        if (polygonIcon === true) {\n          return {\n            type: 'class',\n            value: classPrefix + 'polygon'\n          };\n        } else if (polygonIcon === false) {\n          return false;\n        } else {\n          return {\n            type: 'image',\n            value: polygonIcon\n          };\n        }\n      }\n    },\n\n    showResults: function (features, input) {\n      // Exit function if there are no features\n      if (features.length === 0) {\n        this.showMessage('No results were found.');\n        return;\n      }\n\n      var resultsContainer = this._results;\n\n      // Reset and display results container\n      resultsContainer.innerHTML = '';\n      resultsContainer.style.display = 'block';\n      // manage result box height\n      resultsContainer.style.maxHeight = (this._map.getSize().y - resultsContainer.offsetTop - this._container.offsetTop - RESULTS_HEIGHT_MARGIN) + 'px';\n\n      var list = L.DomUtil.create('ul', 'leaflet-pelias-list', resultsContainer);\n\n      for (var i = 0, j = features.length; i < j; i++) {\n        var feature = features[i];\n        var resultItem = L.DomUtil.create('li', 'leaflet-pelias-result', list);\n\n        resultItem.feature = feature;\n        resultItem.layer = feature.properties.layer;\n\n        // Deprecated\n        // Use L.GeoJSON.coordsToLatLng(resultItem.feature.geometry.coordinates) instead\n        // This returns a L.LatLng object that can be used throughout Leaflet\n        resultItem.coords = feature.geometry.coordinates;\n\n        var icon = this.getIconType(feature.properties.layer);\n        if (icon) {\n          // Point or polygon icon\n          // May be a class or an image path\n          var layerIconContainer = L.DomUtil.create('span', 'leaflet-pelias-layer-icon-container', resultItem);\n          var layerIcon;\n\n          if (icon.type === 'class') {\n            layerIcon = L.DomUtil.create('div', 'leaflet-pelias-layer-icon ' + icon.value, layerIconContainer);\n          } else {\n            layerIcon = L.DomUtil.create('img', 'leaflet-pelias-layer-icon', layerIconContainer);\n            layerIcon.src = icon.value;\n          }\n\n          layerIcon.title = 'layer: ' + feature.properties.layer;\n        }\n\n        resultItem.innerHTML += this.highlight(feature.properties.label, input);\n      }\n    },\n\n    showMessage: function (text) {\n      var resultsContainer = this._results;\n\n      // Reset and display results container\n      resultsContainer.innerHTML = '';\n      resultsContainer.style.display = 'block';\n\n      var messageEl = L.DomUtil.create('div', 'leaflet-pelias-message', resultsContainer);\n\n      // Set text. This is the most cross-browser compatible method\n      // and avoids the issues we have detecting either innerText vs textContent\n      // (e.g. Firefox cannot detect textContent property on elements, but it's there)\n      messageEl.appendChild(document.createTextNode(text));\n    },\n\n    removeMarkers: function () {\n      if (this.options.markers) {\n        for (var i = 0; i < this.markers.length; i++) {\n          this._map.removeLayer(this.markers[i]);\n        }\n        this.markers = [];\n      }\n    },\n\n    showMarker: function (text, latlng) {\n      this._map.setView(latlng, this._map.getZoom() || 8);\n\n      var markerOptions = (typeof this.options.markers === 'object') ? this.options.markers : {};\n\n      if (this.options.markers) {\n        this.marker = new L.marker(latlng, markerOptions).bindPopup(text); // eslint-disable-line new-cap\n        this._map.addLayer(this.marker);\n        this.markers.push(this.marker);\n        this.marker.openPopup();\n      }\n    },\n\n    /**\n     * Fits the map view to a given bounding box.\n     * Mapzen Search / Pelias returns the 'bbox' property on 'feature'. It is\n     * as an array of four numbers:\n     *   [\n     *     0: southwest longitude,\n     *     1: southwest latitude,\n     *     2: northeast longitude,\n     *     3: northeast latitude\n     *   ]\n     * This method expects the array to be passed directly and it will be converted\n     * to a boundary parameter for Leaflet's fitBounds().\n     */\n    fitBoundingBox: function (bbox) {\n      this._map.fitBounds([\n        [ bbox[1], bbox[0] ],\n        [ bbox[3], bbox[2] ]\n      ], {\n        animate: true,\n        maxZoom: 16\n      });\n    },\n\n    setSelectedResult: function (selected, originalEvent) {\n      var latlng = L.GeoJSON.coordsToLatLng(selected.feature.geometry.coordinates);\n      this._input.value = selected.innerText || selected.textContent;\n      if (selected.feature.bbox) {\n        this.removeMarkers();\n        this.fitBoundingBox(selected.feature.bbox);\n      } else {\n        this.removeMarkers();\n        this.showMarker(selected.innerHTML, latlng);\n      }\n      this.fire('select', {\n        originalEvent: originalEvent,\n        latlng: latlng,\n        feature: selected.feature\n      });\n      this.blur();\n\n      if (this.options.place) {\n        this.place(selected.feature.properties.gid);\n      }\n    },\n\n    resetInput: function () {\n      this._input.value = '';\n      L.DomUtil.addClass(this._reset, 'leaflet-pelias-hidden');\n      this.removeMarkers();\n      this._input.focus();\n      this.fire('reset');\n    },\n\n    // Convenience function for focusing on the input\n    // This is meant for external use.\n    focus: function () {\n      // If not expanded, expand this first\n      if (!L.DomUtil.hasClass(this._container, 'leaflet-pelias-expanded')) {\n        this.expand();\n      }\n      this._input.focus();\n    },\n\n    // Removes focus from geocoder control\n    blur: function () {\n      this._input.blur();\n      this.clearResults();\n      if (this._input.value === '' && this._results.style.display !== 'none') {\n        L.DomUtil.addClass(this._reset, 'leaflet-pelias-hidden');\n        if (!this.options.expanded) {\n          this.collapse();\n        }\n      }\n    },\n\n    clearResults: function (force) {\n      // Hide results from view\n      this._results.style.display = 'none';\n\n      // Destroy contents if input has also cleared\n      // OR if force is true\n      if (this._input.value === '' || force === true) {\n        this._results.innerHTML = '';\n      }\n    },\n\n    expand: function () {\n      L.DomUtil.addClass(this._container, 'leaflet-pelias-expanded');\n      this.setFullWidth();\n      this.fire('expand');\n    },\n\n    collapse: function () {\n      // 'expanded' options check happens outside of this function now\n      // So it's now possible for a script to force-collapse a geocoder\n      // that otherwise defaults to the always-expanded state\n      L.DomUtil.removeClass(this._container, 'leaflet-pelias-expanded');\n      this._input.blur();\n      this.clearFullWidth();\n      this.clearResults();\n      this.fire('collapse');\n    },\n\n    // Set full width of expanded input, if enabled\n    setFullWidth: function () {\n      if (this.options.fullWidth) {\n        // If fullWidth setting is a number, only expand if map container\n        // is smaller than that breakpoint. Otherwise, clear width\n        // Always ask map to invalidate and recalculate size first\n        this._map.invalidateSize();\n        var mapWidth = this._map.getSize().x;\n        var touchAdjustment = L.Browser.touch ? FULL_WIDTH_TOUCH_ADJUSTED_MARGIN : 0;\n        var width = mapWidth - FULL_WIDTH_MARGIN - touchAdjustment;\n        if (typeof this.options.fullWidth === 'number' && mapWidth >= window.parseInt(this.options.fullWidth, 10)) {\n          this.clearFullWidth();\n          return;\n        }\n        this._container.style.width = width.toString() + 'px';\n      }\n    },\n\n    clearFullWidth: function () {\n      // Clear set width, if any\n      if (this.options.fullWidth) {\n        this._container.style.width = '';\n      }\n    },\n\n    onAdd: function (map) {\n      var container = L.DomUtil.create('div',\n          'leaflet-pelias-control leaflet-bar leaflet-control');\n\n      this._body = document.body || document.getElementsByTagName('body')[0];\n      this._container = container;\n      this._input = L.DomUtil.create('input', 'leaflet-pelias-input', this._container);\n      this._input.spellcheck = false;\n\n      // Only set if title option is not null or falsy\n      if (this.options.title) {\n        this._input.title = this.options.title;\n      }\n\n      // Only set if placeholder option is not null or falsy\n      if (this.options.placeholder) {\n        this._input.placeholder = this.options.placeholder;\n      }\n\n      this._search = L.DomUtil.create('a', 'leaflet-pelias-search-icon', this._container);\n      this._reset = L.DomUtil.create('div', 'leaflet-pelias-close leaflet-pelias-hidden', this._container);\n      this._reset.innerHTML = '';\n      this._reset.title = 'Reset';\n\n      this._results = L.DomUtil.create('div', 'leaflet-pelias-results leaflet-bar', this._container);\n\n      if (this.options.expanded) {\n        this.expand();\n      }\n\n      L.DomEvent\n        .on(this._container, 'click', function (e) {\n          // Child elements with 'click' listeners should call\n          // stopPropagation() to prevent that event from bubbling to\n          // the container & causing it to fire too greedily\n          this._input.focus();\n        }, this)\n        .on(this._input, 'focus', function (e) {\n          if (this._input.value && this._results.children.length) {\n            this._results.style.display = 'block';\n          }\n        }, this)\n        .on(this._map, 'click', function (e) {\n          // Does what you might expect a _input.blur() listener might do,\n          // but since that would fire for any reason (e.g. clicking a result)\n          // what you really want is to blur from the control by listening to clicks on the map\n          this.blur();\n        }, this)\n        .on(this._search, 'click', function (e) {\n          L.DomEvent.stopPropagation(e);\n\n          // Toggles expanded state of container on click of search icon\n          if (L.DomUtil.hasClass(this._container, 'leaflet-pelias-expanded')) {\n            // If expanded option is true, just focus the input\n            if (this.options.expanded === true) {\n              this._input.focus();\n              return;\n            } else {\n              // Otherwise, toggle to hidden state\n              L.DomUtil.addClass(this._reset, 'leaflet-pelias-hidden');\n              this.collapse();\n            }\n          } else {\n            // If not currently expanded, clicking here always expands it\n            if (this._input.value.length > 0) {\n              L.DomUtil.removeClass(this._reset, 'leaflet-pelias-hidden');\n            }\n            this.expand();\n            this._input.focus();\n          }\n        }, this)\n        .on(this._reset, 'click', function (e) {\n          this.resetInput();\n          this.clearResults();\n          L.DomEvent.stopPropagation(e);\n        }, this)\n        .on(this._input, 'keydown', function (e) {\n          var list = this._results.querySelectorAll('.leaflet-pelias-result');\n          var selected = this._results.querySelectorAll('.leaflet-pelias-selected')[0];\n          var selectedPosition;\n          var self = this;\n          var panToPoint = function (shouldPan) {\n            var _selected = self._results.querySelectorAll('.leaflet-pelias-selected')[0];\n            if (_selected && shouldPan) {\n              if (_selected.feature.bbox) {\n                self.removeMarkers();\n                self.fitBoundingBox(_selected.feature.bbox);\n              } else {\n                self.removeMarkers();\n                self.showMarker(_selected.innerHTML, L.GeoJSON.coordsToLatLng(_selected.feature.geometry.coordinates));\n              }\n            }\n          };\n\n          var scrollSelectedResultIntoView = function () {\n            var _selected = self._results.querySelectorAll('.leaflet-pelias-selected')[0];\n            var _selectedRect = _selected.getBoundingClientRect();\n            var _resultsRect = self._results.getBoundingClientRect();\n            // Is the selected element not visible?\n            if (_selectedRect.bottom > _resultsRect.bottom) {\n              self._results.scrollTop = _selected.offsetTop + _selected.offsetHeight - self._results.offsetHeight;\n            } else if (_selectedRect.top < _resultsRect.top) {\n              self._results.scrollTop = _selected.offsetTop;\n            }\n          };\n\n          for (var i = 0; i < list.length; i++) {\n            if (list[i] === selected) {\n              selectedPosition = i;\n              break;\n            }\n          }\n\n          // TODO cleanup\n          switch (e.keyCode) {\n            // 13 = enter\n            case 13:\n              if (selected) {\n                this.setSelectedResult(selected, e);\n              } else {\n                // perform a full text search on enter\n                var text = (e.target || e.srcElement).value;\n                this.search(text);\n              }\n              L.DomEvent.preventDefault(e);\n              break;\n            // 38 = up arrow\n            case 38:\n              // Ignore key if there are no results or if list is not visible\n              if (list.length === 0 || this._results.style.display === 'none') {\n                return;\n              }\n\n              if (selected) {\n                L.DomUtil.removeClass(selected, 'leaflet-pelias-selected');\n              }\n\n              var previousItem = list[selectedPosition - 1];\n              var highlighted = (selected && previousItem) ? previousItem : list[list.length - 1]; // eslint-disable-line no-redeclare\n\n              L.DomUtil.addClass(highlighted, 'leaflet-pelias-selected');\n              scrollSelectedResultIntoView();\n              panToPoint(this.options.panToPoint);\n              this.fire('highlight', {\n                originalEvent: e,\n                latlng: L.GeoJSON.coordsToLatLng(highlighted.feature.geometry.coordinates),\n                feature: highlighted.feature\n              });\n\n              L.DomEvent.preventDefault(e);\n              break;\n            // 40 = down arrow\n            case 40:\n              // Ignore key if there are no results or if list is not visible\n              if (list.length === 0 || this._results.style.display === 'none') {\n                return;\n              }\n\n              if (selected) {\n                L.DomUtil.removeClass(selected, 'leaflet-pelias-selected');\n              }\n\n              var nextItem = list[selectedPosition + 1];\n              var highlighted = (selected && nextItem) ? nextItem : list[0]; // eslint-disable-line no-redeclare\n\n              L.DomUtil.addClass(highlighted, 'leaflet-pelias-selected');\n              scrollSelectedResultIntoView();\n              panToPoint(this.options.panToPoint);\n              this.fire('highlight', {\n                originalEvent: e,\n                latlng: L.GeoJSON.coordsToLatLng(highlighted.feature.geometry.coordinates),\n                feature: highlighted.feature\n              });\n\n              L.DomEvent.preventDefault(e);\n              break;\n            // all other keys\n            default:\n              break;\n          }\n        }, this)\n        .on(this._input, 'keyup', function (e) {\n          var key = e.which || e.keyCode;\n          var text = (e.target || e.srcElement).value;\n\n          if (text.length > 0) {\n            L.DomUtil.removeClass(this._reset, 'leaflet-pelias-hidden');\n          } else {\n            L.DomUtil.addClass(this._reset, 'leaflet-pelias-hidden');\n          }\n\n          // Ignore all further action if the keycode matches an arrow\n          // key (handled via keydown event)\n          if (key === 13 || key === 38 || key === 40) {\n            return;\n          }\n\n          // keyCode 27 = esc key (esc should clear results)\n          if (key === 27) {\n            // If input is blank or results have already been cleared\n            // (perhaps due to a previous 'esc') then pressing esc at\n            // this point will blur from input as well.\n            if (text.length === 0 || this._results.style.display === 'none') {\n              this._input.blur();\n\n              if (!this.options.expanded && L.DomUtil.hasClass(this._container, 'leaflet-pelias-expanded')) {\n                this.collapse();\n              }\n            }\n\n            // Clears results\n            this.clearResults(true);\n            L.DomUtil.removeClass(this._search, 'leaflet-pelias-loading');\n            return;\n          }\n\n          if (text !== this._lastValue) {\n            this._lastValue = text;\n\n            if (text.length >= MINIMUM_INPUT_LENGTH_FOR_AUTOCOMPLETE && this.options.autocomplete === true) {\n              this.autocomplete(text);\n            } else {\n              this.clearResults(true);\n            }\n          }\n        }, this)\n        .on(this._results, 'click', function (e) {\n          L.DomEvent.preventDefault(e);\n          L.DomEvent.stopPropagation(e);\n\n          var _selected = this._results.querySelectorAll('.leaflet-pelias-selected')[0];\n          if (_selected) {\n            L.DomUtil.removeClass(_selected, 'leaflet-pelias-selected');\n          }\n\n          var selected = e.target || e.srcElement; /* IE8 */\n          var findParent = function () {\n            if (!L.DomUtil.hasClass(selected, 'leaflet-pelias-result')) {\n              selected = selected.parentElement;\n              if (selected) {\n                findParent();\n              }\n            }\n            return selected;\n          };\n\n          // click event can be registered on the child nodes\n          // that does not have the required coords prop\n          // so its important to find the parent.\n          findParent();\n\n          // If nothing is selected, (e.g. it's a message, not a result),\n          // do nothing.\n          if (selected) {\n            L.DomUtil.addClass(selected, 'leaflet-pelias-selected');\n            this.setSelectedResult(selected, e);\n          }\n        }, this)\n        .on(this._results, 'mouseover', function (e) {\n          // Prevent scrolling over results list from zooming the map, if enabled\n          this._scrollWheelZoomEnabled = map.scrollWheelZoom.enabled();\n          if (this._scrollWheelZoomEnabled) {\n            map.scrollWheelZoom.disable();\n          }\n        }, this)\n        .on(this._results, 'mouseout', function (e) {\n          // Re-enable scroll wheel zoom (if previously enabled) after\n          // leaving the results box\n          if (this._scrollWheelZoomEnabled) {\n            map.scrollWheelZoom.enable();\n          }\n        }, this);\n\n      // Recalculate width of the input bar when window resizes\n      if (this.options.fullWidth) {\n        L.DomEvent.on(window, 'resize', function (e) {\n          if (L.DomUtil.hasClass(this._container, 'leaflet-pelias-expanded')) {\n            this.setFullWidth();\n          }\n        }, this);\n      }\n\n      L.DomEvent.on(this._map, 'mousedown', this._onMapInteraction, this);\n      L.DomEvent.on(this._map, 'touchstart', this._onMapInteraction, this);\n\n      L.DomEvent.disableClickPropagation(this._container);\n      if (map.attributionControl) {\n        map.attributionControl.addAttribution(this.options.attribution);\n      }\n      return container;\n    },\n\n    _onMapInteraction: function (event) {\n      this.blur();\n\n      // Only collapse if the input is clear, and is currently expanded.\n      // Disabled if expanded is set to true\n      if (!this.options.expanded) {\n        if (!this._input.value && L.DomUtil.hasClass(this._container, 'leaflet-pelias-expanded')) {\n          this.collapse();\n        }\n      }\n    },\n\n    onRemove: function (map) {\n      map.attributionControl.removeAttribution(this.options.attribution);\n    }\n  });\n\n  L.control.geocoder = function (apiKey, options) {\n    return new L.Control.Geocoder(apiKey, options);\n  };\n\n  /*\n   * AJAX Utility function (implements basic HTTP get)\n   */\n  var AJAX = {\n    serialize: function (params) {\n      var data = '';\n\n      for (var key in params) {\n        if (params.hasOwnProperty(key)) {\n          var param = params[key];\n          var type = param.toString();\n          var value;\n\n          if (data.length) {\n            data += '&';\n          }\n\n          switch (type) {\n            case '[object Array]':\n              value = (param[0].toString() === '[object Object]') ? JSON.stringify(param) : param.join(',');\n              break;\n            case '[object Object]':\n              value = JSON.stringify(param);\n              break;\n            case '[object Date]':\n              value = param.valueOf();\n              break;\n            default:\n              value = param;\n              break;\n          }\n\n          data += encodeURIComponent(key) + '=' + encodeURIComponent(value);\n        }\n      }\n\n      return data;\n    },\n    http_request: function (callback, context) {\n      if (window.XDomainRequest) {\n        return this.xdr(callback, context);\n      } else {\n        return this.xhr(callback, context);\n      }\n    },\n    xhr: function (callback, context) {\n      var xhr = new XMLHttpRequest();\n\n      xhr.onerror = function (e) {\n        xhr.onreadystatechange = L.Util.falseFn;\n        var error = {\n          code: xhr.status,\n          message: xhr.statusText\n        };\n\n        callback.call(context, error, null);\n      };\n\n      xhr.onreadystatechange = function () {\n        var response;\n        var error;\n\n        try {\n          response = JSON.parse(xhr.responseText);\n        } catch (e) {\n          response = null;\n          error = {\n            code: 500,\n            message: 'Parse Error'\n          };\n        }\n\n        if (xhr.readyState === 4) {\n          // Handle all non-200 responses first\n          if (xhr.status !== 200) {\n            error = {\n              code: xhr.status,\n              message: xhr.statusText\n            };\n            callback.call(context, error, response);\n          } else {\n            if (!error && response.error) {\n              error = response.error;\n            }\n\n            xhr.onerror = L.Util.falseFn;\n\n            callback.call(context, error, response);\n          }\n        }\n      };\n\n      return xhr;\n    },\n    xdr: function (callback, context) {\n      var xdr = new window.XDomainRequest();\n\n      xdr.onerror = function (e) {\n        xdr.onload = L.Util.falseFn;\n\n        // XDRs have no access to actual status codes\n        var error = {\n          code: 500,\n          message: 'XMLHttpRequest Error'\n        };\n        callback.call(context, error, null);\n      };\n\n      // XDRs have .onload instead of .onreadystatechange\n      xdr.onload = function () {\n        var response;\n        var error;\n\n        try {\n          response = JSON.parse(xdr.responseText);\n        } catch (e) {\n          response = null;\n          error = {\n            code: 500,\n            message: 'Parse Error'\n          };\n        }\n\n        if (!error && response.error) {\n          error = response.error;\n          response = null;\n        }\n\n        xdr.onerror = L.Util.falseFn;\n        callback.call(context, error, response);\n      };\n\n      return xdr;\n    },\n    request: function (url, params, callback, context) {\n      var paramString = this.serialize(params);\n      var httpRequest = this.http_request(callback, context);\n\n      httpRequest.open('GET', url + '?' + paramString);\n      if (httpRequest.constructor.name === 'XMLHttpRequest') {\n        httpRequest.setRequestHeader('Accept', 'application/json');\n      }\n\n      setTimeout(function () {\n        httpRequest.send(null);\n      }, 0);\n    }\n  };\n\n  /*\n   * throttle Utility function (borrowed from underscore)\n   */\n  function throttle (func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function () {\n      previous = options.leading === false ? 0 : new Date().getTime();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function () {\n      var now = new Date().getTime();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  }\n\n  /*\n   * escaping a string for regex Utility function\n   * from https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex\n   */\n  function escapeRegExp (str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n  }\n}));\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*\n * leaflet-geocoder-mapzen\n * Leaflet plugin to search (geocode) using Mapzen Search or your\n * own hosted version of the Pelias Geocoder API.\n *\n * License: MIT\n * (c) Mapzen\n */\n;(function (factory) { // eslint-disable-line no-extra-semi\n  var L;\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['leaflet'], factory);\n  } else if (typeof module !== 'undefined') {\n    // Node/CommonJS\n    L = require('leaflet');\n    module.exports = factory(L);\n  } else {\n    // Browser globals\n    if (typeof window.L === 'undefined') {\n      throw new Error('Leaflet must be loaded first');\n    }\n    factory(window.L);\n  }\n}(function (L) {\n  'use strict';\n\n  var MINIMUM_INPUT_LENGTH_FOR_AUTOCOMPLETE = 1;\n  var FULL_WIDTH_MARGIN = 20; // in pixels\n  var FULL_WIDTH_TOUCH_ADJUSTED_MARGIN = 4; // in pixels\n  var RESULTS_HEIGHT_MARGIN = 20; // in pixels\n  var API_RATE_LIMIT = 250; // in ms, throttled time between subsequent requests to API\n\n  L.Control.Geocoder = L.Control.extend({\n\n    version: '1.6.2',\n\n    includes: L.Mixin.Events,\n\n    options: {\n      position: 'topleft',\n      attribution: 'Geocoding by <a href=\"https://mapzen.com/projects/search/\">Mapzen</a>',\n      url: 'https://search.mapzen.com/v1',\n      placeholder: 'Search',\n      title: 'Search',\n      bounds: false,\n      focus: true,\n      layers: null,\n      panToPoint: true,\n      pointIcon: true, // 'images/point_icon.png',\n      polygonIcon: true, // 'images/polygon_icon.png',\n      fullWidth: 650,\n      markers: true,\n      expanded: false,\n      autocomplete: true,\n      place: false\n    },\n\n    initialize: function (apiKey, options) {\n      // For IE8 compatibility (if XDomainRequest is present),\n      // we set the default value of options.url to the protocol-relative\n      // version, because XDomainRequest does not allow http-to-https requests\n      // This is set first so it can always be overridden by the user\n      if (window.XDomainRequest) {\n        this.options.url = '//search.mapzen.com/v1';\n      }\n\n      // If the apiKey is omitted entirely and the\n      // first parameter is actually the options\n      if (typeof apiKey === 'object' && !!apiKey) {\n        options = apiKey;\n      } else {\n        this.apiKey = apiKey;\n      }\n\n      // Deprecation warnings\n      // If options.latlng is defined, warn. (Do not check for falsy values, because it can be set to false.)\n      if (options && typeof options.latlng !== 'undefined') {\n        // Set user-specified latlng to focus option, but don't overwrite if it's already there\n        if (typeof options.focus === 'undefined') {\n          options.focus = options.latlng;\n        }\n        console.log('[leaflet-geocoder-mapzen] DEPRECATION WARNING:',\n          'As of v1.6.0, the `latlng` option is deprecated. It has been renamed to `focus`. `latlng` will be removed in a future version.');\n      }\n\n      // Now merge user-specified options\n      L.Util.setOptions(this, options);\n      this.marker;\n      this.markers = [];\n    },\n\n    getLayers: function (params) {\n      var layers = this.options.layers;\n\n      if (!layers) {\n        return params;\n      }\n\n      params.layers = layers;\n      return params;\n    },\n\n    getBoundingBoxParam: function (params) {\n      /*\n       * this.options.bounds can be one of the following\n       * true //Boolean - take the map bounds\n       * false //Boolean - no bounds\n       * L.latLngBounds(...) //Object\n       * [[10, 10], [40, 60]] //Array\n      */\n      var bounds = this.options.bounds;\n\n      // If falsy, bail\n      if (!bounds) {\n        return params;\n      }\n\n      // If set to true, use map bounds\n      // If it is a valid L.LatLngBounds object, get its values\n      // If it is an array, try running it through L.LatLngBounds\n      if (bounds === true) {\n        bounds = this._map.getBounds();\n        params = makeParamsFromLeaflet(params, bounds);\n      } else if (typeof bounds === 'object' && bounds.isValid && bounds.isValid()) {\n        params = makeParamsFromLeaflet(params, bounds);\n      } else if (L.Util.isArray(bounds)) {\n        var latLngBounds = L.latLngBounds(bounds);\n        if (latLngBounds.isValid && latLngBounds.isValid()) {\n          params = makeParamsFromLeaflet(params, latLngBounds);\n        }\n      }\n\n      function makeParamsFromLeaflet (params, latLngBounds) {\n        params['boundary.rect.min_lon'] = latLngBounds.getWest();\n        params['boundary.rect.min_lat'] = latLngBounds.getSouth();\n        params['boundary.rect.max_lon'] = latLngBounds.getEast();\n        params['boundary.rect.max_lat'] = latLngBounds.getNorth();\n        return params;\n      }\n\n      return params;\n    },\n\n    getFocusParam: function (params) {\n      /**\n       * this.options.focus can be one of the following\n       * [50, 30]           // Array\n       * {lon: 30, lat: 50} // Object\n       * {lat: 50, lng: 30} // Object\n       * L.latLng(50, 30)   // Object\n       * true               // Boolean - take the map center\n       * false              // Boolean - No latlng to be considered\n       */\n      var focus = this.options.focus;\n\n      if (!focus) {\n        return params;\n      }\n\n      if (focus === true) {\n        // If focus option is Boolean true, use current map center\n        var mapCenter = this._map.getCenter();\n        params['focus.point.lat'] = mapCenter.lat;\n        params['focus.point.lon'] = mapCenter.lng;\n      } else if (typeof focus === 'object') {\n        // Accepts array, object and L.latLng form\n        // Constructs the latlng object using Leaflet's L.latLng()\n        // [50, 30]\n        // {lon: 30, lat: 50}\n        // {lat: 50, lng: 30}\n        // L.latLng(50, 30)\n        var latlng = L.latLng(focus);\n        params['focus.point.lat'] = latlng.lat;\n        params['focus.point.lon'] = latlng.lng;\n      }\n\n      return params;\n    },\n\n    // @method getParams(params: Object)\n    // Collects all the parameters in a single object from various options,\n    // including options.bounds, options.focus, options.layers, the api key,\n    // and any params that are provided as a argument to this function.\n    // Note that options.params will overwrite any of these\n    getParams: function (params) {\n      params = params || {};\n      params = this.getBoundingBoxParam(params);\n      params = this.getFocusParam(params);\n      params = this.getLayers(params);\n\n      // Search API key\n      if (this.apiKey) {\n        params.api_key = this.apiKey;\n      }\n\n      var newParams = this.options.params;\n\n      if (!newParams) {\n        return params;\n      }\n\n      if (typeof newParams === 'object') {\n        for (var prop in newParams) {\n          params[prop] = newParams[prop];\n        }\n      }\n\n      return params;\n    },\n\n    search: function (input) {\n      // Prevent lack of input from sending a malformed query to Pelias\n      if (!input) return;\n\n      var url = this.options.url + '/search';\n      var params = {\n        text: input\n      };\n\n      this.callPelias(url, params, 'search');\n    },\n\n    autocomplete: throttle(function (input) {\n      // Prevent lack of input from sending a malformed query to Pelias\n      if (!input) return;\n\n      var url = this.options.url + '/autocomplete';\n      var params = {\n        text: input\n      };\n\n      this.callPelias(url, params, 'autocomplete');\n    }, API_RATE_LIMIT),\n\n    place: function (id) {\n      // Prevent lack of input from sending a malformed query to Pelias\n      if (!id) return;\n\n      var url = this.options.url + '/place';\n      var params = {\n        ids: id\n      };\n\n      this.callPelias(url, params, 'place');\n    },\n\n    handlePlaceResponse: function (response) {\n      // Placeholder for handling place response\n    },\n\n    // Timestamp of the last response which was successfully rendered to the UI.\n    // The time represents when the request was *sent*, not when it was recieved.\n    maxReqTimestampRendered: new Date().getTime(),\n\n    callPelias: function (endpoint, params, type) {\n      params = this.getParams(params);\n\n      L.DomUtil.addClass(this._search, 'leaflet-pelias-loading');\n\n      // Track when the request began\n      var reqStartedAt = new Date().getTime();\n\n      AJAX.request(endpoint, params, function (err, results) {\n        L.DomUtil.removeClass(this._search, 'leaflet-pelias-loading');\n\n        if (err) {\n          var errorMessage;\n          switch (err.code) {\n            // Error codes.\n            // https://mapzen.com/documentation/search/http-status-codes/\n            case 403:\n              errorMessage = 'A valid API key is needed for this search feature.';\n              break;\n            case 404:\n              errorMessage = 'The search service cannot be found. :-(';\n              break;\n            case 408:\n              errorMessage = 'The search service took too long to respond. Try again in a second.';\n              break;\n            case 429:\n              errorMessage = 'There were too many requests. Try again in a second.';\n              break;\n            case 500:\n              errorMessage = 'The search service is not working right now. Please try again later.';\n              break;\n            case 502:\n              errorMessage = 'Connection lost. Please try again later.';\n              break;\n            // Note the status code is 0 if CORS is not enabled on the error response\n            default:\n              errorMessage = 'The search service is having problems :-(';\n              break;\n          }\n          this.showMessage(errorMessage);\n          this.fire('error', {\n            results: results,\n            endpoint: endpoint,\n            requestType: type,\n            params: params,\n            errorCode: err.code,\n            errorMessage: errorMessage\n          });\n        }\n\n        // There might be an error message from the geocoding service itself\n        if (results && results.geocoding && results.geocoding.errors) {\n          errorMessage = results.geocoding.errors[0];\n          this.showMessage(errorMessage);\n          this.fire('error', {\n            results: results,\n            endpoint: endpoint,\n            requestType: type,\n            params: params,\n            errorCode: err.code,\n            errorMessage: errorMessage\n          });\n          return;\n        }\n\n        // Autocomplete and search responses\n        if (results && results.features) {\n          // Check if request is stale:\n          // Only for autocomplete or search endpoints\n          // Ignore requests if input is currently blank\n          // Ignore requests that started before a request which has already\n          // been successfully rendered on to the UI.\n          if (type === 'autocomplete' || type === 'search') {\n            if (this._input.value === '' || this.maxReqTimestampRendered >= reqStartedAt) {\n              return;\n            } else {\n              // Record the timestamp of the request.\n              this.maxReqTimestampRendered = reqStartedAt;\n            }\n          }\n\n          // Placeholder: handle place response\n          if (type === 'place') {\n            this.handlePlaceResponse(results);\n          }\n\n          // Show results\n          if (type === 'autocomplete' || type === 'search') {\n            this.showResults(results.features, params.text);\n          }\n\n          // Fire event\n          this.fire('results', {\n            results: results,\n            endpoint: endpoint,\n            requestType: type,\n            params: params\n          });\n        }\n      }, this);\n    },\n\n    highlight: function (text, focus) {\n      var r = RegExp('(' + escapeRegExp(focus) + ')', 'gi');\n      return text.replace(r, '<strong>$1</strong>');\n    },\n\n    getIconType: function (layer) {\n      var pointIcon = this.options.pointIcon;\n      var polygonIcon = this.options.polygonIcon;\n      var classPrefix = 'leaflet-pelias-layer-icon-';\n\n      if (layer.match('venue') || layer.match('address')) {\n        if (pointIcon === true) {\n          return {\n            type: 'class',\n            value: classPrefix + 'point'\n          };\n        } else if (pointIcon === false) {\n          return false;\n        } else {\n          return {\n            type: 'image',\n            value: pointIcon\n          };\n        }\n      } else {\n        if (polygonIcon === true) {\n          return {\n            type: 'class',\n            value: classPrefix + 'polygon'\n          };\n        } else if (polygonIcon === false) {\n          return false;\n        } else {\n          return {\n            type: 'image',\n            value: polygonIcon\n          };\n        }\n      }\n    },\n\n    showResults: function (features, input) {\n      // Exit function if there are no features\n      if (features.length === 0) {\n        this.showMessage('No results were found.');\n        return;\n      }\n\n      var resultsContainer = this._results;\n\n      // Reset and display results container\n      resultsContainer.innerHTML = '';\n      resultsContainer.style.display = 'block';\n      // manage result box height\n      resultsContainer.style.maxHeight = (this._map.getSize().y - resultsContainer.offsetTop - this._container.offsetTop - RESULTS_HEIGHT_MARGIN) + 'px';\n\n      var list = L.DomUtil.create('ul', 'leaflet-pelias-list', resultsContainer);\n\n      for (var i = 0, j = features.length; i < j; i++) {\n        var feature = features[i];\n        var resultItem = L.DomUtil.create('li', 'leaflet-pelias-result', list);\n\n        resultItem.feature = feature;\n        resultItem.layer = feature.properties.layer;\n\n        // Deprecated\n        // Use L.GeoJSON.coordsToLatLng(resultItem.feature.geometry.coordinates) instead\n        // This returns a L.LatLng object that can be used throughout Leaflet\n        resultItem.coords = feature.geometry.coordinates;\n\n        var icon = this.getIconType(feature.properties.layer);\n        if (icon) {\n          // Point or polygon icon\n          // May be a class or an image path\n          var layerIconContainer = L.DomUtil.create('span', 'leaflet-pelias-layer-icon-container', resultItem);\n          var layerIcon;\n\n          if (icon.type === 'class') {\n            layerIcon = L.DomUtil.create('div', 'leaflet-pelias-layer-icon ' + icon.value, layerIconContainer);\n          } else {\n            layerIcon = L.DomUtil.create('img', 'leaflet-pelias-layer-icon', layerIconContainer);\n            layerIcon.src = icon.value;\n          }\n\n          layerIcon.title = 'layer: ' + feature.properties.layer;\n        }\n\n        resultItem.innerHTML += this.highlight(feature.properties.label, input);\n      }\n    },\n\n    showMessage: function (text) {\n      var resultsContainer = this._results;\n\n      // Reset and display results container\n      resultsContainer.innerHTML = '';\n      resultsContainer.style.display = 'block';\n\n      var messageEl = L.DomUtil.create('div', 'leaflet-pelias-message', resultsContainer);\n\n      // Set text. This is the most cross-browser compatible method\n      // and avoids the issues we have detecting either innerText vs textContent\n      // (e.g. Firefox cannot detect textContent property on elements, but it's there)\n      messageEl.appendChild(document.createTextNode(text));\n    },\n\n    removeMarkers: function () {\n      if (this.options.markers) {\n        for (var i = 0; i < this.markers.length; i++) {\n          this._map.removeLayer(this.markers[i]);\n        }\n        this.markers = [];\n      }\n    },\n\n    showMarker: function (text, latlng) {\n      this._map.setView(latlng, this._map.getZoom() || 8);\n\n      var markerOptions = (typeof this.options.markers === 'object') ? this.options.markers : {};\n\n      if (this.options.markers) {\n        this.marker = new L.marker(latlng, markerOptions).bindPopup(text); // eslint-disable-line new-cap\n        this._map.addLayer(this.marker);\n        this.markers.push(this.marker);\n        this.marker.openPopup();\n      }\n    },\n\n    /**\n     * Fits the map view to a given bounding box.\n     * Mapzen Search / Pelias returns the 'bbox' property on 'feature'. It is\n     * as an array of four numbers:\n     *   [\n     *     0: southwest longitude,\n     *     1: southwest latitude,\n     *     2: northeast longitude,\n     *     3: northeast latitude\n     *   ]\n     * This method expects the array to be passed directly and it will be converted\n     * to a boundary parameter for Leaflet's fitBounds().\n     */\n    fitBoundingBox: function (bbox) {\n      this._map.fitBounds([\n        [ bbox[1], bbox[0] ],\n        [ bbox[3], bbox[2] ]\n      ], {\n        animate: true,\n        maxZoom: 16\n      });\n    },\n\n    setSelectedResult: function (selected, originalEvent) {\n      var latlng = L.GeoJSON.coordsToLatLng(selected.feature.geometry.coordinates);\n      this._input.value = selected.innerText || selected.textContent;\n      if (selected.feature.bbox) {\n        this.removeMarkers();\n        this.fitBoundingBox(selected.feature.bbox);\n      } else {\n        this.removeMarkers();\n        this.showMarker(selected.innerHTML, latlng);\n      }\n      this.fire('select', {\n        originalEvent: originalEvent,\n        latlng: latlng,\n        feature: selected.feature\n      });\n      this.blur();\n\n      if (this.options.place) {\n        this.place(selected.feature.properties.gid);\n      }\n    },\n\n    resetInput: function () {\n      this._input.value = '';\n      L.DomUtil.addClass(this._reset, 'leaflet-pelias-hidden');\n      this.removeMarkers();\n      this._input.focus();\n      this.fire('reset');\n    },\n\n    // Convenience function for focusing on the input\n    // This is meant for external use.\n    focus: function () {\n      // If not expanded, expand this first\n      if (!L.DomUtil.hasClass(this._container, 'leaflet-pelias-expanded')) {\n        this.expand();\n      }\n      this._input.focus();\n    },\n\n    // Removes focus from geocoder control\n    blur: function () {\n      this._input.blur();\n      this.clearResults();\n      if (this._input.value === '' && this._results.style.display !== 'none') {\n        L.DomUtil.addClass(this._reset, 'leaflet-pelias-hidden');\n        if (!this.options.expanded) {\n          this.collapse();\n        }\n      }\n    },\n\n    clearResults: function (force) {\n      // Hide results from view\n      this._results.style.display = 'none';\n\n      // Destroy contents if input has also cleared\n      // OR if force is true\n      if (this._input.value === '' || force === true) {\n        this._results.innerHTML = '';\n      }\n    },\n\n    expand: function () {\n      L.DomUtil.addClass(this._container, 'leaflet-pelias-expanded');\n      this.setFullWidth();\n      this.fire('expand');\n    },\n\n    collapse: function () {\n      // 'expanded' options check happens outside of this function now\n      // So it's now possible for a script to force-collapse a geocoder\n      // that otherwise defaults to the always-expanded state\n      L.DomUtil.removeClass(this._container, 'leaflet-pelias-expanded');\n      this._input.blur();\n      this.clearFullWidth();\n      this.clearResults();\n      this.fire('collapse');\n    },\n\n    // Set full width of expanded input, if enabled\n    setFullWidth: function () {\n      if (this.options.fullWidth) {\n        // If fullWidth setting is a number, only expand if map container\n        // is smaller than that breakpoint. Otherwise, clear width\n        // Always ask map to invalidate and recalculate size first\n        this._map.invalidateSize();\n        var mapWidth = this._map.getSize().x;\n        var touchAdjustment = L.Browser.touch ? FULL_WIDTH_TOUCH_ADJUSTED_MARGIN : 0;\n        var width = mapWidth - FULL_WIDTH_MARGIN - touchAdjustment;\n        if (typeof this.options.fullWidth === 'number' && mapWidth >= window.parseInt(this.options.fullWidth, 10)) {\n          this.clearFullWidth();\n          return;\n        }\n        this._container.style.width = width.toString() + 'px';\n      }\n    },\n\n    clearFullWidth: function () {\n      // Clear set width, if any\n      if (this.options.fullWidth) {\n        this._container.style.width = '';\n      }\n    },\n\n    onAdd: function (map) {\n      var container = L.DomUtil.create('div',\n          'leaflet-pelias-control leaflet-bar leaflet-control');\n\n      this._body = document.body || document.getElementsByTagName('body')[0];\n      this._container = container;\n      this._input = L.DomUtil.create('input', 'leaflet-pelias-input', this._container);\n      this._input.spellcheck = false;\n\n      // Only set if title option is not null or falsy\n      if (this.options.title) {\n        this._input.title = this.options.title;\n      }\n\n      // Only set if placeholder option is not null or falsy\n      if (this.options.placeholder) {\n        this._input.placeholder = this.options.placeholder;\n      }\n\n      this._search = L.DomUtil.create('a', 'leaflet-pelias-search-icon', this._container);\n      this._reset = L.DomUtil.create('div', 'leaflet-pelias-close leaflet-pelias-hidden', this._container);\n      this._reset.innerHTML = '';\n      this._reset.title = 'Reset';\n\n      this._results = L.DomUtil.create('div', 'leaflet-pelias-results leaflet-bar', this._container);\n\n      if (this.options.expanded) {\n        this.expand();\n      }\n\n      L.DomEvent\n        .on(this._container, 'click', function (e) {\n          // Child elements with 'click' listeners should call\n          // stopPropagation() to prevent that event from bubbling to\n          // the container & causing it to fire too greedily\n          this._input.focus();\n        }, this)\n        .on(this._input, 'focus', function (e) {\n          if (this._input.value && this._results.children.length) {\n            this._results.style.display = 'block';\n          }\n        }, this)\n        .on(this._map, 'click', function (e) {\n          // Does what you might expect a _input.blur() listener might do,\n          // but since that would fire for any reason (e.g. clicking a result)\n          // what you really want is to blur from the control by listening to clicks on the map\n          this.blur();\n        }, this)\n        .on(this._search, 'click', function (e) {\n          L.DomEvent.stopPropagation(e);\n\n          // Toggles expanded state of container on click of search icon\n          if (L.DomUtil.hasClass(this._container, 'leaflet-pelias-expanded')) {\n            // If expanded option is true, just focus the input\n            if (this.options.expanded === true) {\n              this._input.focus();\n              return;\n            } else {\n              // Otherwise, toggle to hidden state\n              L.DomUtil.addClass(this._reset, 'leaflet-pelias-hidden');\n              this.collapse();\n            }\n          } else {\n            // If not currently expanded, clicking here always expands it\n            if (this._input.value.length > 0) {\n              L.DomUtil.removeClass(this._reset, 'leaflet-pelias-hidden');\n            }\n            this.expand();\n            this._input.focus();\n          }\n        }, this)\n        .on(this._reset, 'click', function (e) {\n          this.resetInput();\n          this.clearResults();\n          L.DomEvent.stopPropagation(e);\n        }, this)\n        .on(this._input, 'keydown', function (e) {\n          var list = this._results.querySelectorAll('.leaflet-pelias-result');\n          var selected = this._results.querySelectorAll('.leaflet-pelias-selected')[0];\n          var selectedPosition;\n          var self = this;\n          var panToPoint = function (shouldPan) {\n            var _selected = self._results.querySelectorAll('.leaflet-pelias-selected')[0];\n            if (_selected && shouldPan) {\n              if (_selected.feature.bbox) {\n                self.removeMarkers();\n                self.fitBoundingBox(_selected.feature.bbox);\n              } else {\n                self.removeMarkers();\n                self.showMarker(_selected.innerHTML, L.GeoJSON.coordsToLatLng(_selected.feature.geometry.coordinates));\n              }\n            }\n          };\n\n          var scrollSelectedResultIntoView = function () {\n            var _selected = self._results.querySelectorAll('.leaflet-pelias-selected')[0];\n            var _selectedRect = _selected.getBoundingClientRect();\n            var _resultsRect = self._results.getBoundingClientRect();\n            // Is the selected element not visible?\n            if (_selectedRect.bottom > _resultsRect.bottom) {\n              self._results.scrollTop = _selected.offsetTop + _selected.offsetHeight - self._results.offsetHeight;\n            } else if (_selectedRect.top < _resultsRect.top) {\n              self._results.scrollTop = _selected.offsetTop;\n            }\n          };\n\n          for (var i = 0; i < list.length; i++) {\n            if (list[i] === selected) {\n              selectedPosition = i;\n              break;\n            }\n          }\n\n          // TODO cleanup\n          switch (e.keyCode) {\n            // 13 = enter\n            case 13:\n              if (selected) {\n                this.setSelectedResult(selected, e);\n              } else {\n                // perform a full text search on enter\n                var text = (e.target || e.srcElement).value;\n                this.search(text);\n              }\n              L.DomEvent.preventDefault(e);\n              break;\n            // 38 = up arrow\n            case 38:\n              // Ignore key if there are no results or if list is not visible\n              if (list.length === 0 || this._results.style.display === 'none') {\n                return;\n              }\n\n              if (selected) {\n                L.DomUtil.removeClass(selected, 'leaflet-pelias-selected');\n              }\n\n              var previousItem = list[selectedPosition - 1];\n              var highlighted = (selected && previousItem) ? previousItem : list[list.length - 1]; // eslint-disable-line no-redeclare\n\n              L.DomUtil.addClass(highlighted, 'leaflet-pelias-selected');\n              scrollSelectedResultIntoView();\n              panToPoint(this.options.panToPoint);\n              this.fire('highlight', {\n                originalEvent: e,\n                latlng: L.GeoJSON.coordsToLatLng(highlighted.feature.geometry.coordinates),\n                feature: highlighted.feature\n              });\n\n              L.DomEvent.preventDefault(e);\n              break;\n            // 40 = down arrow\n            case 40:\n              // Ignore key if there are no results or if list is not visible\n              if (list.length === 0 || this._results.style.display === 'none') {\n                return;\n              }\n\n              if (selected) {\n                L.DomUtil.removeClass(selected, 'leaflet-pelias-selected');\n              }\n\n              var nextItem = list[selectedPosition + 1];\n              var highlighted = (selected && nextItem) ? nextItem : list[0]; // eslint-disable-line no-redeclare\n\n              L.DomUtil.addClass(highlighted, 'leaflet-pelias-selected');\n              scrollSelectedResultIntoView();\n              panToPoint(this.options.panToPoint);\n              this.fire('highlight', {\n                originalEvent: e,\n                latlng: L.GeoJSON.coordsToLatLng(highlighted.feature.geometry.coordinates),\n                feature: highlighted.feature\n              });\n\n              L.DomEvent.preventDefault(e);\n              break;\n            // all other keys\n            default:\n              break;\n          }\n        }, this)\n        .on(this._input, 'keyup', function (e) {\n          var key = e.which || e.keyCode;\n          var text = (e.target || e.srcElement).value;\n\n          if (text.length > 0) {\n            L.DomUtil.removeClass(this._reset, 'leaflet-pelias-hidden');\n          } else {\n            L.DomUtil.addClass(this._reset, 'leaflet-pelias-hidden');\n          }\n\n          // Ignore all further action if the keycode matches an arrow\n          // key (handled via keydown event)\n          if (key === 13 || key === 38 || key === 40) {\n            return;\n          }\n\n          // keyCode 27 = esc key (esc should clear results)\n          if (key === 27) {\n            // If input is blank or results have already been cleared\n            // (perhaps due to a previous 'esc') then pressing esc at\n            // this point will blur from input as well.\n            if (text.length === 0 || this._results.style.display === 'none') {\n              this._input.blur();\n\n              if (!this.options.expanded && L.DomUtil.hasClass(this._container, 'leaflet-pelias-expanded')) {\n                this.collapse();\n              }\n            }\n\n            // Clears results\n            this.clearResults(true);\n            L.DomUtil.removeClass(this._search, 'leaflet-pelias-loading');\n            return;\n          }\n\n          if (text !== this._lastValue) {\n            this._lastValue = text;\n\n            if (text.length >= MINIMUM_INPUT_LENGTH_FOR_AUTOCOMPLETE && this.options.autocomplete === true) {\n              this.autocomplete(text);\n            } else {\n              this.clearResults(true);\n            }\n          }\n        }, this)\n        .on(this._results, 'click', function (e) {\n          L.DomEvent.preventDefault(e);\n          L.DomEvent.stopPropagation(e);\n\n          var _selected = this._results.querySelectorAll('.leaflet-pelias-selected')[0];\n          if (_selected) {\n            L.DomUtil.removeClass(_selected, 'leaflet-pelias-selected');\n          }\n\n          var selected = e.target || e.srcElement; /* IE8 */\n          var findParent = function () {\n            if (!L.DomUtil.hasClass(selected, 'leaflet-pelias-result')) {\n              selected = selected.parentElement;\n              if (selected) {\n                findParent();\n              }\n            }\n            return selected;\n          };\n\n          // click event can be registered on the child nodes\n          // that does not have the required coords prop\n          // so its important to find the parent.\n          findParent();\n\n          // If nothing is selected, (e.g. it's a message, not a result),\n          // do nothing.\n          if (selected) {\n            L.DomUtil.addClass(selected, 'leaflet-pelias-selected');\n            this.setSelectedResult(selected, e);\n          }\n        }, this)\n        .on(this._results, 'mouseover', function (e) {\n          // Prevent scrolling over results list from zooming the map, if enabled\n          this._scrollWheelZoomEnabled = map.scrollWheelZoom.enabled();\n          if (this._scrollWheelZoomEnabled) {\n            map.scrollWheelZoom.disable();\n          }\n        }, this)\n        .on(this._results, 'mouseout', function (e) {\n          // Re-enable scroll wheel zoom (if previously enabled) after\n          // leaving the results box\n          if (this._scrollWheelZoomEnabled) {\n            map.scrollWheelZoom.enable();\n          }\n        }, this);\n\n      // Recalculate width of the input bar when window resizes\n      if (this.options.fullWidth) {\n        L.DomEvent.on(window, 'resize', function (e) {\n          if (L.DomUtil.hasClass(this._container, 'leaflet-pelias-expanded')) {\n            this.setFullWidth();\n          }\n        }, this);\n      }\n\n      L.DomEvent.on(this._map, 'mousedown', this._onMapInteraction, this);\n      L.DomEvent.on(this._map, 'touchstart', this._onMapInteraction, this);\n\n      L.DomEvent.disableClickPropagation(this._container);\n      if (map.attributionControl) {\n        map.attributionControl.addAttribution(this.options.attribution);\n      }\n      return container;\n    },\n\n    _onMapInteraction: function (event) {\n      this.blur();\n\n      // Only collapse if the input is clear, and is currently expanded.\n      // Disabled if expanded is set to true\n      if (!this.options.expanded) {\n        if (!this._input.value && L.DomUtil.hasClass(this._container, 'leaflet-pelias-expanded')) {\n          this.collapse();\n        }\n      }\n    },\n\n    onRemove: function (map) {\n      map.attributionControl.removeAttribution(this.options.attribution);\n    }\n  });\n\n  L.control.geocoder = function (apiKey, options) {\n    return new L.Control.Geocoder(apiKey, options);\n  };\n\n  /*\n   * AJAX Utility function (implements basic HTTP get)\n   */\n  var AJAX = {\n    serialize: function (params) {\n      var data = '';\n\n      for (var key in params) {\n        if (params.hasOwnProperty(key)) {\n          var param = params[key];\n          var type = param.toString();\n          var value;\n\n          if (data.length) {\n            data += '&';\n          }\n\n          switch (type) {\n            case '[object Array]':\n              value = (param[0].toString() === '[object Object]') ? JSON.stringify(param) : param.join(',');\n              break;\n            case '[object Object]':\n              value = JSON.stringify(param);\n              break;\n            case '[object Date]':\n              value = param.valueOf();\n              break;\n            default:\n              value = param;\n              break;\n          }\n\n          data += encodeURIComponent(key) + '=' + encodeURIComponent(value);\n        }\n      }\n\n      return data;\n    },\n    http_request: function (callback, context) {\n      if (window.XDomainRequest) {\n        return this.xdr(callback, context);\n      } else {\n        return this.xhr(callback, context);\n      }\n    },\n    xhr: function (callback, context) {\n      var xhr = new XMLHttpRequest();\n\n      xhr.onerror = function (e) {\n        xhr.onreadystatechange = L.Util.falseFn;\n        var error = {\n          code: xhr.status,\n          message: xhr.statusText\n        };\n\n        callback.call(context, error, null);\n      };\n\n      xhr.onreadystatechange = function () {\n        var response;\n        var error;\n\n        try {\n          response = JSON.parse(xhr.responseText);\n        } catch (e) {\n          response = null;\n          error = {\n            code: 500,\n            message: 'Parse Error'\n          };\n        }\n\n        if (xhr.readyState === 4) {\n          // Handle all non-200 responses first\n          if (xhr.status !== 200) {\n            error = {\n              code: xhr.status,\n              message: xhr.statusText\n            };\n            callback.call(context, error, response);\n          } else {\n            if (!error && response.error) {\n              error = response.error;\n            }\n\n            xhr.onerror = L.Util.falseFn;\n\n            callback.call(context, error, response);\n          }\n        }\n      };\n\n      return xhr;\n    },\n    xdr: function (callback, context) {\n      var xdr = new window.XDomainRequest();\n\n      xdr.onerror = function (e) {\n        xdr.onload = L.Util.falseFn;\n\n        // XDRs have no access to actual status codes\n        var error = {\n          code: 500,\n          message: 'XMLHttpRequest Error'\n        };\n        callback.call(context, error, null);\n      };\n\n      // XDRs have .onload instead of .onreadystatechange\n      xdr.onload = function () {\n        var response;\n        var error;\n\n        try {\n          response = JSON.parse(xdr.responseText);\n        } catch (e) {\n          response = null;\n          error = {\n            code: 500,\n            message: 'Parse Error'\n          };\n        }\n\n        if (!error && response.error) {\n          error = response.error;\n          response = null;\n        }\n\n        xdr.onerror = L.Util.falseFn;\n        callback.call(context, error, response);\n      };\n\n      return xdr;\n    },\n    request: function (url, params, callback, context) {\n      var paramString = this.serialize(params);\n      var httpRequest = this.http_request(callback, context);\n\n      httpRequest.open('GET', url + '?' + paramString);\n      if (httpRequest.constructor.name === 'XMLHttpRequest') {\n        httpRequest.setRequestHeader('Accept', 'application/json');\n      }\n\n      setTimeout(function () {\n        httpRequest.send(null);\n      }, 0);\n    }\n  };\n\n  /*\n   * throttle Utility function (borrowed from underscore)\n   */\n  function throttle (func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function () {\n      previous = options.leading === false ? 0 : new Date().getTime();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function () {\n      var now = new Date().getTime();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  }\n\n  /*\n   * escaping a string for regex Utility function\n   * from https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex\n   */\n  function escapeRegExp (str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n  }\n}));\n\n},{\"leaflet\":5}],2:[function(require,module,exports){\n(function(window) {\n\tvar HAS_HASHCHANGE = (function() {\n\t\tvar doc_mode = window.documentMode;\n\t\treturn ('onhashchange' in window) &&\n\t\t\t(doc_mode === undefined || doc_mode > 7);\n\t})();\n\n\tL.Hash = function(map) {\n\t\tthis.onHashChange = L.Util.bind(this.onHashChange, this);\n\n\t\tif (map) {\n\t\t\tthis.init(map);\n\t\t}\n\t};\n\n\tL.Hash.parseHash = function(hash) {\n\t\tif(hash.indexOf('#') === 0) {\n\t\t\thash = hash.substr(1);\n\t\t}\n\t\tvar args = hash.split(\"/\");\n\t\tif (args.length == 3) {\n\t\t\tvar zoom = parseInt(args[0], 10),\n\t\t\tlat = parseFloat(args[1]),\n\t\t\tlon = parseFloat(args[2]);\n\t\t\tif (isNaN(zoom) || isNaN(lat) || isNaN(lon)) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tcenter: new L.LatLng(lat, lon),\n\t\t\t\t\tzoom: zoom\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tL.Hash.formatHash = function(map) {\n\t\tvar center = map.getCenter(),\n\t\t    zoom = map.getZoom(),\n\t\t    precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));\n\n\t\treturn \"#\" + [zoom,\n\t\t\tcenter.lat.toFixed(precision),\n\t\t\tcenter.lng.toFixed(precision)\n\t\t].join(\"/\");\n\t},\n\n\tL.Hash.prototype = {\n\t\tmap: null,\n\t\tlastHash: null,\n\n\t\tparseHash: L.Hash.parseHash,\n\t\tformatHash: L.Hash.formatHash,\n\n\t\tinit: function(map) {\n\t\t\tthis.map = map;\n\n\t\t\t// reset the hash\n\t\t\tthis.lastHash = null;\n\t\t\tthis.onHashChange();\n\n\t\t\tif (!this.isListening) {\n\t\t\t\tthis.startListening();\n\t\t\t}\n\t\t},\n\n\t\tremoveFrom: function(map) {\n\t\t\tif (this.changeTimeout) {\n\t\t\t\tclearTimeout(this.changeTimeout);\n\t\t\t}\n\n\t\t\tif (this.isListening) {\n\t\t\t\tthis.stopListening();\n\t\t\t}\n\n\t\t\tthis.map = null;\n\t\t},\n\n\t\tonMapMove: function() {\n\t\t\t// bail if we're moving the map (updating from a hash),\n\t\t\t// or if the map is not yet loaded\n\n\t\t\tif (this.movingMap || !this.map._loaded) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar hash = this.formatHash(this.map);\n\t\t\tif (this.lastHash != hash) {\n\t\t\t\tlocation.replace(hash);\n\t\t\t\tthis.lastHash = hash;\n\t\t\t}\n\t\t},\n\n\t\tmovingMap: false,\n\t\tupdate: function() {\n\t\t\tvar hash = location.hash;\n\t\t\tif (hash === this.lastHash) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar parsed = this.parseHash(hash);\n\t\t\tif (parsed) {\n\t\t\t\tthis.movingMap = true;\n\n\t\t\t\tthis.map.setView(parsed.center, parsed.zoom);\n\n\t\t\t\tthis.movingMap = false;\n\t\t\t} else {\n\t\t\t\tthis.onMapMove(this.map);\n\t\t\t}\n\t\t},\n\n\t\t// defer hash change updates every 100ms\n\t\tchangeDefer: 100,\n\t\tchangeTimeout: null,\n\t\tonHashChange: function() {\n\t\t\t// throttle calls to update() so that they only happen every\n\t\t\t// `changeDefer` ms\n\t\t\tif (!this.changeTimeout) {\n\t\t\t\tvar that = this;\n\t\t\t\tthis.changeTimeout = setTimeout(function() {\n\t\t\t\t\tthat.update();\n\t\t\t\t\tthat.changeTimeout = null;\n\t\t\t\t}, this.changeDefer);\n\t\t\t}\n\t\t},\n\n\t\tisListening: false,\n\t\thashChangeInterval: null,\n\t\tstartListening: function() {\n\t\t\tthis.map.on(\"moveend\", this.onMapMove, this);\n\n\t\t\tif (HAS_HASHCHANGE) {\n\t\t\t\tL.DomEvent.addListener(window, \"hashchange\", this.onHashChange);\n\t\t\t} else {\n\t\t\t\tclearInterval(this.hashChangeInterval);\n\t\t\t\tthis.hashChangeInterval = setInterval(this.onHashChange, 50);\n\t\t\t}\n\t\t\tthis.isListening = true;\n\t\t},\n\n\t\tstopListening: function() {\n\t\t\tthis.map.off(\"moveend\", this.onMapMove, this);\n\n\t\t\tif (HAS_HASHCHANGE) {\n\t\t\t\tL.DomEvent.removeListener(window, \"hashchange\", this.onHashChange);\n\t\t\t} else {\n\t\t\t\tclearInterval(this.hashChangeInterval);\n\t\t\t}\n\t\t\tthis.isListening = false;\n\t\t}\n\t};\n\tL.hash = function(map) {\n\t\treturn new L.Hash(map);\n\t};\n\tL.Map.prototype.addHash = function() {\n\t\tthis._hash = L.hash(this);\n\t};\n\tL.Map.prototype.removeHash = function() {\n\t\tthis._hash.removeFrom();\n\t};\n})(window);\n\n},{}],3:[function(require,module,exports){\n/*\n Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com\n (c) 2010-2013, Vladimir Agafonkin\n (c) 2010-2011, CloudMade\n*/\n(function (window, document, undefined) {\r\nvar oldL = window.L,\r\n    L = {};\r\n\r\nL.version = '0.7.7';\r\n\r\n// define Leaflet for Node module pattern loaders, including Browserify\r\nif (typeof module === 'object' && typeof module.exports === 'object') {\r\n\tmodule.exports = L;\r\n\r\n// define Leaflet as an AMD module\r\n} else if (typeof define === 'function' && define.amd) {\r\n\tdefine(L);\r\n}\r\n\r\n// define Leaflet as a global L variable, saving the original L to restore later if needed\r\n\r\nL.noConflict = function () {\r\n\twindow.L = oldL;\r\n\treturn this;\r\n};\r\n\r\nwindow.L = L;\r\n\n\n/*\r\n * L.Util contains various utility functions used throughout Leaflet code.\r\n */\r\n\r\nL.Util = {\r\n\textend: function (dest) { // (Object[, Object, ...]) ->\r\n\t\tvar sources = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, j, len, src;\r\n\r\n\t\tfor (j = 0, len = sources.length; j < len; j++) {\r\n\t\t\tsrc = sources[j] || {};\r\n\t\t\tfor (i in src) {\r\n\t\t\t\tif (src.hasOwnProperty(i)) {\r\n\t\t\t\t\tdest[i] = src[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dest;\r\n\t},\r\n\r\n\tbind: function (fn, obj) { // (Function, Object) -> Function\r\n\t\tvar args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;\r\n\t\treturn function () {\r\n\t\t\treturn fn.apply(obj, args || arguments);\r\n\t\t};\r\n\t},\r\n\r\n\tstamp: (function () {\r\n\t\tvar lastId = 0,\r\n\t\t    key = '_leaflet_id';\r\n\t\treturn function (obj) {\r\n\t\t\tobj[key] = obj[key] || ++lastId;\r\n\t\t\treturn obj[key];\r\n\t\t};\r\n\t}()),\r\n\r\n\tinvokeEach: function (obj, method, context) {\r\n\t\tvar i, args;\r\n\r\n\t\tif (typeof obj === 'object') {\r\n\t\t\targs = Array.prototype.slice.call(arguments, 3);\r\n\r\n\t\t\tfor (i in obj) {\r\n\t\t\t\tmethod.apply(context, [i, obj[i]].concat(args));\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\tlimitExecByInterval: function (fn, time, context) {\r\n\t\tvar lock, execOnUnlock;\r\n\r\n\t\treturn function wrapperFn() {\r\n\t\t\tvar args = arguments;\r\n\r\n\t\t\tif (lock) {\r\n\t\t\t\texecOnUnlock = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlock = true;\r\n\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tlock = false;\r\n\r\n\t\t\t\tif (execOnUnlock) {\r\n\t\t\t\t\twrapperFn.apply(context, args);\r\n\t\t\t\t\texecOnUnlock = false;\r\n\t\t\t\t}\r\n\t\t\t}, time);\r\n\r\n\t\t\tfn.apply(context, args);\r\n\t\t};\r\n\t},\r\n\r\n\tfalseFn: function () {\r\n\t\treturn false;\r\n\t},\r\n\r\n\tformatNum: function (num, digits) {\r\n\t\tvar pow = Math.pow(10, digits || 5);\r\n\t\treturn Math.round(num * pow) / pow;\r\n\t},\r\n\r\n\ttrim: function (str) {\r\n\t\treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n\t},\r\n\r\n\tsplitWords: function (str) {\r\n\t\treturn L.Util.trim(str).split(/\\s+/);\r\n\t},\r\n\r\n\tsetOptions: function (obj, options) {\r\n\t\tobj.options = L.extend({}, obj.options, options);\r\n\t\treturn obj.options;\r\n\t},\r\n\r\n\tgetParamString: function (obj, existingUrl, uppercase) {\r\n\t\tvar params = [];\r\n\t\tfor (var i in obj) {\r\n\t\t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n\t\t}\r\n\t\treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n\t},\r\n\ttemplate: function (str, data) {\r\n\t\treturn str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\r\n\t\t\tvar value = data[key];\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tthrow new Error('No value provided for variable ' + str);\r\n\t\t\t} else if (typeof value === 'function') {\r\n\t\t\t\tvalue = value(data);\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t});\r\n\t},\r\n\r\n\tisArray: Array.isArray || function (obj) {\r\n\t\treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n\t},\r\n\r\n\temptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\r\n};\r\n\r\n(function () {\r\n\r\n\t// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n\tfunction getPrefixed(name) {\r\n\t\tvar i, fn,\r\n\t\t    prefixes = ['webkit', 'moz', 'o', 'ms'];\r\n\r\n\t\tfor (i = 0; i < prefixes.length && !fn; i++) {\r\n\t\t\tfn = window[prefixes[i] + name];\r\n\t\t}\r\n\r\n\t\treturn fn;\r\n\t}\r\n\r\n\tvar lastTime = 0;\r\n\r\n\tfunction timeoutDefer(fn) {\r\n\t\tvar time = +new Date(),\r\n\t\t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n\t\tlastTime = time + timeToCall;\r\n\t\treturn window.setTimeout(fn, timeToCall);\r\n\t}\r\n\r\n\tvar requestFn = window.requestAnimationFrame ||\r\n\t        getPrefixed('RequestAnimationFrame') || timeoutDefer;\r\n\r\n\tvar cancelFn = window.cancelAnimationFrame ||\r\n\t        getPrefixed('CancelAnimationFrame') ||\r\n\t        getPrefixed('CancelRequestAnimationFrame') ||\r\n\t        function (id) { window.clearTimeout(id); };\r\n\r\n\r\n\tL.Util.requestAnimFrame = function (fn, context, immediate, element) {\r\n\t\tfn = L.bind(fn, context);\r\n\r\n\t\tif (immediate && requestFn === timeoutDefer) {\r\n\t\t\tfn();\r\n\t\t} else {\r\n\t\t\treturn requestFn.call(window, fn, element);\r\n\t\t}\r\n\t};\r\n\r\n\tL.Util.cancelAnimFrame = function (id) {\r\n\t\tif (id) {\r\n\t\t\tcancelFn.call(window, id);\r\n\t\t}\r\n\t};\r\n\r\n}());\r\n\r\n// shortcuts for most used utility functions\r\nL.extend = L.Util.extend;\r\nL.bind = L.Util.bind;\r\nL.stamp = L.Util.stamp;\r\nL.setOptions = L.Util.setOptions;\r\n\n\n/*\r\n * L.Class powers the OOP facilities of the library.\r\n * Thanks to John Resig and Dean Edwards for inspiration!\r\n */\r\n\r\nL.Class = function () {};\r\n\r\nL.Class.extend = function (props) {\r\n\r\n\t// extended class with the new prototype\r\n\tvar NewClass = function () {\r\n\r\n\t\t// call the constructor\r\n\t\tif (this.initialize) {\r\n\t\t\tthis.initialize.apply(this, arguments);\r\n\t\t}\r\n\r\n\t\t// call all constructor hooks\r\n\t\tif (this._initHooks) {\r\n\t\t\tthis.callInitHooks();\r\n\t\t}\r\n\t};\r\n\r\n\t// instantiate class without calling constructor\r\n\tvar F = function () {};\r\n\tF.prototype = this.prototype;\r\n\r\n\tvar proto = new F();\r\n\tproto.constructor = NewClass;\r\n\r\n\tNewClass.prototype = proto;\r\n\r\n\t//inherit parent's statics\r\n\tfor (var i in this) {\r\n\t\tif (this.hasOwnProperty(i) && i !== 'prototype') {\r\n\t\t\tNewClass[i] = this[i];\r\n\t\t}\r\n\t}\r\n\r\n\t// mix static properties into the class\r\n\tif (props.statics) {\r\n\t\tL.extend(NewClass, props.statics);\r\n\t\tdelete props.statics;\r\n\t}\r\n\r\n\t// mix includes into the prototype\r\n\tif (props.includes) {\r\n\t\tL.Util.extend.apply(null, [proto].concat(props.includes));\r\n\t\tdelete props.includes;\r\n\t}\r\n\r\n\t// merge options\r\n\tif (props.options && proto.options) {\r\n\t\tprops.options = L.extend({}, proto.options, props.options);\r\n\t}\r\n\r\n\t// mix given properties into the prototype\r\n\tL.extend(proto, props);\r\n\r\n\tproto._initHooks = [];\r\n\r\n\tvar parent = this;\r\n\t// jshint camelcase: false\r\n\tNewClass.__super__ = parent.prototype;\r\n\r\n\t// add method for calling all hooks\r\n\tproto.callInitHooks = function () {\r\n\r\n\t\tif (this._initHooksCalled) { return; }\r\n\r\n\t\tif (parent.prototype.callInitHooks) {\r\n\t\t\tparent.prototype.callInitHooks.call(this);\r\n\t\t}\r\n\r\n\t\tthis._initHooksCalled = true;\r\n\r\n\t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n\t\t\tproto._initHooks[i].call(this);\r\n\t\t}\r\n\t};\r\n\r\n\treturn NewClass;\r\n};\r\n\r\n\r\n// method for adding properties to prototype\r\nL.Class.include = function (props) {\r\n\tL.extend(this.prototype, props);\r\n};\r\n\r\n// merge new default options to the Class\r\nL.Class.mergeOptions = function (options) {\r\n\tL.extend(this.prototype.options, options);\r\n};\r\n\r\n// add a constructor hook\r\nL.Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n\tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n\tvar init = typeof fn === 'function' ? fn : function () {\r\n\t\tthis[fn].apply(this, args);\r\n\t};\r\n\r\n\tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n\tthis.prototype._initHooks.push(init);\r\n};\r\n\n\n/*\r\n * L.Mixin.Events is used to add custom events functionality to Leaflet classes.\r\n */\r\n\r\nvar eventsKey = '_leaflet_events';\r\n\r\nL.Mixin = {};\r\n\r\nL.Mixin.Events = {\r\n\r\n\taddEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])\r\n\r\n\t\t// types can be a map of types/handlers\r\n\t\tif (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey] = this[eventsKey] || {},\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, event, type, indexKey, indexLenKey, typeIndex;\r\n\r\n\t\t// types can be a string of space-separated words\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\tevent = {\r\n\t\t\t\taction: fn,\r\n\t\t\t\tcontext: context || this\r\n\t\t\t};\r\n\t\t\ttype = types[i];\r\n\r\n\t\t\tif (contextId) {\r\n\t\t\t\t// store listeners of a particular context in a separate hash (if it has an id)\r\n\t\t\t\t// gives a major performance boost when removing thousands of map layers\r\n\r\n\t\t\t\tindexKey = type + '_idx';\r\n\t\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\t\ttypeIndex = events[indexKey] = events[indexKey] || {};\r\n\r\n\t\t\t\tif (!typeIndex[contextId]) {\r\n\t\t\t\t\ttypeIndex[contextId] = [];\r\n\r\n\t\t\t\t\t// keep track of the number of keys in the index to quickly check if it's empty\r\n\t\t\t\t\tevents[indexLenKey] = (events[indexLenKey] || 0) + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttypeIndex[contextId].push(event);\r\n\r\n\r\n\t\t\t} else {\r\n\t\t\t\tevents[type] = events[type] || [];\r\n\t\t\t\tevents[type].push(event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasEventListeners: function (type) { // (String) -> Boolean\r\n\t\tvar events = this[eventsKey];\r\n\t\treturn !!events && ((type in events && events[type].length > 0) ||\r\n\t\t                    (type + '_idx' in events && events[type + '_idx_len'] > 0));\r\n\t},\r\n\r\n\tremoveEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])\r\n\r\n\t\tif (!this[eventsKey]) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (!types) {\r\n\t\t\treturn this.clearAllEventListeners();\r\n\t\t}\r\n\r\n\t\tif (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;\r\n\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\ttype = types[i];\r\n\t\t\tindexKey = type + '_idx';\r\n\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\ttypeIndex = events[indexKey];\r\n\r\n\t\t\tif (!fn) {\r\n\t\t\t\t// clear all listeners for a type if function isn't specified\r\n\t\t\t\tdelete events[type];\r\n\t\t\t\tdelete events[indexKey];\r\n\t\t\t\tdelete events[indexLenKey];\r\n\r\n\t\t\t} else {\r\n\t\t\t\tlisteners = contextId && typeIndex ? typeIndex[contextId] : events[type];\r\n\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tfor (j = listeners.length - 1; j >= 0; j--) {\r\n\t\t\t\t\t\tif ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {\r\n\t\t\t\t\t\t\tremoved = listeners.splice(j, 1);\r\n\t\t\t\t\t\t\t// set the old action to a no-op, because it is possible\r\n\t\t\t\t\t\t\t// that the listener is being iterated over as part of a dispatch\r\n\t\t\t\t\t\t\tremoved[0].action = L.Util.falseFn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (context && typeIndex && (listeners.length === 0)) {\r\n\t\t\t\t\t\tdelete typeIndex[contextId];\r\n\t\t\t\t\t\tevents[indexLenKey]--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclearAllEventListeners: function () {\r\n\t\tdelete this[eventsKey];\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfireEvent: function (type, data) { // (String[, Object])\r\n\t\tif (!this.hasEventListeners(type)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar event = L.Util.extend({}, data, { type: type, target: this });\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    listeners, i, len, typeIndex, contextId;\r\n\r\n\t\tif (events[type]) {\r\n\t\t\t// make sure adding/removing listeners inside other listeners won't cause infinite loop\r\n\t\t\tlisteners = events[type].slice();\r\n\r\n\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// fire event for the context-indexed listeners as well\r\n\t\ttypeIndex = events[type + '_idx'];\r\n\r\n\t\tfor (contextId in typeIndex) {\r\n\t\t\tlisteners = typeIndex[contextId].slice();\r\n\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOneTimeEventListener: function (types, fn, context) {\r\n\r\n\t\tif (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar handler = L.bind(function () {\r\n\t\t\tthis\r\n\t\t\t    .removeEventListener(types, fn, context)\r\n\t\t\t    .removeEventListener(types, handler, context);\r\n\t\t}, this);\r\n\r\n\t\treturn this\r\n\t\t    .addEventListener(types, fn, context)\r\n\t\t    .addEventListener(types, handler, context);\r\n\t}\r\n};\r\n\r\nL.Mixin.Events.on = L.Mixin.Events.addEventListener;\r\nL.Mixin.Events.off = L.Mixin.Events.removeEventListener;\r\nL.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;\r\nL.Mixin.Events.fire = L.Mixin.Events.fireEvent;\r\n\n\n/*\r\n * L.Browser handles different browser and feature detections for internal Leaflet use.\r\n */\r\n\r\n(function () {\r\n\r\n\tvar ie = 'ActiveXObject' in window,\r\n\t\tielt9 = ie && !document.addEventListener,\r\n\r\n\t    // terrible browser detection to work around Safari / iOS / Android browser bugs\r\n\t    ua = navigator.userAgent.toLowerCase(),\r\n\t    webkit = ua.indexOf('webkit') !== -1,\r\n\t    chrome = ua.indexOf('chrome') !== -1,\r\n\t    phantomjs = ua.indexOf('phantom') !== -1,\r\n\t    android = ua.indexOf('android') !== -1,\r\n\t    android23 = ua.search('android [23]') !== -1,\r\n\t\tgecko = ua.indexOf('gecko') !== -1,\r\n\r\n\t    mobile = typeof orientation !== undefined + '',\r\n\t    msPointer = !window.PointerEvent && window.MSPointerEvent,\r\n\t\tpointer = (window.PointerEvent && window.navigator.pointerEnabled) ||\r\n\t\t\t\t  msPointer,\r\n\t    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||\r\n\t             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&\r\n\t              window.matchMedia('(min-resolution:144dpi)').matches),\r\n\r\n\t    doc = document.documentElement,\r\n\t    ie3d = ie && ('transition' in doc.style),\r\n\t    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,\r\n\t    gecko3d = 'MozPerspective' in doc.style,\r\n\t    opera3d = 'OTransition' in doc.style,\r\n\t    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;\r\n\r\n\tvar touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||\r\n\t\t(window.DocumentTouch && document instanceof window.DocumentTouch));\r\n\r\n\tL.Browser = {\r\n\t\tie: ie,\r\n\t\tielt9: ielt9,\r\n\t\twebkit: webkit,\r\n\t\tgecko: gecko && !webkit && !window.opera && !ie,\r\n\r\n\t\tandroid: android,\r\n\t\tandroid23: android23,\r\n\r\n\t\tchrome: chrome,\r\n\r\n\t\tie3d: ie3d,\r\n\t\twebkit3d: webkit3d,\r\n\t\tgecko3d: gecko3d,\r\n\t\topera3d: opera3d,\r\n\t\tany3d: any3d,\r\n\r\n\t\tmobile: mobile,\r\n\t\tmobileWebkit: mobile && webkit,\r\n\t\tmobileWebkit3d: mobile && webkit3d,\r\n\t\tmobileOpera: mobile && window.opera,\r\n\r\n\t\ttouch: touch,\r\n\t\tmsPointer: msPointer,\r\n\t\tpointer: pointer,\r\n\r\n\t\tretina: retina\r\n\t};\r\n\r\n}());\r\n\n\n/*\r\n * L.Point represents a point with x and y coordinates.\r\n */\r\n\r\nL.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {\r\n\tthis.x = (round ? Math.round(x) : x);\r\n\tthis.y = (round ? Math.round(y) : y);\r\n};\r\n\r\nL.Point.prototype = {\r\n\r\n\tclone: function () {\r\n\t\treturn new L.Point(this.x, this.y);\r\n\t},\r\n\r\n\t// non-destructive, returns a new point\r\n\tadd: function (point) {\r\n\t\treturn this.clone()._add(L.point(point));\r\n\t},\r\n\r\n\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n\t_add: function (point) {\r\n\t\tthis.x += point.x;\r\n\t\tthis.y += point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsubtract: function (point) {\r\n\t\treturn this.clone()._subtract(L.point(point));\r\n\t},\r\n\r\n\t_subtract: function (point) {\r\n\t\tthis.x -= point.x;\r\n\t\tthis.y -= point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdivideBy: function (num) {\r\n\t\treturn this.clone()._divideBy(num);\r\n\t},\r\n\r\n\t_divideBy: function (num) {\r\n\t\tthis.x /= num;\r\n\t\tthis.y /= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tmultiplyBy: function (num) {\r\n\t\treturn this.clone()._multiplyBy(num);\r\n\t},\r\n\r\n\t_multiplyBy: function (num) {\r\n\t\tthis.x *= num;\r\n\t\tthis.y *= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tround: function () {\r\n\t\treturn this.clone()._round();\r\n\t},\r\n\r\n\t_round: function () {\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfloor: function () {\r\n\t\treturn this.clone()._floor();\r\n\t},\r\n\r\n\t_floor: function () {\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdistanceTo: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tvar x = point.x - this.x,\r\n\t\t    y = point.y - this.y;\r\n\r\n\t\treturn Math.sqrt(x * x + y * y);\r\n\t},\r\n\r\n\tequals: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn point.x === this.x &&\r\n\t\t       point.y === this.y;\r\n\t},\r\n\r\n\tcontains: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n\t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn 'Point(' +\r\n\t\t        L.Util.formatNum(this.x) + ', ' +\r\n\t\t        L.Util.formatNum(this.y) + ')';\r\n\t}\r\n};\r\n\r\nL.point = function (x, y, round) {\r\n\tif (x instanceof L.Point) {\r\n\t\treturn x;\r\n\t}\r\n\tif (L.Util.isArray(x)) {\r\n\t\treturn new L.Point(x[0], x[1]);\r\n\t}\r\n\tif (x === undefined || x === null) {\r\n\t\treturn x;\r\n\t}\r\n\treturn new L.Point(x, y, round);\r\n};\r\n\n\n/*\r\n * L.Bounds represents a rectangular area on the screen in pixel coordinates.\r\n */\r\n\r\nL.Bounds = function (a, b) { //(Point, Point) or Point[]\r\n\tif (!a) { return; }\r\n\r\n\tvar points = b ? [a, b] : a;\r\n\r\n\tfor (var i = 0, len = points.length; i < len; i++) {\r\n\t\tthis.extend(points[i]);\r\n\t}\r\n};\r\n\r\nL.Bounds.prototype = {\r\n\t// extend the bounds to contain the given point\r\n\textend: function (point) { // (Point)\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tif (!this.min && !this.max) {\r\n\t\t\tthis.min = point.clone();\r\n\t\t\tthis.max = point.clone();\r\n\t\t} else {\r\n\t\t\tthis.min.x = Math.min(point.x, this.min.x);\r\n\t\t\tthis.max.x = Math.max(point.x, this.max.x);\r\n\t\t\tthis.min.y = Math.min(point.y, this.min.y);\r\n\t\t\tthis.max.y = Math.max(point.y, this.max.y);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetCenter: function (round) { // (Boolean) -> Point\r\n\t\treturn new L.Point(\r\n\t\t        (this.min.x + this.max.x) / 2,\r\n\t\t        (this.min.y + this.max.y) / 2, round);\r\n\t},\r\n\r\n\tgetBottomLeft: function () { // -> Point\r\n\t\treturn new L.Point(this.min.x, this.max.y);\r\n\t},\r\n\r\n\tgetTopRight: function () { // -> Point\r\n\t\treturn new L.Point(this.max.x, this.min.y);\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\treturn this.max.subtract(this.min);\r\n\t},\r\n\r\n\tcontains: function (obj) { // (Bounds) or (Point) -> Boolean\r\n\t\tvar min, max;\r\n\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.Point) {\r\n\t\t\tobj = L.point(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.bounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.Bounds) {\r\n\t\t\tmin = obj.min;\r\n\t\t\tmax = obj.max;\r\n\t\t} else {\r\n\t\t\tmin = max = obj;\r\n\t\t}\r\n\r\n\t\treturn (min.x >= this.min.x) &&\r\n\t\t       (max.x <= this.max.x) &&\r\n\t\t       (min.y >= this.min.y) &&\r\n\t\t       (max.y <= this.max.y);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (Bounds) -> Boolean\r\n\t\tbounds = L.bounds(bounds);\r\n\r\n\t\tvar min = this.min,\r\n\t\t    max = this.max,\r\n\t\t    min2 = bounds.min,\r\n\t\t    max2 = bounds.max,\r\n\t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n\t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n\t\treturn xIntersects && yIntersects;\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this.min && this.max);\r\n\t}\r\n};\r\n\r\nL.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])\r\n\tif (!a || a instanceof L.Bounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.Bounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\r\n */\r\n\r\nL.Transformation = function (a, b, c, d) {\r\n\tthis._a = a;\r\n\tthis._b = b;\r\n\tthis._c = c;\r\n\tthis._d = d;\r\n};\r\n\r\nL.Transformation.prototype = {\r\n\ttransform: function (point, scale) { // (Point, Number) -> Point\r\n\t\treturn this._transform(point.clone(), scale);\r\n\t},\r\n\r\n\t// destructive transform (faster)\r\n\t_transform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\tpoint.x = scale * (this._a * point.x + this._b);\r\n\t\tpoint.y = scale * (this._c * point.y + this._d);\r\n\t\treturn point;\r\n\t},\r\n\r\n\tuntransform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\treturn new L.Point(\r\n\t\t        (point.x / scale - this._b) / this._a,\r\n\t\t        (point.y / scale - this._d) / this._c);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.DomUtil contains various utility functions for working with DOM.\r\n */\r\n\r\nL.DomUtil = {\r\n\tget: function (id) {\r\n\t\treturn (typeof id === 'string' ? document.getElementById(id) : id);\r\n\t},\r\n\r\n\tgetStyle: function (el, style) {\r\n\r\n\t\tvar value = el.style[style];\r\n\r\n\t\tif (!value && el.currentStyle) {\r\n\t\t\tvalue = el.currentStyle[style];\r\n\t\t}\r\n\r\n\t\tif ((!value || value === 'auto') && document.defaultView) {\r\n\t\t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n\t\t\tvalue = css ? css[style] : null;\r\n\t\t}\r\n\r\n\t\treturn value === 'auto' ? null : value;\r\n\t},\r\n\r\n\tgetViewportOffset: function (element) {\r\n\r\n\t\tvar top = 0,\r\n\t\t    left = 0,\r\n\t\t    el = element,\r\n\t\t    docBody = document.body,\r\n\t\t    docEl = document.documentElement,\r\n\t\t    pos;\r\n\r\n\t\tdo {\r\n\t\t\ttop  += el.offsetTop  || 0;\r\n\t\t\tleft += el.offsetLeft || 0;\r\n\r\n\t\t\t//add borders\r\n\t\t\ttop += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;\r\n\t\t\tleft += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;\r\n\r\n\t\t\tpos = L.DomUtil.getStyle(el, 'position');\r\n\r\n\t\t\tif (el.offsetParent === docBody && pos === 'absolute') { break; }\r\n\r\n\t\t\tif (pos === 'fixed') {\r\n\t\t\t\ttop  += docBody.scrollTop  || docEl.scrollTop  || 0;\r\n\t\t\t\tleft += docBody.scrollLeft || docEl.scrollLeft || 0;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (pos === 'relative' && !el.offsetLeft) {\r\n\t\t\t\tvar width = L.DomUtil.getStyle(el, 'width'),\r\n\t\t\t\t    maxWidth = L.DomUtil.getStyle(el, 'max-width'),\r\n\t\t\t\t    r = el.getBoundingClientRect();\r\n\r\n\t\t\t\tif (width !== 'none' || maxWidth !== 'none') {\r\n\t\t\t\t\tleft += r.left + el.clientLeft;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//calculate full y offset since we're breaking out of the loop\r\n\t\t\t\ttop += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tel = el.offsetParent;\r\n\r\n\t\t} while (el);\r\n\r\n\t\tel = element;\r\n\r\n\t\tdo {\r\n\t\t\tif (el === docBody) { break; }\r\n\r\n\t\t\ttop  -= el.scrollTop  || 0;\r\n\t\t\tleft -= el.scrollLeft || 0;\r\n\r\n\t\t\tel = el.parentNode;\r\n\t\t} while (el);\r\n\r\n\t\treturn new L.Point(left, top);\r\n\t},\r\n\r\n\tdocumentIsLtr: function () {\r\n\t\tif (!L.DomUtil._docIsLtrCached) {\r\n\t\t\tL.DomUtil._docIsLtrCached = true;\r\n\t\t\tL.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';\r\n\t\t}\r\n\t\treturn L.DomUtil._docIsLtr;\r\n\t},\r\n\r\n\tcreate: function (tagName, className, container) {\r\n\r\n\t\tvar el = document.createElement(tagName);\r\n\t\tel.className = className;\r\n\r\n\t\tif (container) {\r\n\t\t\tcontainer.appendChild(el);\r\n\t\t}\r\n\r\n\t\treturn el;\r\n\t},\r\n\r\n\thasClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\treturn el.classList.contains(name);\r\n\t\t}\r\n\t\tvar className = L.DomUtil._getClass(el);\r\n\t\treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n\t},\r\n\r\n\taddClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tvar classes = L.Util.splitWords(name);\r\n\t\t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n\t\t\t\tel.classList.add(classes[i]);\r\n\t\t\t}\r\n\t\t} else if (!L.DomUtil.hasClass(el, name)) {\r\n\t\t\tvar className = L.DomUtil._getClass(el);\r\n\t\t\tL.DomUtil._setClass(el, (className ? className + ' ' : '') + name);\r\n\t\t}\r\n\t},\r\n\r\n\tremoveClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tel.classList.remove(name);\r\n\t\t} else {\r\n\t\t\tL.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n\t\t}\r\n\t},\r\n\r\n\t_setClass: function (el, name) {\r\n\t\tif (el.className.baseVal === undefined) {\r\n\t\t\tel.className = name;\r\n\t\t} else {\r\n\t\t\t// in case of SVG element\r\n\t\t\tel.className.baseVal = name;\r\n\t\t}\r\n\t},\r\n\r\n\t_getClass: function (el) {\r\n\t\treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n\t},\r\n\r\n\tsetOpacity: function (el, value) {\r\n\r\n\t\tif ('opacity' in el.style) {\r\n\t\t\tel.style.opacity = value;\r\n\r\n\t\t} else if ('filter' in el.style) {\r\n\r\n\t\t\tvar filter = false,\r\n\t\t\t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n\t\t\t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n\t\t\ttry {\r\n\t\t\t\tfilter = el.filters.item(filterName);\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n\t\t\t\t// it isn't needed and breaks transparent pngs.\r\n\t\t\t\tif (value === 1) { return; }\r\n\t\t\t}\r\n\r\n\t\t\tvalue = Math.round(value * 100);\r\n\r\n\t\t\tif (filter) {\r\n\t\t\t\tfilter.Enabled = (value !== 100);\r\n\t\t\t\tfilter.Opacity = value;\r\n\t\t\t} else {\r\n\t\t\t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\ttestProp: function (props) {\r\n\r\n\t\tvar style = document.documentElement.style;\r\n\r\n\t\tfor (var i = 0; i < props.length; i++) {\r\n\t\t\tif (props[i] in style) {\r\n\t\t\t\treturn props[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tgetTranslateString: function (point) {\r\n\t\t// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate\r\n\t\t// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care\r\n\t\t// (same speed either way), Opera 12 doesn't support translate3d\r\n\r\n\t\tvar is3d = L.Browser.webkit3d,\r\n\t\t    open = 'translate' + (is3d ? '3d' : '') + '(',\r\n\t\t    close = (is3d ? ',0' : '') + ')';\r\n\r\n\t\treturn open + point.x + 'px,' + point.y + 'px' + close;\r\n\t},\r\n\r\n\tgetScaleString: function (scale, origin) {\r\n\r\n\t\tvar preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),\r\n\t\t    scaleStr = ' scale(' + scale + ') ';\r\n\r\n\t\treturn preTranslateStr + scaleStr;\r\n\t},\r\n\r\n\tsetPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])\r\n\r\n\t\t// jshint camelcase: false\r\n\t\tel._leaflet_pos = point;\r\n\r\n\t\tif (!disable3D && L.Browser.any3d) {\r\n\t\t\tel.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);\r\n\t\t} else {\r\n\t\t\tel.style.left = point.x + 'px';\r\n\t\t\tel.style.top = point.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\tgetPosition: function (el) {\r\n\t\t// this method is only used for elements previously positioned using setPosition,\r\n\t\t// so it's safe to cache the position for performance\r\n\r\n\t\t// jshint camelcase: false\r\n\t\treturn el._leaflet_pos;\r\n\t}\r\n};\r\n\r\n\r\n// prefix style property names\r\n\r\nL.DomUtil.TRANSFORM = L.DomUtil.testProp(\r\n        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n// webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n// the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\nL.DomUtil.TRANSITION = L.DomUtil.testProp(\r\n        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\nL.DomUtil.TRANSITION_END =\r\n        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?\r\n        L.DomUtil.TRANSITION + 'End' : 'transitionend';\r\n\r\n(function () {\r\n    if ('onselectstart' in document) {\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\r\n            }\r\n        });\r\n    } else {\r\n        var userSelectProperty = L.DomUtil.testProp(\r\n            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    var style = document.documentElement.style;\r\n                    this._userSelect = style[userSelectProperty];\r\n                    style[userSelectProperty] = 'none';\r\n                }\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    document.documentElement.style[userSelectProperty] = this._userSelect;\r\n                    delete this._userSelect;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\tL.extend(L.DomUtil, {\r\n\t\tdisableImageDrag: function () {\r\n\t\t\tL.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t},\r\n\r\n\t\tenableImageDrag: function () {\r\n\t\t\tL.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t}\r\n\t});\r\n})();\r\n\n\n/*\r\n * L.LatLng represents a geographical point with latitude and longitude coordinates.\r\n */\r\n\r\nL.LatLng = function (lat, lng, alt) { // (Number, Number, Number)\r\n\tlat = parseFloat(lat);\r\n\tlng = parseFloat(lng);\r\n\r\n\tif (isNaN(lat) || isNaN(lng)) {\r\n\t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n\t}\r\n\r\n\tthis.lat = lat;\r\n\tthis.lng = lng;\r\n\r\n\tif (alt !== undefined) {\r\n\t\tthis.alt = parseFloat(alt);\r\n\t}\r\n};\r\n\r\nL.extend(L.LatLng, {\r\n\tDEG_TO_RAD: Math.PI / 180,\r\n\tRAD_TO_DEG: 180 / Math.PI,\r\n\tMAX_MARGIN: 1.0E-9 // max margin of error for the \"equals\" check\r\n});\r\n\r\nL.LatLng.prototype = {\r\n\tequals: function (obj) { // (LatLng) -> Boolean\r\n\t\tif (!obj) { return false; }\r\n\r\n\t\tobj = L.latLng(obj);\r\n\r\n\t\tvar margin = Math.max(\r\n\t\t        Math.abs(this.lat - obj.lat),\r\n\t\t        Math.abs(this.lng - obj.lng));\r\n\r\n\t\treturn margin <= L.LatLng.MAX_MARGIN;\r\n\t},\r\n\r\n\ttoString: function (precision) { // (Number) -> String\r\n\t\treturn 'LatLng(' +\r\n\t\t        L.Util.formatNum(this.lat, precision) + ', ' +\r\n\t\t        L.Util.formatNum(this.lng, precision) + ')';\r\n\t},\r\n\r\n\t// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula\r\n\t// TODO move to projection code, LatLng shouldn't know about Earth\r\n\tdistanceTo: function (other) { // (LatLng) -> Number\r\n\t\tother = L.latLng(other);\r\n\r\n\t\tvar R = 6378137, // earth radius in meters\r\n\t\t    d2r = L.LatLng.DEG_TO_RAD,\r\n\t\t    dLat = (other.lat - this.lat) * d2r,\r\n\t\t    dLon = (other.lng - this.lng) * d2r,\r\n\t\t    lat1 = this.lat * d2r,\r\n\t\t    lat2 = other.lat * d2r,\r\n\t\t    sin1 = Math.sin(dLat / 2),\r\n\t\t    sin2 = Math.sin(dLon / 2);\r\n\r\n\t\tvar a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);\r\n\r\n\t\treturn R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\t},\r\n\r\n\twrap: function (a, b) { // (Number, Number) -> LatLng\r\n\t\tvar lng = this.lng;\r\n\r\n\t\ta = a || -180;\r\n\t\tb = b ||  180;\r\n\r\n\t\tlng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);\r\n\r\n\t\treturn new L.LatLng(this.lat, lng);\r\n\t}\r\n};\r\n\r\nL.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)\r\n\tif (a instanceof L.LatLng) {\r\n\t\treturn a;\r\n\t}\r\n\tif (L.Util.isArray(a)) {\r\n\t\tif (typeof a[0] === 'number' || typeof a[0] === 'string') {\r\n\t\t\treturn new L.LatLng(a[0], a[1], a[2]);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\tif (a === undefined || a === null) {\r\n\t\treturn a;\r\n\t}\r\n\tif (typeof a === 'object' && 'lat' in a) {\r\n\t\treturn new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);\r\n\t}\r\n\tif (b === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\treturn new L.LatLng(a, b);\r\n};\r\n\r\n\n\n/*\r\n * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\r\n */\r\n\r\nL.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])\r\n\tif (!southWest) { return; }\r\n\r\n\tvar latlngs = northEast ? [southWest, northEast] : southWest;\r\n\r\n\tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n\t\tthis.extend(latlngs[i]);\r\n\t}\r\n};\r\n\r\nL.LatLngBounds.prototype = {\r\n\t// extend the bounds to contain the given point or bounds\r\n\textend: function (obj) { // (LatLng) or (LatLngBounds)\r\n\t\tif (!obj) { return this; }\r\n\r\n\t\tvar latLng = L.latLng(obj);\r\n\t\tif (latLng !== null) {\r\n\t\t\tobj = latLng;\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.LatLng) {\r\n\t\t\tif (!this._southWest && !this._northEast) {\r\n\t\t\t\tthis._southWest = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t\tthis._northEast = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t} else {\r\n\t\t\t\tthis._southWest.lat = Math.min(obj.lat, this._southWest.lat);\r\n\t\t\t\tthis._southWest.lng = Math.min(obj.lng, this._southWest.lng);\r\n\r\n\t\t\t\tthis._northEast.lat = Math.max(obj.lat, this._northEast.lat);\r\n\t\t\t\tthis._northEast.lng = Math.max(obj.lng, this._northEast.lng);\r\n\t\t\t}\r\n\t\t} else if (obj instanceof L.LatLngBounds) {\r\n\t\t\tthis.extend(obj._southWest);\r\n\t\t\tthis.extend(obj._northEast);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// extend the bounds by a percentage\r\n\tpad: function (bufferRatio) { // (Number) -> LatLngBounds\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n\t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n\t\t        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n\t},\r\n\r\n\tgetCenter: function () { // -> LatLng\r\n\t\treturn new L.LatLng(\r\n\t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n\t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n\t},\r\n\r\n\tgetSouthWest: function () {\r\n\t\treturn this._southWest;\r\n\t},\r\n\r\n\tgetNorthEast: function () {\r\n\t\treturn this._northEast;\r\n\t},\r\n\r\n\tgetNorthWest: function () {\r\n\t\treturn new L.LatLng(this.getNorth(), this.getWest());\r\n\t},\r\n\r\n\tgetSouthEast: function () {\r\n\t\treturn new L.LatLng(this.getSouth(), this.getEast());\r\n\t},\r\n\r\n\tgetWest: function () {\r\n\t\treturn this._southWest.lng;\r\n\t},\r\n\r\n\tgetSouth: function () {\r\n\t\treturn this._southWest.lat;\r\n\t},\r\n\r\n\tgetEast: function () {\r\n\t\treturn this._northEast.lng;\r\n\t},\r\n\r\n\tgetNorth: function () {\r\n\t\treturn this._northEast.lat;\r\n\t},\r\n\r\n\tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\r\n\t\t\tobj = L.latLng(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2, ne2;\r\n\r\n\t\tif (obj instanceof L.LatLngBounds) {\r\n\t\t\tsw2 = obj.getSouthWest();\r\n\t\t\tne2 = obj.getNorthEast();\r\n\t\t} else {\r\n\t\t\tsw2 = ne2 = obj;\r\n\t\t}\r\n\r\n\t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n\t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (LatLngBounds)\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2 = bounds.getSouthWest(),\r\n\t\t    ne2 = bounds.getNorthEast(),\r\n\r\n\t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n\t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n\t\treturn latIntersects && lngIntersects;\r\n\t},\r\n\r\n\ttoBBoxString: function () {\r\n\t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n\t},\r\n\r\n\tequals: function (bounds) { // (LatLngBounds)\r\n\t\tif (!bounds) { return false; }\r\n\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\treturn this._southWest.equals(bounds.getSouthWest()) &&\r\n\t\t       this._northEast.equals(bounds.getNorthEast());\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this._southWest && this._northEast);\r\n\t}\r\n};\r\n\r\n//TODO International date line?\r\n\r\nL.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)\r\n\tif (!a || a instanceof L.LatLngBounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.LatLngBounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Projection contains various geographical projections used by CRS classes.\r\n */\r\n\r\nL.Projection = {};\r\n\n\n/*\r\n * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\r\n */\r\n\r\nL.Projection.SphericalMercator = {\r\n\tMAX_LATITUDE: 85.0511287798,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    x = latlng.lng * d,\r\n\t\t    y = lat * d;\r\n\r\n\t\ty = Math.log(Math.tan((Math.PI / 4) + (y / 2)));\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    lng = point.x * d,\r\n\t\t    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;\r\n\r\n\t\treturn new L.LatLng(lat, lng);\r\n\t}\r\n};\r\n\n\n/*\r\n * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\r\n */\r\n\r\nL.Projection.LonLat = {\r\n\tproject: function (latlng) {\r\n\t\treturn new L.Point(latlng.lng, latlng.lat);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\treturn new L.LatLng(point.y, point.x);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\r\n */\r\n\r\nL.CRS = {\r\n\tlatLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    scale = this.scale(zoom);\r\n\r\n\t\treturn this.transformation._transform(projectedPoint, scale);\r\n\t},\r\n\r\n\tpointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng\r\n\t\tvar scale = this.scale(zoom),\r\n\t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n\t\treturn this.projection.unproject(untransformedPoint);\r\n\t},\r\n\r\n\tproject: function (latlng) {\r\n\t\treturn this.projection.project(latlng);\r\n\t},\r\n\r\n\tscale: function (zoom) {\r\n\t\treturn 256 * Math.pow(2, zoom);\r\n\t},\r\n\r\n\tgetSize: function (zoom) {\r\n\t\tvar s = this.scale(zoom);\r\n\t\treturn L.point(s, s);\r\n\t}\r\n};\r\n\n\n/*\n * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n */\n\nL.CRS.Simple = L.extend({}, L.CRS, {\n\tprojection: L.Projection.LonLat,\n\ttransformation: new L.Transformation(1, 0, -1, 0),\n\n\tscale: function (zoom) {\n\t\treturn Math.pow(2, zoom);\n\t}\n});\n\n\n/*\r\n * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping\r\n * and is used by Leaflet by default.\r\n */\r\n\r\nL.CRS.EPSG3857 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3857',\r\n\r\n\tprojection: L.Projection.SphericalMercator,\r\n\ttransformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    earthRadius = 6378137;\r\n\t\treturn projectedPoint.multiplyBy(earthRadius);\r\n\t}\r\n});\r\n\r\nL.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\r\n\tcode: 'EPSG:900913'\r\n});\r\n\n\n/*\r\n * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\r\n */\r\n\r\nL.CRS.EPSG4326 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:4326',\r\n\r\n\tprojection: L.Projection.LonLat,\r\n\ttransformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)\r\n});\r\n\n\n/*\r\n * L.Map is the central class of the API - it is used to create a map.\r\n */\r\n\r\nL.Map = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tcrs: L.CRS.EPSG3857,\r\n\r\n\t\t/*\r\n\t\tcenter: LatLng,\r\n\t\tzoom: Number,\r\n\t\tlayers: Array,\r\n\t\t*/\r\n\r\n\t\tfadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,\r\n\t\ttrackResize: true,\r\n\t\tmarkerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d\r\n\t},\r\n\r\n\tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\r\n\t\tthis._initContainer(id);\r\n\t\tthis._initLayout();\r\n\r\n\t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n\t\tthis._onResize = L.bind(this._onResize, this);\r\n\r\n\t\tthis._initEvents();\r\n\r\n\t\tif (options.maxBounds) {\r\n\t\t\tthis.setMaxBounds(options.maxBounds);\r\n\t\t}\r\n\r\n\t\tif (options.center && options.zoom !== undefined) {\r\n\t\t\tthis.setView(L.latLng(options.center), options.zoom, {reset: true});\r\n\t\t}\r\n\r\n\t\tthis._handlers = [];\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._zoomBoundLayers = {};\r\n\t\tthis._tileLayersNum = 0;\r\n\r\n\t\tthis.callInitHooks();\r\n\r\n\t\tthis._addLayers(options.layers);\r\n\t},\r\n\r\n\r\n\t// public methods that modify map state\r\n\r\n\t// replaced by animation-powered implementation in Map.PanAnimation.js\r\n\tsetView: function (center, zoom) {\r\n\t\tzoom = zoom === undefined ? this.getZoom() : zoom;\r\n\t\tthis._resetView(L.latLng(center), this._limitZoom(zoom));\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZoom: function (zoom, options) {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthis._zoom = this._limitZoom(zoom);\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n\t},\r\n\r\n\tzoomIn: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom + (delta || 1), options);\r\n\t},\r\n\r\n\tzoomOut: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom - (delta || 1), options);\r\n\t},\r\n\r\n\tsetZoomAround: function (latlng, zoom, options) {\r\n\t\tvar scale = this.getZoomScale(zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n\t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n\t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n\t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n\t},\r\n\r\n\tfitBounds: function (bounds, options) {\r\n\r\n\t\toptions = options || {};\r\n\t\tbounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\r\n\r\n\t\tvar paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n\t\t    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n\t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\r\n\t\tzoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n\t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n\t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n\t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n\t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n\t\treturn this.setView(center, zoom, options);\r\n\t},\r\n\r\n\tfitWorld: function (options) {\r\n\t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n\t},\r\n\r\n\tpanTo: function (center, options) { // (LatLng)\r\n\t\treturn this.setView(center, this._zoom, {pan: options});\r\n\t},\r\n\r\n\tpanBy: function (offset) { // (Point)\r\n\t\t// replaced with animated panBy in Map.PanAnimation.js\r\n\t\tthis.fire('movestart');\r\n\r\n\t\tthis._rawPanBy(L.point(offset));\r\n\r\n\t\tthis.fire('move');\r\n\t\treturn this.fire('moveend');\r\n\t},\r\n\r\n\tsetMaxBounds: function (bounds) {\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tthis.options.maxBounds = bounds;\r\n\r\n\t\tif (!bounds) {\r\n\t\t\treturn this.off('moveend', this._panInsideMaxBounds, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._panInsideMaxBounds();\r\n\t\t}\r\n\r\n\t\treturn this.on('moveend', this._panInsideMaxBounds, this);\r\n\t},\r\n\r\n\tpanInsideBounds: function (bounds, options) {\r\n\t\tvar center = this.getCenter(),\r\n\t\t\tnewCenter = this._limitCenter(center, this._zoom, bounds);\r\n\r\n\t\tif (center.equals(newCenter)) { return this; }\r\n\r\n\t\treturn this.panTo(newCenter, options);\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\t// TODO method is too big, refactor\r\n\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (this._layers[id]) { return this; }\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\t// TODO getMaxZoom, getMinZoom in ILayer (instead of options)\r\n\t\tif (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {\r\n\t\t\tthis._zoomBoundLayers[id] = layer;\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor!!!\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum++;\r\n\t\t\tthis._tileLayersToLoad++;\r\n\t\t\tlayer.on('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._layerAdd(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (!this._layers[id]) { return this; }\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tlayer.onRemove(this);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('layerremove', {layer: layer});\r\n\t\t}\r\n\r\n\t\tif (this._zoomBoundLayers[id]) {\r\n\t\t\tdelete this._zoomBoundLayers[id];\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum--;\r\n\t\t\tthis._tileLayersToLoad--;\r\n\t\t\tlayer.off('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (L.stamp(layer) in this._layers);\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvalidateSize: function (options) {\r\n\t\tif (!this._loaded) { return this; }\r\n\r\n\t\toptions = L.extend({\r\n\t\t\tanimate: false,\r\n\t\t\tpan: true\r\n\t\t}, options === true ? {animate: true} : options);\r\n\r\n\t\tvar oldSize = this.getSize();\r\n\t\tthis._sizeChanged = true;\r\n\t\tthis._initialCenter = null;\r\n\r\n\t\tvar newSize = this.getSize(),\r\n\t\t    oldCenter = oldSize.divideBy(2).round(),\r\n\t\t    newCenter = newSize.divideBy(2).round(),\r\n\t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n\t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n\t\tif (options.animate && options.pan) {\r\n\t\t\tthis.panBy(offset);\r\n\r\n\t\t} else {\r\n\t\t\tif (options.pan) {\r\n\t\t\t\tthis._rawPanBy(offset);\r\n\t\t\t}\r\n\r\n\t\t\tthis.fire('move');\r\n\r\n\t\t\tif (options.debounceMoveend) {\r\n\t\t\t\tclearTimeout(this._sizeTimer);\r\n\t\t\t\tthis._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\r\n\t\t\t} else {\r\n\t\t\t\tthis.fire('moveend');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.fire('resize', {\r\n\t\t\toldSize: oldSize,\r\n\t\t\tnewSize: newSize\r\n\t\t});\r\n\t},\r\n\r\n\t// TODO handler.addTo\r\n\taddHandler: function (name, HandlerClass) {\r\n\t\tif (!HandlerClass) { return this; }\r\n\r\n\t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n\t\tthis._handlers.push(handler);\r\n\r\n\t\tif (this.options[name]) {\r\n\t\t\thandler.enable();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremove: function () {\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('unload');\r\n\t\t}\r\n\r\n\t\tthis._initEvents('off');\r\n\r\n\t\ttry {\r\n\t\t\t// throws error in IE6-8\r\n\t\t\tdelete this._container._leaflet;\r\n\t\t} catch (e) {\r\n\t\t\tthis._container._leaflet = undefined;\r\n\t\t}\r\n\r\n\t\tthis._clearPanes();\r\n\t\tif (this._clearControlPos) {\r\n\t\t\tthis._clearControlPos();\r\n\t\t}\r\n\r\n\t\tthis._clearHandlers();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\r\n\t// public methods for getting map state\r\n\r\n\tgetCenter: function () { // (Boolean) -> LatLng\r\n\t\tthis._checkIfLoaded();\r\n\r\n\t\tif (this._initialCenter && !this._moved()) {\r\n\t\t\treturn this._initialCenter;\r\n\t\t}\r\n\t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\tgetZoom: function () {\r\n\t\treturn this._zoom;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = this.getPixelBounds(),\r\n\t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n\t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n\t\treturn new L.LatLngBounds(sw, ne);\r\n\t},\r\n\r\n\tgetMinZoom: function () {\r\n\t\treturn this.options.minZoom === undefined ?\r\n\t\t\t(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :\r\n\t\t\tthis.options.minZoom;\r\n\t},\r\n\r\n\tgetMaxZoom: function () {\r\n\t\treturn this.options.maxZoom === undefined ?\r\n\t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n\t\t\tthis.options.maxZoom;\r\n\t},\r\n\r\n\tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar zoom = this.getMinZoom() - (inside ? 1 : 0),\r\n\t\t    maxZoom = this.getMaxZoom(),\r\n\t\t    size = this.getSize(),\r\n\r\n\t\t    nw = bounds.getNorthWest(),\r\n\t\t    se = bounds.getSouthEast(),\r\n\r\n\t\t    zoomNotFound = true,\r\n\t\t    boundsSize;\r\n\r\n\t\tpadding = L.point(padding || [0, 0]);\r\n\r\n\t\tdo {\r\n\t\t\tzoom++;\r\n\t\t\tboundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);\r\n\t\t\tzoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\r\n\r\n\t\t} while (zoomNotFound && zoom <= maxZoom);\r\n\r\n\t\tif (zoomNotFound && inside) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn inside ? zoom : zoom - 1;\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\tif (!this._size || this._sizeChanged) {\r\n\t\t\tthis._size = new L.Point(\r\n\t\t\t\tthis._container.clientWidth,\r\n\t\t\t\tthis._container.clientHeight);\r\n\r\n\t\t\tthis._sizeChanged = false;\r\n\t\t}\r\n\t\treturn this._size.clone();\r\n\t},\r\n\r\n\tgetPixelBounds: function () {\r\n\t\tvar topLeftPoint = this._getTopLeftPoint();\r\n\t\treturn new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n\t},\r\n\r\n\tgetPixelOrigin: function () {\r\n\t\tthis._checkIfLoaded();\r\n\t\treturn this._initialTopLeftPoint;\r\n\t},\r\n\r\n\tgetPanes: function () {\r\n\t\treturn this._panes;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\r\n\t// TODO replace with universal implementation after refactoring projections\r\n\r\n\tgetZoomScale: function (toZoom) {\r\n\t\tvar crs = this.options.crs;\r\n\t\treturn crs.scale(toZoom) / crs.scale(this._zoom);\r\n\t},\r\n\r\n\tgetScaleZoom: function (scale) {\r\n\t\treturn this._zoom + (Math.log(scale) / Math.LN2);\r\n\t},\r\n\r\n\r\n\t// conversion methods\r\n\r\n\tproject: function (latlng, zoom) { // (LatLng[, Number]) -> Point\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\r\n\t},\r\n\r\n\tunproject: function (point, zoom) { // (Point[, Number]) -> LatLng\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.pointToLatLng(L.point(point), zoom);\r\n\t},\r\n\r\n\tlayerPointToLatLng: function (point) { // (Point)\r\n\t\tvar projectedPoint = L.point(point).add(this.getPixelOrigin());\r\n\t\treturn this.unproject(projectedPoint);\r\n\t},\r\n\r\n\tlatLngToLayerPoint: function (latlng) { // (LatLng)\r\n\t\tvar projectedPoint = this.project(L.latLng(latlng))._round();\r\n\t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n\t},\r\n\r\n\tcontainerPointToLayerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\tlayerPointToContainerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).add(this._getMapPanePos());\r\n\t},\r\n\r\n\tcontainerPointToLatLng: function (point) {\r\n\t\tvar layerPoint = this.containerPointToLayerPoint(L.point(point));\r\n\t\treturn this.layerPointToLatLng(layerPoint);\r\n\t},\r\n\r\n\tlatLngToContainerPoint: function (latlng) {\r\n\t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\r\n\t},\r\n\r\n\tmouseEventToContainerPoint: function (e) { // (MouseEvent)\r\n\t\treturn L.DomEvent.getMousePosition(e, this._container);\r\n\t},\r\n\r\n\tmouseEventToLayerPoint: function (e) { // (MouseEvent)\r\n\t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n\t},\r\n\r\n\tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n\t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n\t},\r\n\r\n\r\n\t// map initialization methods\r\n\r\n\t_initContainer: function (id) {\r\n\t\tvar container = this._container = L.DomUtil.get(id);\r\n\r\n\t\tif (!container) {\r\n\t\t\tthrow new Error('Map container not found.');\r\n\t\t} else if (container._leaflet) {\r\n\t\t\tthrow new Error('Map container is already initialized.');\r\n\t\t}\r\n\r\n\t\tcontainer._leaflet = true;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar container = this._container;\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-container' +\r\n\t\t\t(L.Browser.touch ? ' leaflet-touch' : '') +\r\n\t\t\t(L.Browser.retina ? ' leaflet-retina' : '') +\r\n\t\t\t(L.Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n\t\t\t(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));\r\n\r\n\t\tvar position = L.DomUtil.getStyle(container, 'position');\r\n\r\n\t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n\t\t\tcontainer.style.position = 'relative';\r\n\t\t}\r\n\r\n\t\tthis._initPanes();\r\n\r\n\t\tif (this._initControlPos) {\r\n\t\t\tthis._initControlPos();\r\n\t\t}\r\n\t},\r\n\r\n\t_initPanes: function () {\r\n\t\tvar panes = this._panes = {};\r\n\r\n\t\tthis._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);\r\n\r\n\t\tthis._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);\r\n\t\tpanes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);\r\n\t\tpanes.shadowPane = this._createPane('leaflet-shadow-pane');\r\n\t\tpanes.overlayPane = this._createPane('leaflet-overlay-pane');\r\n\t\tpanes.markerPane = this._createPane('leaflet-marker-pane');\r\n\t\tpanes.popupPane = this._createPane('leaflet-popup-pane');\r\n\r\n\t\tvar zoomHide = ' leaflet-zoom-hide';\r\n\r\n\t\tif (!this.options.markerZoomAnimation) {\r\n\t\t\tL.DomUtil.addClass(panes.markerPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.shadowPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.popupPane, zoomHide);\r\n\t\t}\r\n\t},\r\n\r\n\t_createPane: function (className, container) {\r\n\t\treturn L.DomUtil.create('div', className, container || this._panes.objectsPane);\r\n\t},\r\n\r\n\t_clearPanes: function () {\r\n\t\tthis._container.removeChild(this._mapPane);\r\n\t},\r\n\r\n\t_addLayers: function (layers) {\r\n\t\tlayers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];\r\n\r\n\t\tfor (var i = 0, len = layers.length; i < len; i++) {\r\n\t\t\tthis.addLayer(layers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// private methods that modify map state\r\n\r\n\t_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {\r\n\r\n\t\tvar zoomChanged = (this._zoom !== zoom);\r\n\r\n\t\tif (!afterZoomAnim) {\r\n\t\t\tthis.fire('movestart');\r\n\r\n\t\t\tif (zoomChanged) {\r\n\t\t\t\tthis.fire('zoomstart');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._zoom = zoom;\r\n\t\tthis._initialCenter = center;\r\n\r\n\t\tthis._initialTopLeftPoint = this._getNewTopLeftPoint(center);\r\n\r\n\t\tif (!preserveMapOffset) {\r\n\t\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\t\t} else {\r\n\t\t\tthis._initialTopLeftPoint._add(this._getMapPanePos());\r\n\t\t}\r\n\r\n\t\tthis._tileLayersToLoad = this._tileLayersNum;\r\n\r\n\t\tvar loading = !this._loaded;\r\n\t\tthis._loaded = true;\r\n\r\n\t\tthis.fire('viewreset', {hard: !preserveMapOffset});\r\n\r\n\t\tif (loading) {\r\n\t\t\tthis.fire('load');\r\n\t\t\tthis.eachLayer(this._layerAdd, this);\r\n\t\t}\r\n\r\n\t\tthis.fire('move');\r\n\r\n\t\tif (zoomChanged || afterZoomAnim) {\r\n\t\t\tthis.fire('zoomend');\r\n\t\t}\r\n\r\n\t\tthis.fire('moveend', {hard: !preserveMapOffset});\r\n\t},\r\n\r\n\t_rawPanBy: function (offset) {\r\n\t\tL.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n\t},\r\n\r\n\t_getZoomSpan: function () {\r\n\t\treturn this.getMaxZoom() - this.getMinZoom();\r\n\t},\r\n\r\n\t_updateZoomLevels: function () {\r\n\t\tvar i,\r\n\t\t\tminZoom = Infinity,\r\n\t\t\tmaxZoom = -Infinity,\r\n\t\t\toldZoomSpan = this._getZoomSpan();\r\n\r\n\t\tfor (i in this._zoomBoundLayers) {\r\n\t\t\tvar layer = this._zoomBoundLayers[i];\r\n\t\t\tif (!isNaN(layer.options.minZoom)) {\r\n\t\t\t\tminZoom = Math.min(minZoom, layer.options.minZoom);\r\n\t\t\t}\r\n\t\t\tif (!isNaN(layer.options.maxZoom)) {\r\n\t\t\t\tmaxZoom = Math.max(maxZoom, layer.options.maxZoom);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (i === undefined) { // we have no tilelayers\r\n\t\t\tthis._layersMaxZoom = this._layersMinZoom = undefined;\r\n\t\t} else {\r\n\t\t\tthis._layersMaxZoom = maxZoom;\r\n\t\t\tthis._layersMinZoom = minZoom;\r\n\t\t}\r\n\r\n\t\tif (oldZoomSpan !== this._getZoomSpan()) {\r\n\t\t\tthis.fire('zoomlevelschange');\r\n\t\t}\r\n\t},\r\n\r\n\t_panInsideMaxBounds: function () {\r\n\t\tthis.panInsideBounds(this.options.maxBounds);\r\n\t},\r\n\r\n\t_checkIfLoaded: function () {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthrow new Error('Set map center and zoom first.');\r\n\t\t}\r\n\t},\r\n\r\n\t// map events\r\n\r\n\t_initEvents: function (onOff) {\r\n\t\tif (!L.DomEvent) { return; }\r\n\r\n\t\tonOff = onOff || 'on';\r\n\r\n\t\tL.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\tvar events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',\r\n\t\t              'mouseleave', 'mousemove', 'contextmenu'],\r\n\t\t    i, len;\r\n\r\n\t\tfor (i = 0, len = events.length; i < len; i++) {\r\n\t\t\tL.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (this.options.trackResize) {\r\n\t\t\tL.DomEvent[onOff](window, 'resize', this._onResize, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onResize: function () {\r\n\t\tL.Util.cancelAnimFrame(this._resizeRequest);\r\n\t\tthis._resizeRequest = L.Util.requestAnimFrame(\r\n\t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (!this._loaded || (!e._simulated &&\r\n\t\t        ((this.dragging && this.dragging.moved()) ||\r\n\t\t         (this.boxZoom  && this.boxZoom.moved()))) ||\r\n\t\t            L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tthis.fire('preclick');\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._loaded || L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tvar type = e.type;\r\n\r\n\t\ttype = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));\r\n\r\n\t\tif (!this.hasEventListeners(type)) { return; }\r\n\r\n\t\tif (type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\r\n\t\tvar containerPoint = this.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = this.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = this.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\t},\r\n\r\n\t_onTileLayerLoad: function () {\r\n\t\tthis._tileLayersToLoad--;\r\n\t\tif (this._tileLayersNum && !this._tileLayersToLoad) {\r\n\t\t\tthis.fire('tilelayersload');\r\n\t\t}\r\n\t},\r\n\r\n\t_clearHandlers: function () {\r\n\t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n\t\t\tthis._handlers[i].disable();\r\n\t\t}\r\n\t},\r\n\r\n\twhenReady: function (callback, context) {\r\n\t\tif (this._loaded) {\r\n\t\t\tcallback.call(context || this, this);\r\n\t\t} else {\r\n\t\t\tthis.on('load', callback, context);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_layerAdd: function (layer) {\r\n\t\tlayer.onAdd(this);\r\n\t\tthis.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\r\n\t// private methods for getting map state\r\n\r\n\t_getMapPanePos: function () {\r\n\t\treturn L.DomUtil.getPosition(this._mapPane);\r\n\t},\r\n\r\n\t_moved: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\treturn pos && !pos.equals([0, 0]);\r\n\t},\r\n\r\n\t_getTopLeftPoint: function () {\r\n\t\treturn this.getPixelOrigin().subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\t_getNewTopLeftPoint: function (center, zoom) {\r\n\t\tvar viewHalf = this.getSize()._divideBy(2);\r\n\t\t// TODO round on display, not calculation to increase precision?\r\n\t\treturn this.project(center, zoom)._subtract(viewHalf)._round();\r\n\t},\r\n\r\n\t_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {\r\n\t\tvar topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());\r\n\t\treturn this.project(latlng, newZoom)._subtract(topLeft);\r\n\t},\r\n\r\n\t// layer point of the current center\r\n\t_getCenterLayerPoint: function () {\r\n\t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n\t},\r\n\r\n\t// offset of the specified place to the current center in pixels\r\n\t_getCenterOffset: function (latlng) {\r\n\t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\t// adjust center for view to get inside bounds\r\n\t_limitCenter: function (center, zoom, bounds) {\r\n\r\n\t\tif (!bounds) { return center; }\r\n\r\n\t\tvar centerPoint = this.project(center, zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n\t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n\t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n\t},\r\n\r\n\t// adjust offset for view to get inside bounds\r\n\t_limitOffset: function (offset, bounds) {\r\n\t\tif (!bounds) { return offset; }\r\n\r\n\t\tvar viewBounds = this.getPixelBounds(),\r\n\t\t    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n\t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n\t},\r\n\r\n\t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n\t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n\t\tvar nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\r\n\t\t    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\r\n\r\n\t\t    dx = this._rebound(nwOffset.x, -seOffset.x),\r\n\t\t    dy = this._rebound(nwOffset.y, -seOffset.y);\r\n\r\n\t\treturn new L.Point(dx, dy);\r\n\t},\r\n\r\n\t_rebound: function (left, right) {\r\n\t\treturn left + right > 0 ?\r\n\t\t\tMath.round(left - right) / 2 :\r\n\t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n\t},\r\n\r\n\t_limitZoom: function (zoom) {\r\n\t\tvar min = this.getMinZoom(),\r\n\t\t    max = this.getMaxZoom();\r\n\r\n\t\treturn Math.max(min, Math.min(max, zoom));\r\n\t}\r\n});\r\n\r\nL.map = function (id, options) {\r\n\treturn new L.Map(id, options);\r\n};\r\n\n\n/*\r\n * Mercator projection that takes into account that the Earth is not a perfect sphere.\r\n * Less popular than spherical mercator; used by projections like EPSG:3395.\r\n */\r\n\r\nL.Projection.Mercator = {\r\n\tMAX_LATITUDE: 85.0840591556,\r\n\r\n\tR_MINOR: 6356752.314245179,\r\n\tR_MAJOR: 6378137,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    x = latlng.lng * d * r,\r\n\t\t    y = lat * d,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1.0 - tmp * tmp),\r\n\t\t    con = eccent * Math.sin(y);\r\n\r\n\t\tcon = Math.pow((1 - con) / (1 + con), eccent * 0.5);\r\n\r\n\t\tvar ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;\r\n\t\ty = -r * Math.log(ts);\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    lng = point.x * d / r,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1 - (tmp * tmp)),\r\n\t\t    ts = Math.exp(- point.y / r),\r\n\t\t    phi = (Math.PI / 2) - 2 * Math.atan(ts),\r\n\t\t    numIter = 15,\r\n\t\t    tol = 1e-7,\r\n\t\t    i = numIter,\r\n\t\t    dphi = 0.1,\r\n\t\t    con;\r\n\r\n\t\twhile ((Math.abs(dphi) > tol) && (--i > 0)) {\r\n\t\t\tcon = eccent * Math.sin(phi);\r\n\t\t\tdphi = (Math.PI / 2) - 2 * Math.atan(ts *\r\n\t\t\t            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;\r\n\t\t\tphi += dphi;\r\n\t\t}\r\n\r\n\t\treturn new L.LatLng(phi * d, lng);\r\n\t}\r\n};\r\n\n\n\r\nL.CRS.EPSG3395 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3395',\r\n\r\n\tprojection: L.Projection.Mercator,\r\n\r\n\ttransformation: (function () {\r\n\t\tvar m = L.Projection.Mercator,\r\n\t\t    r = m.R_MAJOR,\r\n\t\t    scale = 0.5 / (Math.PI * r);\r\n\r\n\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\r\n\t}())\r\n});\r\n\n\n/*\r\n * L.TileLayer is used for standard xyz-numbered tile layers.\r\n */\r\n\r\nL.TileLayer = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminZoom: 0,\r\n\t\tmaxZoom: 18,\r\n\t\ttileSize: 256,\r\n\t\tsubdomains: 'abc',\r\n\t\terrorTileUrl: '',\r\n\t\tattribution: '',\r\n\t\tzoomOffset: 0,\r\n\t\topacity: 1,\r\n\t\t/*\r\n\t\tmaxNativeZoom: null,\r\n\t\tzIndex: null,\r\n\t\ttms: false,\r\n\t\tcontinuousWorld: false,\r\n\t\tnoWrap: false,\r\n\t\tzoomReverse: false,\r\n\t\tdetectRetina: false,\r\n\t\treuseTiles: false,\r\n\t\tbounds: false,\r\n\t\t*/\r\n\t\tunloadInvisibleTiles: L.Browser.mobile,\r\n\t\tupdateWhenIdle: L.Browser.mobile\r\n\t},\r\n\r\n\tinitialize: function (url, options) {\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n\t\tif (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\r\n\r\n\t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\t\t\toptions.zoomOffset++;\r\n\r\n\t\t\tif (options.minZoom > 0) {\r\n\t\t\t\toptions.minZoom--;\r\n\t\t\t}\r\n\t\t\tthis.options.maxZoom--;\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\toptions.bounds = L.latLngBounds(options.bounds);\r\n\t\t}\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar subdomains = this.options.subdomains;\r\n\r\n\t\tif (typeof subdomains === 'string') {\r\n\t\t\tthis.options.subdomains = subdomains.split('');\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._animated = map._zoomAnimated;\r\n\r\n\t\t// create a container div for tiles\r\n\t\tthis._initContainer();\r\n\r\n\t\t// set up events\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.on({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tthis._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);\r\n\t\t\tmap.on('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t\tthis._update();\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis._container.parentNode.removeChild(this._container);\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.off({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tmap.off('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._container = null;\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.appendChild(this._container);\r\n\t\t\tthis._setAutoZIndex(pane, Math.max);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.insertBefore(this._container, pane.firstChild);\r\n\t\t\tthis._setAutoZIndex(pane, Math.min);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\tthis.options.zIndex = zIndex;\r\n\t\tthis._updateZIndex();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url, noRedraw) {\r\n\t\tthis._url = url;\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateZIndex: function () {\r\n\t\tif (this._container && this.options.zIndex !== undefined) {\r\n\t\t\tthis._container.style.zIndex = this.options.zIndex;\r\n\t\t}\r\n\t},\r\n\r\n\t_setAutoZIndex: function (pane, compare) {\r\n\r\n\t\tvar layers = pane.children,\r\n\t\t    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min\r\n\t\t    zIndex, i, len;\r\n\r\n\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\r\n\t\t\tif (layers[i] !== this._container) {\r\n\t\t\t\tzIndex = parseInt(layers[i].style.zIndex, 10);\r\n\r\n\t\t\t\tif (!isNaN(zIndex)) {\r\n\t\t\t\t\tedgeZIndex = compare(edgeZIndex, zIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.options.zIndex = this._container.style.zIndex =\r\n\t\t        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tvar i,\r\n\t\t    tiles = this._tiles;\r\n\r\n\t\tif (L.Browser.ielt9) {\r\n\t\t\tfor (i in tiles) {\r\n\t\t\t\tL.DomUtil.setOpacity(tiles[i], this.options.opacity);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tL.DomUtil.setOpacity(this._container, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_initContainer: function () {\r\n\t\tvar tilePane = this._map._panes.tilePane;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._container = L.DomUtil.create('div', 'leaflet-layer');\r\n\r\n\t\t\tthis._updateZIndex();\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\tvar className = 'leaflet-tile-container';\r\n\r\n\t\t\t\tthis._bgBuffer = L.DomUtil.create('div', className, this._container);\r\n\t\t\t\tthis._tileContainer = L.DomUtil.create('div', className, this._container);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tthis._tileContainer = this._container;\r\n\t\t\t}\r\n\r\n\t\t\ttilePane.appendChild(this._container);\r\n\r\n\t\t\tif (this.options.opacity < 1) {\r\n\t\t\t\tthis._updateOpacity();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_reset: function (e) {\r\n\t\tfor (var key in this._tiles) {\r\n\t\t\tthis.fire('tileunload', {tile: this._tiles[key]});\r\n\t\t}\r\n\r\n\t\tthis._tiles = {};\r\n\t\tthis._tilesToLoad = 0;\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tthis._unusedTiles = [];\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.innerHTML = '';\r\n\r\n\t\tif (this._animated && e && e.hard) {\r\n\t\t\tthis._clearBgBuffer();\r\n\t\t}\r\n\r\n\t\tthis._initContainer();\r\n\t},\r\n\r\n\t_getTileSize: function () {\r\n\t\tvar map = this._map,\r\n\t\t    zoom = map.getZoom() + this.options.zoomOffset,\r\n\t\t    zoomN = this.options.maxNativeZoom,\r\n\t\t    tileSize = this.options.tileSize;\r\n\r\n\t\tif (zoomN && zoom > zoomN) {\r\n\t\t\ttileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);\r\n\t\t}\r\n\r\n\t\treturn tileSize;\r\n\t},\r\n\r\n\t_update: function () {\r\n\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    bounds = map.getPixelBounds(),\r\n\t\t    zoom = map.getZoom(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tileBounds = L.bounds(\r\n\t\t        bounds.min.divideBy(tileSize)._floor(),\r\n\t\t        bounds.max.divideBy(tileSize)._floor());\r\n\r\n\t\tthis._addTilesFromCenterOut(tileBounds);\r\n\r\n\t\tif (this.options.unloadInvisibleTiles || this.options.reuseTiles) {\r\n\t\t\tthis._removeOtherTiles(tileBounds);\r\n\t\t}\r\n\t},\r\n\r\n\t_addTilesFromCenterOut: function (bounds) {\r\n\t\tvar queue = [],\r\n\t\t    center = bounds.getCenter();\r\n\r\n\t\tvar j, i, point;\r\n\r\n\t\tfor (j = bounds.min.y; j <= bounds.max.y; j++) {\r\n\t\t\tfor (i = bounds.min.x; i <= bounds.max.x; i++) {\r\n\t\t\t\tpoint = new L.Point(i, j);\r\n\r\n\t\t\t\tif (this._tileShouldBeLoaded(point)) {\r\n\t\t\t\t\tqueue.push(point);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar tilesToLoad = queue.length;\r\n\r\n\t\tif (tilesToLoad === 0) { return; }\r\n\r\n\t\t// load tiles in order of their distance to center\r\n\t\tqueue.sort(function (a, b) {\r\n\t\t\treturn a.distanceTo(center) - b.distanceTo(center);\r\n\t\t});\r\n\r\n\t\tvar fragment = document.createDocumentFragment();\r\n\r\n\t\t// if its the first batch of tiles to load\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('loading');\r\n\t\t}\r\n\r\n\t\tthis._tilesToLoad += tilesToLoad;\r\n\r\n\t\tfor (i = 0; i < tilesToLoad; i++) {\r\n\t\t\tthis._addTile(queue[i], fragment);\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.appendChild(fragment);\r\n\t},\r\n\r\n\t_tileShouldBeLoaded: function (tilePoint) {\r\n\t\tif ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {\r\n\t\t\treturn false; // already loaded\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (!options.continuousWorld) {\r\n\t\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t\t// don't load if exceeds world bounds\r\n\t\t\tif ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||\r\n\t\t\t\ttilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\tvar tileSize = this._getTileSize(),\r\n\t\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\t\t\t    nw = this._map.unproject(nwPoint),\r\n\t\t\t    se = this._map.unproject(sePoint);\r\n\r\n\t\t\t// TODO temporary hack, will be removed after refactoring projections\r\n\t\t\t// https://github.com/Leaflet/Leaflet/issues/1618\r\n\t\t\tif (!options.continuousWorld && !options.noWrap) {\r\n\t\t\t\tnw = nw.wrap();\r\n\t\t\t\tse = se.wrap();\r\n\t\t\t}\r\n\r\n\t\t\tif (!options.bounds.intersects([nw, se])) { return false; }\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_removeOtherTiles: function (bounds) {\r\n\t\tvar kArr, x, y, key;\r\n\r\n\t\tfor (key in this._tiles) {\r\n\t\t\tkArr = key.split(':');\r\n\t\t\tx = parseInt(kArr[0], 10);\r\n\t\t\ty = parseInt(kArr[1], 10);\r\n\r\n\t\t\t// remove tile if it's out of bounds\r\n\t\t\tif (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {\r\n\t\t\t\tthis._removeTile(key);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_removeTile: function (key) {\r\n\t\tvar tile = this._tiles[key];\r\n\r\n\t\tthis.fire('tileunload', {tile: tile, url: tile.src});\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tL.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\r\n\t\t\tthis._unusedTiles.push(tile);\r\n\r\n\t\t} else if (tile.parentNode === this._tileContainer) {\r\n\t\t\tthis._tileContainer.removeChild(tile);\r\n\t\t}\r\n\r\n\t\t// for https://github.com/CloudMade/Leaflet/issues/137\r\n\t\tif (!L.Browser.android) {\r\n\t\t\ttile.onload = null;\r\n\t\t\ttile.src = L.Util.emptyImageUrl;\r\n\t\t}\r\n\r\n\t\tdelete this._tiles[key];\r\n\t},\r\n\r\n\t_addTile: function (tilePoint, container) {\r\n\t\tvar tilePos = this._getTilePos(tilePoint);\r\n\r\n\t\t// get unused tile - or create a new tile\r\n\t\tvar tile = this._getTile();\r\n\r\n\t\t/*\r\n\t\tChrome 20 layouts much faster with top/left (verify with timeline, frames)\r\n\t\tAndroid 4 browser has display issues with top/left and requires transform instead\r\n\t\t(other browsers don't currently care) - see debug/hacks/jitter.html for an example\r\n\t\t*/\r\n\t\tL.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);\r\n\r\n\t\tthis._tiles[tilePoint.x + ':' + tilePoint.y] = tile;\r\n\r\n\t\tthis._loadTile(tile, tilePoint);\r\n\r\n\t\tif (tile.parentNode !== this._tileContainer) {\r\n\t\t\tcontainer.appendChild(tile);\r\n\t\t}\r\n\t},\r\n\r\n\t_getZoomForUrl: function () {\r\n\r\n\t\tvar options = this.options,\r\n\t\t    zoom = this._map.getZoom();\r\n\r\n\t\tif (options.zoomReverse) {\r\n\t\t\tzoom = options.maxZoom - zoom;\r\n\t\t}\r\n\r\n\t\tzoom += options.zoomOffset;\r\n\r\n\t\treturn options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;\r\n\t},\r\n\r\n\t_getTilePos: function (tilePoint) {\r\n\t\tvar origin = this._map.getPixelOrigin(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\treturn tilePoint.multiplyBy(tileSize).subtract(origin);\r\n\t},\r\n\r\n\t// image-specific code (override to implement e.g. Canvas or SVG tile layer)\r\n\r\n\tgetTileUrl: function (tilePoint) {\r\n\t\treturn L.Util.template(this._url, L.extend({\r\n\t\t\ts: this._getSubdomain(tilePoint),\r\n\t\t\tz: tilePoint.z,\r\n\t\t\tx: tilePoint.x,\r\n\t\t\ty: tilePoint.y\r\n\t\t}, this.options));\r\n\t},\r\n\r\n\t_getWrapTileNum: function () {\r\n\t\tvar crs = this._map.options.crs,\r\n\t\t    size = crs.getSize(this._map.getZoom());\r\n\t\treturn size.divideBy(this._getTileSize())._floor();\r\n\t},\r\n\r\n\t_adjustTilePoint: function (tilePoint) {\r\n\r\n\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t// wrap tile coordinates\r\n\t\tif (!this.options.continuousWorld && !this.options.noWrap) {\r\n\t\t\ttilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;\r\n\t\t}\r\n\r\n\t\tif (this.options.tms) {\r\n\t\t\ttilePoint.y = limit.y - tilePoint.y - 1;\r\n\t\t}\r\n\r\n\t\ttilePoint.z = this._getZoomForUrl();\r\n\t},\r\n\r\n\t_getSubdomain: function (tilePoint) {\r\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n\t\treturn this.options.subdomains[index];\r\n\t},\r\n\r\n\t_getTile: function () {\r\n\t\tif (this.options.reuseTiles && this._unusedTiles.length > 0) {\r\n\t\t\tvar tile = this._unusedTiles.pop();\r\n\t\t\tthis._resetTile(tile);\r\n\t\t\treturn tile;\r\n\t\t}\r\n\t\treturn this._createTile();\r\n\t},\r\n\r\n\t// Override if data stored on a tile needs to be cleaned up before reuse\r\n\t_resetTile: function (/*tile*/) {},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('img', 'leaflet-tile');\r\n\t\ttile.style.width = tile.style.height = this._getTileSize() + 'px';\r\n\t\ttile.galleryimg = 'no';\r\n\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\r\n\t\tif (L.Browser.ielt9 && this.options.opacity !== undefined) {\r\n\t\t\tL.DomUtil.setOpacity(tile, this.options.opacity);\r\n\t\t}\r\n\t\t// without this hack, tiles disappear after zoom on Chrome for Android\r\n\t\t// https://github.com/Leaflet/Leaflet/issues/2078\r\n\t\tif (L.Browser.mobileWebkit3d) {\r\n\t\t\ttile.style.WebkitBackfaceVisibility = 'hidden';\r\n\t\t}\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer  = this;\r\n\t\ttile.onload  = this._tileOnLoad;\r\n\t\ttile.onerror = this._tileOnError;\r\n\r\n\t\tthis._adjustTilePoint(tilePoint);\r\n\t\ttile.src     = this.getTileUrl(tilePoint);\r\n\r\n\t\tthis.fire('tileloadstart', {\r\n\t\t\ttile: tile,\r\n\t\t\turl: tile.src\r\n\t\t});\r\n\t},\r\n\r\n\t_tileLoaded: function () {\r\n\t\tthis._tilesToLoad--;\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tL.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\r\n\t\t}\r\n\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('load');\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\t// clear scaled tiles after all new tiles are loaded (for performance)\r\n\t\t\t\tclearTimeout(this._clearBgBufferTimer);\r\n\t\t\t\tthis._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_tileOnLoad: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\t//Only if we are loading an actual image\r\n\t\tif (this.src !== L.Util.emptyImageUrl) {\r\n\t\t\tL.DomUtil.addClass(this, 'leaflet-tile-loaded');\r\n\r\n\t\t\tlayer.fire('tileload', {\r\n\t\t\t\ttile: this,\r\n\t\t\t\turl: this.src\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t},\r\n\r\n\t_tileOnError: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\tlayer.fire('tileerror', {\r\n\t\t\ttile: this,\r\n\t\t\turl: this.src\r\n\t\t});\r\n\r\n\t\tvar newUrl = layer.options.errorTileUrl;\r\n\t\tif (newUrl) {\r\n\t\t\tthis.src = newUrl;\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t}\r\n});\r\n\r\nL.tileLayer = function (url, options) {\r\n\treturn new L.TileLayer(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.WMS is used for putting WMS tile layers on the map.\r\n */\r\n\r\nL.TileLayer.WMS = L.TileLayer.extend({\r\n\r\n\tdefaultWmsParams: {\r\n\t\tservice: 'WMS',\r\n\t\trequest: 'GetMap',\r\n\t\tversion: '1.1.1',\r\n\t\tlayers: '',\r\n\t\tstyles: '',\r\n\t\tformat: 'image/jpeg',\r\n\t\ttransparent: false\r\n\t},\r\n\r\n\tinitialize: function (url, options) { // (String, Object)\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar wmsParams = L.extend({}, this.defaultWmsParams),\r\n\t\t    tileSize = options.tileSize || this.options.tileSize;\r\n\r\n\t\tif (options.detectRetina && L.Browser.retina) {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize * 2;\r\n\t\t} else {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize;\r\n\t\t}\r\n\r\n\t\tfor (var i in options) {\r\n\t\t\t// all keys that are not TileLayer options go to WMS params\r\n\t\t\tif (!this.options.hasOwnProperty(i) && i !== 'crs') {\r\n\t\t\t\twmsParams[i] = options[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.wmsParams = wmsParams;\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\r\n\t\tthis._crs = this.options.crs || map.options.crs;\r\n\r\n\t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n\t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n\t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\r\n\t\tL.TileLayer.prototype.onAdd.call(this, map);\r\n\t},\r\n\r\n\tgetTileUrl: function (tilePoint) { // (Point, Number) -> String\r\n\r\n\t\tvar map = this._map,\r\n\t\t    tileSize = this.options.tileSize,\r\n\r\n\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\r\n\t\t    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\r\n\t\t    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\r\n\t\t    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?\r\n\t\t        [se.y, nw.x, nw.y, se.x].join(',') :\r\n\t\t        [nw.x, se.y, se.x, nw.y].join(','),\r\n\r\n\t\t    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});\r\n\r\n\t\treturn url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;\r\n\t},\r\n\r\n\tsetParams: function (params, noRedraw) {\r\n\r\n\t\tL.extend(this.wmsParams, params);\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.tileLayer.wms = function (url, options) {\r\n\treturn new L.TileLayer.WMS(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.Canvas is a class that you can use as a base for creating\r\n * dynamically drawn Canvas-based tile layers.\r\n */\r\n\r\nL.TileLayer.Canvas = L.TileLayer.extend({\r\n\toptions: {\r\n\t\tasync: false\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tfor (var i in this._tiles) {\r\n\t\t\tthis._redrawTile(this._tiles[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_redrawTile: function (tile) {\r\n\t\tthis.drawTile(tile, tile._tilePoint, this._map._zoom);\r\n\t},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('canvas', 'leaflet-tile');\r\n\t\ttile.width = tile.height = this.options.tileSize;\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer = this;\r\n\t\ttile._tilePoint = tilePoint;\r\n\r\n\t\tthis._redrawTile(tile);\r\n\r\n\t\tif (!this.options.async) {\r\n\t\t\tthis.tileDrawn(tile);\r\n\t\t}\r\n\t},\r\n\r\n\tdrawTile: function (/*tile, tilePoint*/) {\r\n\t\t// override with rendering code\r\n\t},\r\n\r\n\ttileDrawn: function (tile) {\r\n\t\tthis._tileOnLoad.call(tile);\r\n\t}\r\n});\r\n\r\n\r\nL.tileLayer.canvas = function (options) {\r\n\treturn new L.TileLayer.Canvas(options);\r\n};\r\n\n\n/*\r\n * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\r\n */\r\n\r\nL.ImageOverlay = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\topacity: 1\r\n\t},\r\n\r\n\tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n\t\tthis._url = url;\r\n\t\tthis._bounds = L.latLngBounds(bounds);\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._image) {\r\n\t\t\tthis._initImage();\r\n\t\t}\r\n\r\n\t\tmap._panes.overlayPane.appendChild(this._image);\r\n\r\n\t\tmap.on('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.getPanes().overlayPane.removeChild(this._image);\r\n\r\n\t\tmap.off('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation) {\r\n\t\t\tmap.off('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tthis._updateOpacity();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// TODO remove bringToFront/bringToBack duplication from TileLayer/Path\r\n\tbringToFront: function () {\r\n\t\tif (this._image) {\r\n\t\t\tthis._map._panes.overlayPane.appendChild(this._image);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.overlayPane;\r\n\t\tif (this._image) {\r\n\t\t\tpane.insertBefore(this._image, pane.firstChild);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url) {\r\n\t\tthis._url = url;\r\n\t\tthis._image.src = this._url;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\t_initImage: function () {\r\n\t\tthis._image = L.DomUtil.create('img', 'leaflet-image-layer');\r\n\r\n\t\tif (this._map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-animated');\r\n\t\t} else {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-hide');\r\n\t\t}\r\n\r\n\t\tthis._updateOpacity();\r\n\r\n\t\t//TODO createImage util method to remove duplication\r\n\t\tL.extend(this._image, {\r\n\t\t\tgalleryimg: 'no',\r\n\t\t\tonselectstart: L.Util.falseFn,\r\n\t\t\tonmousemove: L.Util.falseFn,\r\n\t\t\tonload: L.bind(this._onImageLoad, this),\r\n\t\t\tsrc: this._url\r\n\t\t});\r\n\t},\r\n\r\n\t_animateZoom: function (e) {\r\n\t\tvar map = this._map,\r\n\t\t    image = this._image,\r\n\t\t    scale = map.getZoomScale(e.zoom),\r\n\t\t    nw = this._bounds.getNorthWest(),\r\n\t\t    se = this._bounds.getSouthEast(),\r\n\r\n\t\t    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),\r\n\t\t    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),\r\n\t\t    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));\r\n\r\n\t\timage.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';\r\n\t},\r\n\r\n\t_reset: function () {\r\n\t\tvar image   = this._image,\r\n\t\t    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n\t\t    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);\r\n\r\n\t\tL.DomUtil.setPosition(image, topLeft);\r\n\r\n\t\timage.style.width  = size.x + 'px';\r\n\t\timage.style.height = size.y + 'px';\r\n\t},\r\n\r\n\t_onImageLoad: function () {\r\n\t\tthis.fire('load');\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._image, this.options.opacity);\r\n\t}\r\n});\r\n\r\nL.imageOverlay = function (url, bounds, options) {\r\n\treturn new L.ImageOverlay(url, bounds, options);\r\n};\r\n\n\n/*\r\n * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\r\n */\r\n\r\nL.Icon = L.Class.extend({\r\n\toptions: {\r\n\t\t/*\r\n\t\ticonUrl: (String) (required)\r\n\t\ticonRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\ticonSize: (Point) (can be set through CSS)\r\n\t\ticonAnchor: (Point) (centered by default, can be set in CSS with negative margins)\r\n\t\tpopupAnchor: (Point) (if not specified, popup opens in the anchor point)\r\n\t\tshadowUrl: (String) (no shadow by default)\r\n\t\tshadowRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\tshadowSize: (Point)\r\n\t\tshadowAnchor: (Point)\r\n\t\t*/\r\n\t\tclassName: ''\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tcreateIcon: function (oldIcon) {\r\n\t\treturn this._createIcon('icon', oldIcon);\r\n\t},\r\n\r\n\tcreateShadow: function (oldIcon) {\r\n\t\treturn this._createIcon('shadow', oldIcon);\r\n\t},\r\n\r\n\t_createIcon: function (name, oldIcon) {\r\n\t\tvar src = this._getIconUrl(name);\r\n\r\n\t\tif (!src) {\r\n\t\t\tif (name === 'icon') {\r\n\t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar img;\r\n\t\tif (!oldIcon || oldIcon.tagName !== 'IMG') {\r\n\t\t\timg = this._createImg(src);\r\n\t\t} else {\r\n\t\t\timg = this._createImg(src, oldIcon);\r\n\t\t}\r\n\t\tthis._setIconStyles(img, name);\r\n\r\n\t\treturn img;\r\n\t},\r\n\r\n\t_setIconStyles: function (img, name) {\r\n\t\tvar options = this.options,\r\n\t\t    size = L.point(options[name + 'Size']),\r\n\t\t    anchor;\r\n\r\n\t\tif (name === 'shadow') {\r\n\t\t\tanchor = L.point(options.shadowAnchor || options.iconAnchor);\r\n\t\t} else {\r\n\t\t\tanchor = L.point(options.iconAnchor);\r\n\t\t}\r\n\r\n\t\tif (!anchor && size) {\r\n\t\t\tanchor = size.divideBy(2, true);\r\n\t\t}\r\n\r\n\t\timg.className = 'leaflet-marker-' + name + ' ' + options.className;\r\n\r\n\t\tif (anchor) {\r\n\t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n\t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n\t\t}\r\n\r\n\t\tif (size) {\r\n\t\t\timg.style.width  = size.x + 'px';\r\n\t\t\timg.style.height = size.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\t_createImg: function (src, el) {\r\n\t\tel = el || document.createElement('img');\r\n\t\tel.src = src;\r\n\t\treturn el;\r\n\t},\r\n\r\n\t_getIconUrl: function (name) {\r\n\t\tif (L.Browser.retina && this.options[name + 'RetinaUrl']) {\r\n\t\t\treturn this.options[name + 'RetinaUrl'];\r\n\t\t}\r\n\t\treturn this.options[name + 'Url'];\r\n\t}\r\n});\r\n\r\nL.icon = function (options) {\r\n\treturn new L.Icon(options);\r\n};\r\n\n\n/*\n * L.Icon.Default is the blue marker icon used by default in Leaflet.\n */\n\nL.Icon.Default = L.Icon.extend({\n\n\toptions: {\n\t\ticonSize: [25, 41],\n\t\ticonAnchor: [12, 41],\n\t\tpopupAnchor: [1, -34],\n\n\t\tshadowSize: [41, 41]\n\t},\n\n\t_getIconUrl: function (name) {\n\t\tvar key = name + 'Url';\n\n\t\tif (this.options[key]) {\n\t\t\treturn this.options[key];\n\t\t}\n\n\t\tif (L.Browser.retina && name === 'icon') {\n\t\t\tname += '-2x';\n\t\t}\n\n\t\tvar path = L.Icon.Default.imagePath;\n\n\t\tif (!path) {\n\t\t\tthrow new Error('Couldn\\'t autodetect L.Icon.Default.imagePath, set it manually.');\n\t\t}\n\n\t\treturn path + '/marker-' + name + '.png';\n\t}\n});\n\nL.Icon.Default.imagePath = (function () {\n\tvar scripts = document.getElementsByTagName('script'),\n\t    leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n\tvar i, len, src, matches, path;\n\n\tfor (i = 0, len = scripts.length; i < len; i++) {\n\t\tsrc = scripts[i].src;\n\t\tmatches = src.match(leafletRe);\n\n\t\tif (matches) {\n\t\t\tpath = src.split(leafletRe)[0];\n\t\t\treturn (path ? path + '/' : '') + 'images';\n\t\t}\n\t}\n}());\n\n\n/*\r\n * L.Marker is used to display clickable/draggable icons on the map.\r\n */\r\n\r\nL.Marker = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\ticon: new L.Icon.Default(),\r\n\t\ttitle: '',\r\n\t\talt: '',\r\n\t\tclickable: true,\r\n\t\tdraggable: false,\r\n\t\tkeyboard: true,\r\n\t\tzIndexOffset: 0,\r\n\t\topacity: 1,\r\n\t\triseOnHover: false,\r\n\t\triseOffset: 250\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.setOptions(this, options);\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tmap.on('viewreset', this.update, this);\r\n\r\n\t\tthis._initIcon();\r\n\t\tthis.update();\r\n\t\tthis.fire('add');\r\n\r\n\t\tif (map.options.zoomAnimation && map.options.markerZoomAnimation) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tif (this.dragging) {\r\n\t\t\tthis.dragging.disable();\r\n\t\t}\r\n\r\n\t\tthis._removeIcon();\r\n\t\tthis._removeShadow();\r\n\r\n\t\tthis.fire('remove');\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.update,\r\n\t\t\t'zoomanim': this._animateZoom\r\n\t\t}, this);\r\n\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\r\n\t\tthis.update();\r\n\r\n\t\treturn this.fire('move', { latlng: this._latlng });\r\n\t},\r\n\r\n\tsetZIndexOffset: function (offset) {\r\n\t\tthis.options.zIndexOffset = offset;\r\n\t\tthis.update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetIcon: function (icon) {\r\n\r\n\t\tthis.options.icon = icon;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._initIcon();\r\n\t\t\tthis.update();\r\n\t\t}\r\n\r\n\t\tif (this._popup) {\r\n\t\t\tthis.bindPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (this._icon) {\r\n\t\t\tthis._setPos(this._map.latLngToLayerPoint(this._latlng).round());\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initIcon: function () {\r\n\t\tvar options = this.options,\r\n\t\t    map = this._map,\r\n\t\t    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),\r\n\t\t    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';\r\n\r\n\t\tvar icon = options.icon.createIcon(this._icon),\r\n\t\t\taddIcon = false;\r\n\r\n\t\t// if we're not reusing the icon, remove the old one and init new one\r\n\t\tif (icon !== this._icon) {\r\n\t\t\tif (this._icon) {\r\n\t\t\t\tthis._removeIcon();\r\n\t\t\t}\r\n\t\t\taddIcon = true;\r\n\r\n\t\t\tif (options.title) {\r\n\t\t\t\ticon.title = options.title;\r\n\t\t\t}\r\n\r\n\t\t\tif (options.alt) {\r\n\t\t\t\ticon.alt = options.alt;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tL.DomUtil.addClass(icon, classToAdd);\r\n\r\n\t\tif (options.keyboard) {\r\n\t\t\ticon.tabIndex = '0';\r\n\t\t}\r\n\r\n\t\tthis._icon = icon;\r\n\r\n\t\tthis._initInteraction();\r\n\r\n\t\tif (options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.on(icon, 'mouseover', this._bringToFront, this)\r\n\t\t\t\t.on(icon, 'mouseout', this._resetZIndex, this);\r\n\t\t}\r\n\r\n\t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n\t\t\taddShadow = false;\r\n\r\n\t\tif (newShadow !== this._shadow) {\r\n\t\t\tthis._removeShadow();\r\n\t\t\taddShadow = true;\r\n\t\t}\r\n\r\n\t\tif (newShadow) {\r\n\t\t\tL.DomUtil.addClass(newShadow, classToAdd);\r\n\t\t}\r\n\t\tthis._shadow = newShadow;\r\n\r\n\r\n\t\tif (options.opacity < 1) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\r\n\t\tvar panes = this._map._panes;\r\n\r\n\t\tif (addIcon) {\r\n\t\t\tpanes.markerPane.appendChild(this._icon);\r\n\t\t}\r\n\r\n\t\tif (newShadow && addShadow) {\r\n\t\t\tpanes.shadowPane.appendChild(this._shadow);\r\n\t\t}\r\n\t},\r\n\r\n\t_removeIcon: function () {\r\n\t\tif (this.options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(this._icon, 'mouseover', this._bringToFront)\r\n\t\t\t    .off(this._icon, 'mouseout', this._resetZIndex);\r\n\t\t}\r\n\r\n\t\tthis._map._panes.markerPane.removeChild(this._icon);\r\n\r\n\t\tthis._icon = null;\r\n\t},\r\n\r\n\t_removeShadow: function () {\r\n\t\tif (this._shadow) {\r\n\t\t\tthis._map._panes.shadowPane.removeChild(this._shadow);\r\n\t\t}\r\n\t\tthis._shadow = null;\r\n\t},\r\n\r\n\t_setPos: function (pos) {\r\n\t\tL.DomUtil.setPosition(this._icon, pos);\r\n\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setPosition(this._shadow, pos);\r\n\t\t}\r\n\r\n\t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n\t\tthis._resetZIndex();\r\n\t},\r\n\r\n\t_updateZIndex: function (offset) {\r\n\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n\t},\r\n\r\n\t_animateZoom: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n\t\tthis._setPos(pos);\r\n\t},\r\n\r\n\t_initInteraction: function () {\r\n\r\n\t\tif (!this.options.clickable) { return; }\r\n\r\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\r\n\r\n\t\tvar icon = this._icon,\r\n\t\t    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];\r\n\r\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\r\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\r\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\r\n\r\n\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n\t\t\tif (this.options.draggable) {\r\n\t\t\t\tthis.dragging.enable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tvar wasDragged = this.dragging && this.dragging.moved();\r\n\r\n\t\tif (this.hasEventListeners(e.type) || wasDragged) {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\r\n\t\tif (wasDragged) { return; }\r\n\r\n\t\tif ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\t},\r\n\r\n\t_onKeyPress: function (e) {\r\n\t\tif (e.keyCode === 13) {\r\n\t\t\tthis.fire('click', {\r\n\t\t\t\toriginalEvent: e,\r\n\t\t\t\tlatlng: this._latlng\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\r\n\t\t// TODO proper custom event propagation\r\n\t\t// this line will always be called if marker is in a FeatureGroup\r\n\t\tif (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousedown') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._icon, this.options.opacity);\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setOpacity(this._shadow, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_bringToFront: function () {\r\n\t\tthis._updateZIndex(this.options.riseOffset);\r\n\t},\r\n\r\n\t_resetZIndex: function () {\r\n\t\tthis._updateZIndex(0);\r\n\t}\r\n});\r\n\r\nL.marker = function (latlng, options) {\r\n\treturn new L.Marker(latlng, options);\r\n};\r\n\n\n/*\n * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n * to use with L.Marker.\n */\n\nL.DivIcon = L.Icon.extend({\n\toptions: {\n\t\ticonSize: [12, 12], // also can be set through CSS\n\t\t/*\n\t\ticonAnchor: (Point)\n\t\tpopupAnchor: (Point)\n\t\thtml: (String)\n\t\tbgPos: (Point)\n\t\t*/\n\t\tclassName: 'leaflet-div-icon',\n\t\thtml: false\n\t},\n\n\tcreateIcon: function (oldIcon) {\n\t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n\t\t    options = this.options;\n\n\t\tif (options.html !== false) {\n\t\t\tdiv.innerHTML = options.html;\n\t\t} else {\n\t\t\tdiv.innerHTML = '';\n\t\t}\n\n\t\tif (options.bgPos) {\n\t\t\tdiv.style.backgroundPosition =\n\t\t\t        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n\t\t}\n\n\t\tthis._setIconStyles(div, 'icon');\n\t\treturn div;\n\t},\n\n\tcreateShadow: function () {\n\t\treturn null;\n\t}\n});\n\nL.divIcon = function (options) {\n\treturn new L.DivIcon(options);\n};\n\n\n/*\r\n * L.Popup is used for displaying popups on the map.\r\n */\r\n\r\nL.Map.mergeOptions({\r\n\tclosePopupOnClick: true\r\n});\r\n\r\nL.Popup = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminWidth: 50,\r\n\t\tmaxWidth: 300,\r\n\t\t// maxHeight: null,\r\n\t\tautoPan: true,\r\n\t\tcloseButton: true,\r\n\t\toffset: [0, 7],\r\n\t\tautoPanPadding: [5, 5],\r\n\t\t// autoPanPaddingTopLeft: null,\r\n\t\t// autoPanPaddingBottomRight: null,\r\n\t\tkeepInView: false,\r\n\t\tclassName: '',\r\n\t\tzoomAnimation: true\r\n\t},\r\n\r\n\tinitialize: function (options, source) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._source = source;\r\n\t\tthis._animated = L.Browser.any3d && this.options.zoomAnimation;\r\n\t\tthis._isOpen = false;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initLayout();\r\n\t\t}\r\n\r\n\t\tvar animFade = map.options.fadeAnimation;\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\t\tmap._panes.popupPane.appendChild(this._container);\r\n\r\n\t\tmap.on(this._getEvents(), this);\r\n\r\n\t\tthis.update();\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 1);\r\n\t\t}\r\n\r\n\t\tthis.fire('open');\r\n\r\n\t\tmap.fire('popupopen', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupopen', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenOn: function (map) {\r\n\t\tmap.openPopup(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._panes.popupPane.removeChild(this._container);\r\n\r\n\t\tL.Util.falseFn(this._container.offsetWidth); // force reflow\r\n\r\n\t\tmap.off(this._getEvents(), this);\r\n\r\n\t\tif (map.options.fadeAnimation) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\r\n\t\tthis._map = null;\r\n\r\n\t\tthis.fire('close');\r\n\r\n\t\tmap.fire('popupclose', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupclose', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tif (this._map) {\r\n\t\t\tthis._updatePosition();\r\n\t\t\tthis._adjustPan();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContent: function () {\r\n\t\treturn this._content;\r\n\t},\r\n\r\n\tsetContent: function (content) {\r\n\t\tthis._content = content;\r\n\t\tthis.update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._container.style.visibility = 'hidden';\r\n\r\n\t\tthis._updateContent();\r\n\t\tthis._updateLayout();\r\n\t\tthis._updatePosition();\r\n\r\n\t\tthis._container.style.visibility = '';\r\n\r\n\t\tthis._adjustPan();\r\n\t},\r\n\r\n\t_getEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tviewreset: this._updatePosition\r\n\t\t};\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tevents.zoomanim = this._zoomAnimation;\r\n\t\t}\r\n\t\tif ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n\t\t\tevents.preclick = this._close;\r\n\t\t}\r\n\t\tif (this.options.keepInView) {\r\n\t\t\tevents.moveend = this._adjustPan;\r\n\t\t}\r\n\r\n\t\treturn events;\r\n\t},\r\n\r\n\t_close: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.closePopup(this);\r\n\t\t}\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar prefix = 'leaflet-popup',\r\n\t\t\tcontainerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +\r\n\t\t\t        (this._animated ? 'animated' : 'hide'),\r\n\t\t\tcontainer = this._container = L.DomUtil.create('div', containerClass),\r\n\t\t\tcloseButton;\r\n\r\n\t\tif (this.options.closeButton) {\r\n\t\t\tcloseButton = this._closeButton =\r\n\t\t\t        L.DomUtil.create('a', prefix + '-close-button', container);\r\n\t\t\tcloseButton.href = '#close';\r\n\t\t\tcloseButton.innerHTML = '&#215;';\r\n\t\t\tL.DomEvent.disableClickPropagation(closeButton);\r\n\r\n\t\t\tL.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\r\n\t\t}\r\n\r\n\t\tvar wrapper = this._wrapper =\r\n\t\t        L.DomUtil.create('div', prefix + '-content-wrapper', container);\r\n\t\tL.DomEvent.disableClickPropagation(wrapper);\r\n\r\n\t\tthis._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\r\n\r\n\t\tL.DomEvent.disableScrollPropagation(this._contentNode);\r\n\t\tL.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\r\n\r\n\t\tthis._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\r\n\t\tthis._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\r\n\t},\r\n\r\n\t_updateContent: function () {\r\n\t\tif (!this._content) { return; }\r\n\r\n\t\tif (typeof this._content === 'string') {\r\n\t\t\tthis._contentNode.innerHTML = this._content;\r\n\t\t} else {\r\n\t\t\twhile (this._contentNode.hasChildNodes()) {\r\n\t\t\t\tthis._contentNode.removeChild(this._contentNode.firstChild);\r\n\t\t\t}\r\n\t\t\tthis._contentNode.appendChild(this._content);\r\n\t\t}\r\n\t\tthis.fire('contentupdate');\r\n\t},\r\n\r\n\t_updateLayout: function () {\r\n\t\tvar container = this._contentNode,\r\n\t\t    style = container.style;\r\n\r\n\t\tstyle.width = '';\r\n\t\tstyle.whiteSpace = 'nowrap';\r\n\r\n\t\tvar width = container.offsetWidth;\r\n\t\twidth = Math.min(width, this.options.maxWidth);\r\n\t\twidth = Math.max(width, this.options.minWidth);\r\n\r\n\t\tstyle.width = (width + 1) + 'px';\r\n\t\tstyle.whiteSpace = '';\r\n\r\n\t\tstyle.height = '';\r\n\r\n\t\tvar height = container.offsetHeight,\r\n\t\t    maxHeight = this.options.maxHeight,\r\n\t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n\t\tif (maxHeight && height > maxHeight) {\r\n\t\t\tstyle.height = maxHeight + 'px';\r\n\t\t\tL.DomUtil.addClass(container, scrolledClass);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.removeClass(container, scrolledClass);\r\n\t\t}\r\n\r\n\t\tthis._containerWidth = this._container.offsetWidth;\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n\t\t    animated = this._animated,\r\n\t\t    offset = L.point(this.options.offset);\r\n\r\n\t\tif (animated) {\r\n\t\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t\t}\r\n\r\n\t\tthis._containerBottom = -offset.y - (animated ? 0 : pos.y);\r\n\t\tthis._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);\r\n\r\n\t\t// bottom position the popup in case the height of the popup changes (images loading etc)\r\n\t\tthis._container.style.bottom = this._containerBottom + 'px';\r\n\t\tthis._container.style.left = this._containerLeft + 'px';\r\n\t},\r\n\r\n\t_zoomAnimation: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);\r\n\r\n\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t},\r\n\r\n\t_adjustPan: function () {\r\n\t\tif (!this.options.autoPan) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerHeight = this._container.offsetHeight,\r\n\t\t    containerWidth = this._containerWidth,\r\n\r\n\t\t    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tlayerPos._add(L.DomUtil.getPosition(this._container));\r\n\t\t}\r\n\r\n\t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n\t\t    padding = L.point(this.options.autoPanPadding),\r\n\t\t    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\r\n\t\t    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\r\n\t\t    size = map.getSize(),\r\n\t\t    dx = 0,\r\n\t\t    dy = 0;\r\n\r\n\t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n\t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n\t\t}\r\n\t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n\t\t\tdx = containerPos.x - paddingTL.x;\r\n\t\t}\r\n\t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n\t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n\t\t}\r\n\t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n\t\t\tdy = containerPos.y - paddingTL.y;\r\n\t\t}\r\n\r\n\t\tif (dx || dy) {\r\n\t\t\tmap\r\n\t\t\t    .fire('autopanstart')\r\n\t\t\t    .panBy([dx, dy]);\r\n\t\t}\r\n\t},\r\n\r\n\t_onCloseButtonClick: function (e) {\r\n\t\tthis._close();\r\n\t\tL.DomEvent.stop(e);\r\n\t}\r\n});\r\n\r\nL.popup = function (options, source) {\r\n\treturn new L.Popup(options, source);\r\n};\r\n\r\n\r\nL.Map.include({\r\n\topenPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])\r\n\t\tthis.closePopup();\r\n\r\n\t\tif (!(popup instanceof L.Popup)) {\r\n\t\t\tvar content = popup;\r\n\r\n\t\t\tpopup = new L.Popup(options)\r\n\t\t\t    .setLatLng(latlng)\r\n\t\t\t    .setContent(content);\r\n\t\t}\r\n\t\tpopup._isOpen = true;\r\n\r\n\t\tthis._popup = popup;\r\n\t\treturn this.addLayer(popup);\r\n\t},\r\n\r\n\tclosePopup: function (popup) {\r\n\t\tif (!popup || popup === this._popup) {\r\n\t\t\tpopup = this._popup;\r\n\t\t\tthis._popup = null;\r\n\t\t}\r\n\t\tif (popup) {\r\n\t\t\tthis.removeLayer(popup);\r\n\t\t\tpopup._isOpen = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Marker, adding popup-related methods.\r\n */\r\n\r\nL.Marker.include({\r\n\topenPopup: function () {\r\n\t\tif (this._popup && this._map && !this._map.hasLayer(this._popup)) {\r\n\t\t\tthis._popup.setLatLng(this._latlng);\r\n\t\t\tthis._map.openPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttogglePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tif (this._popup._isOpen) {\r\n\t\t\t\tthis.closePopup();\r\n\t\t\t} else {\r\n\t\t\t\tthis.openPopup();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tvar anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);\r\n\r\n\t\tanchor = anchor.add(L.Popup.prototype.options.offset);\r\n\r\n\t\tif (options && options.offset) {\r\n\t\t\tanchor = anchor.add(options.offset);\r\n\t\t}\r\n\r\n\t\toptions = L.extend({offset: anchor}, options);\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this.togglePopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this)\r\n\t\t\t    .on('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tL.setOptions(content, options);\r\n\t\t\tthis._popup = content;\r\n\t\t\tcontent._source = this;\r\n\t\t} else {\r\n\t\t\tthis._popup = new L.Popup(options, this)\r\n\t\t\t\t.setContent(content);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetPopupContent: function (content) {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this.togglePopup, this)\r\n\t\t\t    .off('remove', this.closePopup, this)\r\n\t\t\t    .off('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPopup: function () {\r\n\t\treturn this._popup;\r\n\t},\r\n\r\n\t_movePopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LayerGroup is a class to combine several layers into one so that\r\n * you can manipulate the group (e.g. add/remove it) as one layer.\r\n */\r\n\r\nL.LayerGroup = L.Class.extend({\r\n\tinitialize: function (layers) {\r\n\t\tthis._layers = {};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (layers) {\r\n\t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\t\t\t\tthis.addLayer(layers[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tvar id = this.getLayerId(layer);\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.addLayer(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n\t\tif (this._map && this._layers[id]) {\r\n\t\t\tthis._map.removeLayer(this._layers[id]);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (layer in this._layers || this.getLayerId(layer) in this._layers);\r\n\t},\r\n\r\n\tclearLayers: function () {\r\n\t\tthis.eachLayer(this.removeLayer, this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvoke: function (methodName) {\r\n\t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, layer;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tlayer = this._layers[i];\r\n\r\n\t\t\tif (layer[methodName]) {\r\n\t\t\t\tlayer[methodName].apply(layer, args);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis.eachLayer(map.addLayer, map);\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis.eachLayer(map.removeLayer, map);\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetLayer: function (id) {\r\n\t\treturn this._layers[id];\r\n\t},\r\n\r\n\tgetLayers: function () {\r\n\t\tvar layers = [];\r\n\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tlayers.push(this._layers[i]);\r\n\t\t}\r\n\t\treturn layers;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\treturn this.invoke('setZIndex', zIndex);\r\n\t},\r\n\r\n\tgetLayerId: function (layer) {\r\n\t\treturn L.stamp(layer);\r\n\t}\r\n});\r\n\r\nL.layerGroup = function (layers) {\r\n\treturn new L.LayerGroup(layers);\r\n};\r\n\n\n/*\r\n * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\r\n * shared between a group of interactive layers (like vectors or markers).\r\n */\r\n\r\nL.FeatureGroup = L.LayerGroup.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tEVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tif (this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif ('on' in layer) {\r\n\t\t\tlayer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent && layer.bindPopup) {\r\n\t\t\tlayer.bindPopup(this._popupContent, this._popupOptions);\r\n\t\t}\r\n\r\n\t\treturn this.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tif (!this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif (layer in this._layers) {\r\n\t\t\tlayer = this._layers[layer];\r\n\t\t}\r\n\r\n\t\tif ('off' in layer) {\r\n\t\t\tlayer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent) {\r\n\t\t\tthis.invoke('unbindPopup');\r\n\t\t}\r\n\r\n\t\treturn this.fire('layerremove', {layer: layer});\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tthis._popupContent = content;\r\n\t\tthis._popupOptions = options;\r\n\t\treturn this.invoke('bindPopup', content, options);\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\t\t// open popup on the first layer\r\n\t\tfor (var id in this._layers) {\r\n\t\t\tthis._layers[id].openPopup(latlng);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\treturn this.invoke('setStyle', style);\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\treturn this.invoke('bringToFront');\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\treturn this.invoke('bringToBack');\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = new L.LatLngBounds();\r\n\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tbounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());\r\n\t\t});\r\n\r\n\t\treturn bounds;\r\n\t},\r\n\r\n\t_propagateEvent: function (e) {\r\n\t\te = L.extend({\r\n\t\t\tlayer: e.target,\r\n\t\t\ttarget: this\r\n\t\t}, e);\r\n\t\tthis.fire(e.type, e);\r\n\t}\r\n});\r\n\r\nL.featureGroup = function (layers) {\r\n\treturn new L.FeatureGroup(layers);\r\n};\r\n\n\n/*\r\n * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.\r\n */\r\n\r\nL.Path = L.Class.extend({\r\n\tincludes: [L.Mixin.Events],\r\n\r\n\tstatics: {\r\n\t\t// how much to extend the clip area around the map view\r\n\t\t// (relative to its size, e.g. 0.5 is half the screen in each direction)\r\n\t\t// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)\r\n\t\tCLIP_PADDING: (function () {\r\n\t\t\tvar max = L.Browser.mobile ? 1280 : 2000,\r\n\t\t\t    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;\r\n\t\t\treturn Math.max(0, Math.min(0.5, target));\r\n\t\t})()\r\n\t},\r\n\r\n\toptions: {\r\n\t\tstroke: true,\r\n\t\tcolor: '#0033ff',\r\n\t\tdashArray: null,\r\n\t\tlineCap: null,\r\n\t\tlineJoin: null,\r\n\t\tweight: 5,\r\n\t\topacity: 0.5,\r\n\r\n\t\tfill: false,\r\n\t\tfillColor: null, //same as color by default\r\n\t\tfillOpacity: 0.2,\r\n\r\n\t\tclickable: true\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initElements();\r\n\t\t\tthis._initEvents();\r\n\t\t}\r\n\r\n\t\tthis.projectLatlngs();\r\n\t\tthis._updatePath();\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._map._pathRoot.appendChild(this._container);\r\n\t\t}\r\n\r\n\t\tthis.fire('add');\r\n\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._pathRoot.removeChild(this._container);\r\n\r\n\t\t// Need to fire remove event before we set _map to null as the event hooks might need the object\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\r\n\t\tif (L.Browser.vml) {\r\n\t\t\tthis._container = null;\r\n\t\t\tthis._stroke = null;\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\t// do all projection stuff here\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._updateStyle();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._updatePath();\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_updatePathViewport: function () {\r\n\t\tvar p = L.Path.CLIP_PADDING,\r\n\t\t    size = this.getSize(),\r\n\t\t    panePos = L.DomUtil.getPosition(this._mapPane),\r\n\t\t    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),\r\n\t\t    max = min.add(size.multiplyBy(1 + p * 2)._round());\r\n\r\n\t\tthis._pathViewport = new L.Bounds(min, max);\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Path with SVG-specific rendering code.\r\n */\r\n\r\nL.Path.SVG_NS = 'http://www.w3.org/2000/svg';\r\n\r\nL.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);\r\n\r\nL.Path = L.Path.extend({\r\n\tstatics: {\r\n\t\tSVG: L.Browser.svg\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container;\r\n\r\n\t\tif (path && root.lastChild !== path) {\r\n\t\t\troot.appendChild(path);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container,\r\n\t\t    first = root.firstChild;\r\n\r\n\t\tif (path && first !== path) {\r\n\t\t\troot.insertBefore(path, first);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\t// form path string here\r\n\t},\r\n\r\n\t_createElement: function (name) {\r\n\t\treturn document.createElementNS(L.Path.SVG_NS, name);\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._initPath();\r\n\t\tthis._initStyle();\r\n\t},\r\n\r\n\t_initPath: function () {\r\n\t\tthis._container = this._createElement('g');\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\r\n\t\tif (this.options.className) {\r\n\t\t\tL.DomUtil.addClass(this._path, this.options.className);\r\n\t\t}\r\n\r\n\t\tthis._container.appendChild(this._path);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke-linejoin', 'round');\r\n\t\t\tthis._path.setAttribute('stroke-linecap', 'round');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill-rule', 'evenodd');\r\n\t\t}\r\n\t\tif (this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', this.options.pointerEvents);\r\n\t\t}\r\n\t\tif (!this.options.clickable && !this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', 'none');\r\n\t\t}\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke', this.options.color);\r\n\t\t\tthis._path.setAttribute('stroke-opacity', this.options.opacity);\r\n\t\t\tthis._path.setAttribute('stroke-width', this.options.weight);\r\n\t\t\tif (this.options.dashArray) {\r\n\t\t\t\tthis._path.setAttribute('stroke-dasharray', this.options.dashArray);\r\n\t\t\t} else {\r\n\t\t\t\tthis._path.removeAttribute('stroke-dasharray');\r\n\t\t\t}\r\n\t\t\tif (this.options.lineCap) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linecap', this.options.lineCap);\r\n\t\t\t}\r\n\t\t\tif (this.options.lineJoin) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linejoin', this.options.lineJoin);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('stroke', 'none');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill', this.options.fillColor || this.options.color);\r\n\t\t\tthis._path.setAttribute('fill-opacity', this.options.fillOpacity);\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('fill', 'none');\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar str = this.getPathString();\r\n\t\tif (!str) {\r\n\t\t\t// fix webkit empty string parsing bug\r\n\t\t\tstr = 'M0 0';\r\n\t\t}\r\n\t\tthis._path.setAttribute('d', str);\r\n\t},\r\n\r\n\t// TODO remove duplication with L.Map\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tif (L.Browser.svg || !L.Browser.vml) {\r\n\t\t\t\tL.DomUtil.addClass(this._path, 'leaflet-clickable');\r\n\t\t\t}\r\n\r\n\t\t\tL.DomEvent.on(this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\t\tvar events = ['dblclick', 'mousedown', 'mouseover',\r\n\t\t\t              'mouseout', 'mousemove', 'contextmenu'];\r\n\t\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\t\tL.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._map || !this.hasEventListeners(e.type)) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerPoint = map.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = map.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = map.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\r\n\t\tif (e.type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousemove') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_initPathRoot: function () {\r\n\t\tif (!this._pathRoot) {\r\n\t\t\tthis._pathRoot = L.Path.prototype._createElement('svg');\r\n\t\t\tthis._panes.overlayPane.appendChild(this._pathRoot);\r\n\r\n\t\t\tif (this.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');\r\n\r\n\t\t\t\tthis.on({\r\n\t\t\t\t\t'zoomanim': this._animatePathZoom,\r\n\t\t\t\t\t'zoomend': this._endPathZoom\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');\r\n\t\t\t}\r\n\r\n\t\t\tthis.on('moveend', this._updateSvgViewport);\r\n\t\t\tthis._updateSvgViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_animatePathZoom: function (e) {\r\n\t\tvar scale = this.getZoomScale(e.zoom),\r\n\t\t    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);\r\n\r\n\t\tthis._pathRoot.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';\r\n\r\n\t\tthis._pathZooming = true;\r\n\t},\r\n\r\n\t_endPathZoom: function () {\r\n\t\tthis._pathZooming = false;\r\n\t},\r\n\r\n\t_updateSvgViewport: function () {\r\n\r\n\t\tif (this._pathZooming) {\r\n\t\t\t// Do not update SVGs while a zoom animation is going on otherwise the animation will break.\r\n\t\t\t// When the zoom animation ends we will be updated again anyway\r\n\t\t\t// This fixes the case where you do a momentum move and zoom while the move is still ongoing.\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    max = vp.max,\r\n\t\t    width = max.x - min.x,\r\n\t\t    height = max.y - min.y,\r\n\t\t    root = this._pathRoot,\r\n\t\t    pane = this._panes.overlayPane;\r\n\r\n\t\t// Hack to make flicker on drag end on mobile webkit less irritating\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.removeChild(root);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.setAttribute('width', width);\r\n\t\troot.setAttribute('height', height);\r\n\t\troot.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));\r\n\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.appendChild(root);\r\n\t\t}\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.\r\n */\r\n\r\nL.Path.include({\r\n\r\n\tbindPopup: function (content, options) {\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tthis._popup = content;\r\n\t\t} else {\r\n\t\t\tif (!this._popup || options) {\r\n\t\t\t\tthis._popup = new L.Popup(options, this);\r\n\t\t\t}\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this._openPopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this);\r\n\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this._openPopup)\r\n\t\t\t    .off('remove', this.closePopup);\r\n\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\r\n\t\tif (this._popup) {\r\n\t\t\t// open the popup from one of the path's points if not specified\r\n\t\t\tlatlng = latlng || this._latlng ||\r\n\t\t\t         this._latlngs[Math.floor(this._latlngs.length / 2)];\r\n\r\n\t\t\tthis._openPopup({latlng: latlng});\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_openPopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t\tthis._map.openPopup(this._popup);\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for IE6-8 through VML.\r\n * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\r\n */\r\n\r\nL.Browser.vml = !L.Browser.svg && (function () {\r\n\ttry {\r\n\t\tvar div = document.createElement('div');\r\n\t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\r\n\r\n\t\tvar shape = div.firstChild;\r\n\t\tshape.style.behavior = 'url(#default#VML)';\r\n\r\n\t\treturn shape && (typeof shape.adj === 'object');\r\n\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t}\r\n}());\r\n\r\nL.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\tVML: true,\r\n\t\tCLIP_PADDING: 0.02\r\n\t},\r\n\r\n\t_createElement: (function () {\r\n\t\ttry {\r\n\t\t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\r\n\t\t\t};\r\n\t\t} catch (e) {\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement(\r\n\t\t\t\t        '<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\r\n\t\t\t};\r\n\t\t}\r\n\t}()),\r\n\r\n\t_initPath: function () {\r\n\t\tvar container = this._container = this._createElement('shape');\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-vml-shape' +\r\n\t\t\t(this.options.className ? ' ' + this.options.className : ''));\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tL.DomUtil.addClass(container, 'leaflet-clickable');\r\n\t\t}\r\n\r\n\t\tcontainer.coordsize = '1 1';\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\t\tcontainer.appendChild(this._path);\r\n\r\n\t\tthis._map._pathRoot.appendChild(container);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar stroke = this._stroke,\r\n\t\t    fill = this._fill,\r\n\t\t    options = this.options,\r\n\t\t    container = this._container;\r\n\r\n\t\tcontainer.stroked = options.stroke;\r\n\t\tcontainer.filled = options.fill;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tif (!stroke) {\r\n\t\t\t\tstroke = this._stroke = this._createElement('stroke');\r\n\t\t\t\tstroke.endcap = 'round';\r\n\t\t\t\tcontainer.appendChild(stroke);\r\n\t\t\t}\r\n\t\t\tstroke.weight = options.weight + 'px';\r\n\t\t\tstroke.color = options.color;\r\n\t\t\tstroke.opacity = options.opacity;\r\n\r\n\t\t\tif (options.dashArray) {\r\n\t\t\t\tstroke.dashStyle = L.Util.isArray(options.dashArray) ?\r\n\t\t\t\t    options.dashArray.join(' ') :\r\n\t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\r\n\t\t\t} else {\r\n\t\t\t\tstroke.dashStyle = '';\r\n\t\t\t}\r\n\t\t\tif (options.lineCap) {\r\n\t\t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\r\n\t\t\t}\r\n\t\t\tif (options.lineJoin) {\r\n\t\t\t\tstroke.joinstyle = options.lineJoin;\r\n\t\t\t}\r\n\r\n\t\t} else if (stroke) {\r\n\t\t\tcontainer.removeChild(stroke);\r\n\t\t\tthis._stroke = null;\r\n\t\t}\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tif (!fill) {\r\n\t\t\t\tfill = this._fill = this._createElement('fill');\r\n\t\t\t\tcontainer.appendChild(fill);\r\n\t\t\t}\r\n\t\t\tfill.color = options.fillColor || options.color;\r\n\t\t\tfill.opacity = options.fillOpacity;\r\n\r\n\t\t} else if (fill) {\r\n\t\t\tcontainer.removeChild(fill);\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar style = this._container.style;\r\n\r\n\t\tstyle.display = 'none';\r\n\t\tthis._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug\r\n\t\tstyle.display = '';\r\n\t}\r\n});\r\n\r\nL.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tif (this._pathRoot) { return; }\r\n\r\n\t\tvar root = this._pathRoot = document.createElement('div');\r\n\t\troot.className = 'leaflet-vml-container';\r\n\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\tthis.on('moveend', this._updatePathViewport);\r\n\t\tthis._updatePathViewport();\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for all browsers that support canvas.\r\n */\r\n\r\nL.Browser.canvas = (function () {\r\n\treturn !!document.createElement('canvas').getContext;\r\n}());\r\n\r\nL.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\t//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value\r\n\t\tCANVAS: true,\r\n\t\tSVG: false\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateStyle();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('viewreset', this.projectLatlngs, this)\r\n\t\t    .off('moveend', this._updatePath, this);\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.off('click', this._onClick, this);\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\r\n\t\tthis._requestUpdate();\r\n\t\t\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\t_requestUpdate: function () {\r\n\t\tif (this._map && !L.Path._updateRequest) {\r\n\t\t\tL.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMapMoveEnd: function () {\r\n\t\tL.Path._updateRequest = null;\r\n\t\tthis.fire('moveend');\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._ctx = this._map._canvasCtx;\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tthis._ctx.lineWidth = options.weight;\r\n\t\t\tthis._ctx.strokeStyle = options.color;\r\n\t\t}\r\n\t\tif (options.fill) {\r\n\t\t\tthis._ctx.fillStyle = options.fillColor || options.color;\r\n\t\t}\r\n\r\n\t\tif (options.lineCap) {\r\n\t\t\tthis._ctx.lineCap = options.lineCap;\r\n\t\t}\r\n\t\tif (options.lineJoin) {\r\n\t\t\tthis._ctx.lineJoin = options.lineJoin;\r\n\t\t}\r\n\t},\r\n\r\n\t_drawPath: function () {\r\n\t\tvar i, j, len, len2, point, drawMethod;\r\n\r\n\t\tthis._ctx.beginPath();\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tfor (j = 0, len2 = this._parts[i].length; j < len2; j++) {\r\n\t\t\t\tpoint = this._parts[i][j];\r\n\t\t\t\tdrawMethod = (j === 0 ? 'move' : 'line') + 'To';\r\n\r\n\t\t\t\tthis._ctx[drawMethod](point.x, point.y);\r\n\t\t\t}\r\n\t\t\t// TODO refactor ugly hack\r\n\t\t\tif (this instanceof L.Polygon) {\r\n\t\t\t\tthis._ctx.closePath();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\treturn !this._parts.length;\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (this._checkIfEmpty()) { return; }\r\n\r\n\t\tvar ctx = this._ctx,\r\n\t\t    options = this.options;\r\n\r\n\t\tthis._drawPath();\r\n\t\tctx.save();\r\n\t\tthis._updateStyle();\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tctx.globalAlpha = options.fillOpacity;\r\n\t\t\tctx.fill(options.fillRule || 'evenodd');\r\n\t\t}\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tctx.globalAlpha = options.opacity;\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\r\n\t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t\tthis._map.on('click dblclick contextmenu', this._fireMouseEvent, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis.fire(e.type, e);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tif (!this._map || this._map._animatingZoom) { return; }\r\n\r\n\t\t// TODO don't do on each move\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis._ctx.canvas.style.cursor = 'pointer';\r\n\t\t\tthis._mouseInside = true;\r\n\t\t\tthis.fire('mouseover', e);\r\n\r\n\t\t} else if (this._mouseInside) {\r\n\t\t\tthis._ctx.canvas.style.cursor = '';\r\n\t\t\tthis._mouseInside = false;\r\n\t\t\tthis.fire('mouseout', e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tvar root = this._pathRoot,\r\n\t\t    ctx;\r\n\r\n\t\tif (!root) {\r\n\t\t\troot = this._pathRoot = document.createElement('canvas');\r\n\t\t\troot.style.position = 'absolute';\r\n\t\t\tctx = this._canvasCtx = root.getContext('2d');\r\n\r\n\t\t\tctx.lineCap = 'round';\r\n\t\t\tctx.lineJoin = 'round';\r\n\r\n\t\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\t\tif (this.options.zoomAnimation) {\r\n\t\t\t\tthis._pathRoot.className = 'leaflet-zoom-animated';\r\n\t\t\t\tthis.on('zoomanim', this._animatePathZoom);\r\n\t\t\t\tthis.on('zoomend', this._endPathZoom);\r\n\t\t\t}\r\n\t\t\tthis.on('moveend', this._updateCanvasViewport);\r\n\t\t\tthis._updateCanvasViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_updateCanvasViewport: function () {\r\n\t\t// don't redraw while zooming. See _updateSvgViewport for more details\r\n\t\tif (this._pathZooming) { return; }\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    size = vp.max.subtract(min),\r\n\t\t    root = this._pathRoot;\r\n\r\n\t\t//TODO check if this works properly on mobile webkit\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.width = size.x;\r\n\t\troot.height = size.y;\r\n\t\troot.getContext('2d').translate(-min.x, -min.y);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LineUtil contains different utility functions for line segments\r\n * and polylines (clipping, simplification, distances, etc.)\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations for this file\r\n\r\nL.LineUtil = {\r\n\r\n\t// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n\t// Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n\tsimplify: function (/*Point[]*/ points, /*Number*/ tolerance) {\r\n\t\tif (!tolerance || !points.length) {\r\n\t\t\treturn points.slice();\r\n\t\t}\r\n\r\n\t\tvar sqTolerance = tolerance * tolerance;\r\n\r\n\t\t// stage 1: vertex reduction\r\n\t\tpoints = this._reducePoints(points, sqTolerance);\r\n\r\n\t\t// stage 2: Douglas-Peucker simplification\r\n\t\tpoints = this._simplifyDP(points, sqTolerance);\r\n\r\n\t\treturn points;\r\n\t},\r\n\r\n\t// distance from a point to a segment between two points\r\n\tpointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\r\n\t},\r\n\r\n\tclosestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn this._sqClosestPointOnSegment(p, p1, p2);\r\n\t},\r\n\r\n\t// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\n\t_simplifyDP: function (points, sqTolerance) {\r\n\r\n\t\tvar len = points.length,\r\n\t\t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n\t\t    markers = new ArrayConstructor(len);\r\n\r\n\t\tmarkers[0] = markers[len - 1] = 1;\r\n\r\n\t\tthis._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n\t\tvar i,\r\n\t\t    newPoints = [];\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (markers[i]) {\r\n\t\t\t\tnewPoints.push(points[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newPoints;\r\n\t},\r\n\r\n\t_simplifyDPStep: function (points, markers, sqTolerance, first, last) {\r\n\r\n\t\tvar maxSqDist = 0,\r\n\t\t    index, i, sqDist;\r\n\r\n\t\tfor (i = first + 1; i <= last - 1; i++) {\r\n\t\t\tsqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n\t\t\tif (sqDist > maxSqDist) {\r\n\t\t\t\tindex = i;\r\n\t\t\t\tmaxSqDist = sqDist;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (maxSqDist > sqTolerance) {\r\n\t\t\tmarkers[index] = 1;\r\n\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, first, index);\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, index, last);\r\n\t\t}\r\n\t},\r\n\r\n\t// reduce points that are too close to each other to a single point\r\n\t_reducePoints: function (points, sqTolerance) {\r\n\t\tvar reducedPoints = [points[0]];\r\n\r\n\t\tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n\t\t\tif (this._sqDist(points[i], points[prev]) > sqTolerance) {\r\n\t\t\t\treducedPoints.push(points[i]);\r\n\t\t\t\tprev = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (prev < len - 1) {\r\n\t\t\treducedPoints.push(points[len - 1]);\r\n\t\t}\r\n\t\treturn reducedPoints;\r\n\t},\r\n\r\n\t// Cohen-Sutherland line clipping algorithm.\r\n\t// Used to avoid rendering parts of a polyline that are not currently visible.\r\n\r\n\tclipSegment: function (a, b, bounds, useLastCode) {\r\n\t\tvar codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\r\n\t\t    codeB = this._getBitCode(b, bounds),\r\n\r\n\t\t    codeOut, p, newCode;\r\n\r\n\t\t// save 2nd code to avoid calculating it on the next segment\r\n\t\tthis._lastCode = codeB;\r\n\r\n\t\twhile (true) {\r\n\t\t\t// if a,b is inside the clip window (trivial accept)\r\n\t\t\tif (!(codeA | codeB)) {\r\n\t\t\t\treturn [a, b];\r\n\t\t\t// if a,b is outside the clip window (trivial reject)\r\n\t\t\t} else if (codeA & codeB) {\r\n\t\t\t\treturn false;\r\n\t\t\t// other cases\r\n\t\t\t} else {\r\n\t\t\t\tcodeOut = codeA || codeB;\r\n\t\t\t\tp = this._getEdgeIntersection(a, b, codeOut, bounds);\r\n\t\t\t\tnewCode = this._getBitCode(p, bounds);\r\n\r\n\t\t\t\tif (codeOut === codeA) {\r\n\t\t\t\t\ta = p;\r\n\t\t\t\t\tcodeA = newCode;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tb = p;\r\n\t\t\t\t\tcodeB = newCode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getEdgeIntersection: function (a, b, code, bounds) {\r\n\t\tvar dx = b.x - a.x,\r\n\t\t    dy = b.y - a.y,\r\n\t\t    min = bounds.min,\r\n\t\t    max = bounds.max;\r\n\r\n\t\tif (code & 8) { // top\r\n\t\t\treturn new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);\r\n\t\t} else if (code & 4) { // bottom\r\n\t\t\treturn new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);\r\n\t\t} else if (code & 2) { // right\r\n\t\t\treturn new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);\r\n\t\t} else if (code & 1) { // left\r\n\t\t\treturn new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);\r\n\t\t}\r\n\t},\r\n\r\n\t_getBitCode: function (/*Point*/ p, bounds) {\r\n\t\tvar code = 0;\r\n\r\n\t\tif (p.x < bounds.min.x) { // left\r\n\t\t\tcode |= 1;\r\n\t\t} else if (p.x > bounds.max.x) { // right\r\n\t\t\tcode |= 2;\r\n\t\t}\r\n\t\tif (p.y < bounds.min.y) { // bottom\r\n\t\t\tcode |= 4;\r\n\t\t} else if (p.y > bounds.max.y) { // top\r\n\t\t\tcode |= 8;\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\t},\r\n\r\n\t// square distance (to avoid unnecessary Math.sqrt calls)\r\n\t_sqDist: function (p1, p2) {\r\n\t\tvar dx = p2.x - p1.x,\r\n\t\t    dy = p2.y - p1.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\t},\r\n\r\n\t// return closest point on segment or distance to that point\r\n\t_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\r\n\t\tvar x = p1.x,\r\n\t\t    y = p1.y,\r\n\t\t    dx = p2.x - x,\r\n\t\t    dy = p2.y - y,\r\n\t\t    dot = dx * dx + dy * dy,\r\n\t\t    t;\r\n\r\n\t\tif (dot > 0) {\r\n\t\t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n\t\t\tif (t > 1) {\r\n\t\t\t\tx = p2.x;\r\n\t\t\t\ty = p2.y;\r\n\t\t\t} else if (t > 0) {\r\n\t\t\t\tx += dx * t;\r\n\t\t\t\ty += dy * t;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdx = p.x - x;\r\n\t\tdy = p.y - y;\r\n\r\n\t\treturn sqDist ? dx * dx + dy * dy : new L.Point(x, y);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.Polyline is used to display polylines on a map.\r\n */\r\n\r\nL.Polyline = L.Path.extend({\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t},\r\n\r\n\toptions: {\r\n\t\t// how much to simplify the polyline on each zoom level\r\n\t\t// more = better performance and smoother look, less = more accurate\r\n\t\tsmoothFactor: 1.0,\r\n\t\tnoClip: false\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._originalPoints = [];\r\n\r\n\t\tfor (var i = 0, len = this._latlngs.length; i < len; i++) {\r\n\t\t\tthis._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);\r\n\t\t}\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tfor (var i = 0, len = this._parts.length, str = ''; i < len; i++) {\r\n\t\t\tstr += this._getPathPartStr(this._parts[i]);\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\tgetLatLngs: function () {\r\n\t\treturn this._latlngs;\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\taddLatLng: function (latlng) {\r\n\t\tthis._latlngs.push(L.latLng(latlng));\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tspliceLatLngs: function () { // (Number index, Number howMany)\r\n\t\tvar removed = [].splice.apply(this._latlngs, arguments);\r\n\t\tthis._convertLatLngs(this._latlngs, true);\r\n\t\tthis.redraw();\r\n\t\treturn removed;\r\n\t},\r\n\r\n\tclosestLayerPoint: function (p) {\r\n\t\tvar minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;\r\n\r\n\t\tfor (var j = 0, jLen = parts.length; j < jLen; j++) {\r\n\t\t\tvar points = parts[j];\r\n\t\t\tfor (var i = 1, len = points.length; i < len; i++) {\r\n\t\t\t\tp1 = points[i - 1];\r\n\t\t\t\tp2 = points[i];\r\n\t\t\t\tvar sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);\r\n\t\t\t\tif (sqDist < minDistance) {\r\n\t\t\t\t\tminDistance = sqDist;\r\n\t\t\t\t\tminPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (minPoint) {\r\n\t\t\tminPoint.distance = Math.sqrt(minDistance);\r\n\t\t}\r\n\t\treturn minPoint;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\treturn new L.LatLngBounds(this.getLatLngs());\r\n\t},\r\n\r\n\t_convertLatLngs: function (latlngs, overwrite) {\r\n\t\tvar i, len, target = overwrite ? latlngs : [];\r\n\r\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\r\n\t\t\tif (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttarget[i] = L.latLng(latlngs[i]);\r\n\t\t}\r\n\t\treturn target;\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tL.Path.prototype._initEvents.call(this);\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar round = L.Path.VML;\r\n\r\n\t\tfor (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {\r\n\t\t\tp = points[j];\r\n\t\t\tif (round) {\r\n\t\t\t\tp._round();\r\n\t\t\t}\r\n\t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    len = points.length,\r\n\t\t    i, k, segment;\r\n\r\n\t\tif (this.options.noClip) {\r\n\t\t\tthis._parts = [points];\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._parts = [];\r\n\r\n\t\tvar parts = this._parts,\r\n\t\t    vp = this._map._pathViewport,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (i = 0, k = 0; i < len - 1; i++) {\r\n\t\t\tsegment = lu.clipSegment(points[i], points[i + 1], vp, i);\r\n\t\t\tif (!segment) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tparts[k] = parts[k] || [];\r\n\t\t\tparts[k].push(segment[0]);\r\n\r\n\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\r\n\t\t\tif ((segment[1] !== points[i + 1]) || (i === len - 2)) {\r\n\t\t\t\tparts[k].push(segment[1]);\r\n\t\t\t\tk++;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// simplify each clipped part of the polyline\r\n\t_simplifyPoints: function () {\r\n\t\tvar parts = this._parts,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (var i = 0, len = parts.length; i < len; i++) {\r\n\t\t\tparts[i] = lu.simplify(parts[i], this.options.smoothFactor);\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._clipPoints();\r\n\t\tthis._simplifyPoints();\r\n\r\n\t\tL.Path.prototype._updatePath.call(this);\r\n\t}\r\n});\r\n\r\nL.polyline = function (latlngs, options) {\r\n\treturn new L.Polyline(latlngs, options);\r\n};\r\n\n\n/*\r\n * L.PolyUtil contains utility functions for polygons (clipping, etc.).\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations here\r\n\r\nL.PolyUtil = {};\r\n\r\n/*\r\n * Sutherland-Hodgeman polygon clipping algorithm.\r\n * Used to avoid rendering parts of a polygon that are not currently visible.\r\n */\r\nL.PolyUtil.clipPolygon = function (points, bounds) {\r\n\tvar clippedPoints,\r\n\t    edges = [1, 4, 2, 8],\r\n\t    i, j, k,\r\n\t    a, b,\r\n\t    len, edge, p,\r\n\t    lu = L.LineUtil;\r\n\r\n\tfor (i = 0, len = points.length; i < len; i++) {\r\n\t\tpoints[i]._code = lu._getBitCode(points[i], bounds);\r\n\t}\r\n\r\n\t// for each edge (left, bottom, right, top)\r\n\tfor (k = 0; k < 4; k++) {\r\n\t\tedge = edges[k];\r\n\t\tclippedPoints = [];\r\n\r\n\t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n\t\t\ta = points[i];\r\n\t\t\tb = points[j];\r\n\r\n\t\t\t// if a is inside the clip window\r\n\t\t\tif (!(a._code & edge)) {\r\n\t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n\t\t\t\tif (b._code & edge) {\r\n\t\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\t\tclippedPoints.push(p);\r\n\t\t\t\t}\r\n\t\t\t\tclippedPoints.push(a);\r\n\r\n\t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n\t\t\t} else if (!(b._code & edge)) {\r\n\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\tclippedPoints.push(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpoints = clippedPoints;\r\n\t}\r\n\r\n\treturn points;\r\n};\r\n\n\n/*\r\n * L.Polygon is used to display polygons on a map.\r\n */\r\n\r\nL.Polygon = L.Polyline.extend({\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Polyline.prototype.initialize.call(this, latlngs, options);\r\n\t\tthis._initWithHoles(latlngs);\r\n\t},\r\n\r\n\t_initWithHoles: function (latlngs) {\r\n\t\tvar i, len, hole;\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._latlngs = this._convertLatLngs(latlngs[0]);\r\n\t\t\tthis._holes = latlngs.slice(1);\r\n\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = this._holes[i] = this._convertLatLngs(this._holes[i]);\r\n\t\t\t\tif (hole[0].equals(hole[hole.length - 1])) {\r\n\t\t\t\t\thole.pop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// filter out last point if its equal to the first one\r\n\t\tlatlngs = this._latlngs;\r\n\r\n\t\tif (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {\r\n\t\t\tlatlngs.pop();\r\n\t\t}\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tL.Polyline.prototype.projectLatlngs.call(this);\r\n\r\n\t\t// project polygon holes points\r\n\t\t// TODO move this logic to Polyline to get rid of duplication\r\n\t\tthis._holePoints = [];\r\n\r\n\t\tif (!this._holes) { return; }\r\n\r\n\t\tvar i, j, len, len2;\r\n\r\n\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\tthis._holePoints[i] = [];\r\n\r\n\t\t\tfor (j = 0, len2 = this._holes[i].length; j < len2; j++) {\r\n\t\t\t\tthis._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._initWithHoles(latlngs);\r\n\t\t\treturn this.redraw();\r\n\t\t} else {\r\n\t\t\treturn L.Polyline.prototype.setLatLngs.call(this, latlngs);\r\n\t\t}\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    newParts = [];\r\n\r\n\t\tthis._parts = [points].concat(this._holePoints);\r\n\r\n\t\tif (this.options.noClip) { return; }\r\n\r\n\t\tfor (var i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tvar clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);\r\n\t\t\tif (clipped.length) {\r\n\t\t\t\tnewParts.push(clipped);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._parts = newParts;\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar str = L.Polyline.prototype._getPathPartStr.call(this, points);\r\n\t\treturn str + (L.Browser.svg ? 'z' : 'x');\r\n\t}\r\n});\r\n\r\nL.polygon = function (latlngs, options) {\r\n\treturn new L.Polygon(latlngs, options);\r\n};\r\n\n\n/*\r\n * Contains L.MultiPolyline and L.MultiPolygon layers.\r\n */\r\n\r\n(function () {\r\n\tfunction createMulti(Klass) {\r\n\r\n\t\treturn L.FeatureGroup.extend({\r\n\r\n\t\t\tinitialize: function (latlngs, options) {\r\n\t\t\t\tthis._layers = {};\r\n\t\t\t\tthis._options = options;\r\n\t\t\t\tthis.setLatLngs(latlngs);\r\n\t\t\t},\r\n\r\n\t\t\tsetLatLngs: function (latlngs) {\r\n\t\t\t\tvar i = 0,\r\n\t\t\t\t    len = latlngs.length;\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tif (i < len) {\r\n\t\t\t\t\t\tlayer.setLatLngs(latlngs[i++]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.removeLayer(layer);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\twhile (i < len) {\r\n\t\t\t\t\tthis.addLayer(new Klass(latlngs[i++], this._options));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\tgetLatLngs: function () {\r\n\t\t\t\tvar latlngs = [];\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tlatlngs.push(layer.getLatLngs());\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn latlngs;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tL.MultiPolyline = createMulti(L.Polyline);\r\n\tL.MultiPolygon = createMulti(L.Polygon);\r\n\r\n\tL.multiPolyline = function (latlngs, options) {\r\n\t\treturn new L.MultiPolyline(latlngs, options);\r\n\t};\r\n\r\n\tL.multiPolygon = function (latlngs, options) {\r\n\t\treturn new L.MultiPolygon(latlngs, options);\r\n\t};\r\n}());\r\n\n\n/*\r\n * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\r\n */\r\n\r\nL.Rectangle = L.Polygon.extend({\r\n\tinitialize: function (latLngBounds, options) {\r\n\t\tL.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\r\n\t},\r\n\r\n\tsetBounds: function (latLngBounds) {\r\n\t\tthis.setLatLngs(this._boundsToLatLngs(latLngBounds));\r\n\t},\r\n\r\n\t_boundsToLatLngs: function (latLngBounds) {\r\n\t\tlatLngBounds = L.latLngBounds(latLngBounds);\r\n\t\treturn [\r\n\t\t\tlatLngBounds.getSouthWest(),\r\n\t\t\tlatLngBounds.getNorthWest(),\r\n\t\t\tlatLngBounds.getNorthEast(),\r\n\t\t\tlatLngBounds.getSouthEast()\r\n\t\t];\r\n\t}\r\n});\r\n\r\nL.rectangle = function (latLngBounds, options) {\r\n\treturn new L.Rectangle(latLngBounds, options);\r\n};\r\n\n\n/*\r\n * L.Circle is a circle overlay (with a certain radius in meters).\r\n */\r\n\r\nL.Circle = L.Path.extend({\r\n\tinitialize: function (latlng, radius, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tthis._mRadius = radius;\r\n\t},\r\n\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis._mRadius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latlng = this._latlng,\r\n\t\t    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);\r\n\r\n\t\tthis._point = this._map.latLngToLayerPoint(latlng);\r\n\t\tthis._radius = Math.max(this._point.x - pointLeft.x, 1);\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latRadius = (this._mRadius / 40075017) * 360,\r\n\t\t    latlng = this._latlng;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        [latlng.lat - latRadius, latlng.lng - lngRadius],\r\n\t\t        [latlng.lat + latRadius, latlng.lng + lngRadius]);\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tvar p = this._point,\r\n\t\t    r = this._radius;\r\n\r\n\t\tif (this._checkIfEmpty()) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tif (L.Browser.svg) {\r\n\t\t\treturn 'M' + p.x + ',' + (p.y - r) +\r\n\t\t\t       'A' + r + ',' + r + ',0,1,1,' +\r\n\t\t\t       (p.x - 0.1) + ',' + (p.y - r) + ' z';\r\n\t\t} else {\r\n\t\t\tp._round();\r\n\t\t\tr = Math.round(r);\r\n\t\t\treturn 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);\r\n\t\t}\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._mRadius;\r\n\t},\r\n\r\n\t// TODO Earth hardcoded, move into projection code!\r\n\r\n\t_getLatRadius: function () {\r\n\t\treturn (this._mRadius / 40075017) * 360;\r\n\t},\r\n\r\n\t_getLngRadius: function () {\r\n\t\treturn this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\tif (!this._map) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tvar vp = this._map._pathViewport,\r\n\t\t    r = this._radius,\r\n\t\t    p = this._point;\r\n\r\n\t\treturn p.x - r > vp.max.x || p.y - r > vp.max.y ||\r\n\t\t       p.x + r < vp.min.x || p.y + r < vp.min.y;\r\n\t}\r\n});\r\n\r\nL.circle = function (latlng, radius, options) {\r\n\treturn new L.Circle(latlng, radius, options);\r\n};\r\n\n\n/*\r\n * L.CircleMarker is a circle overlay with a permanent pixel radius.\r\n */\r\n\r\nL.CircleMarker = L.Circle.extend({\r\n\toptions: {\r\n\t\tradius: 10,\r\n\t\tweight: 2\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.Circle.prototype.initialize.call(this, latlng, null, options);\r\n\t\tthis._radius = this.options.radius;\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\r\n\t},\r\n\r\n\t_updateStyle : function () {\r\n\t\tL.Circle.prototype._updateStyle.call(this);\r\n\t\tthis.setRadius(this.options.radius);\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tL.Circle.prototype.setLatLng.call(this, latlng);\r\n\t\tif (this._popup && this._popup._isOpen) {\r\n\t\t\tthis._popup.setLatLng(latlng);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis.options.radius = this._radius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._radius;\r\n\t}\r\n});\r\n\r\nL.circleMarker = function (latlng, options) {\r\n\treturn new L.CircleMarker(latlng, options);\r\n};\r\n\n\n/*\r\n * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.\r\n */\r\n\r\nL.Polyline.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p, closed) {\r\n\t\tvar i, j, k, len, len2, dist, part,\r\n\t\t    w = this.options.weight / 2;\r\n\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tw += 10; // polyline click tolerance on touch devices\r\n\t\t}\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tif (!closed && (j === 0)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);\r\n\r\n\t\t\t\tif (dist <= w) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.\r\n */\r\n\r\nL.Polygon.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p) {\r\n\t\tvar inside = false,\r\n\t\t    part, p1, p2,\r\n\t\t    i, j, k,\r\n\t\t    len, len2;\r\n\r\n\t\t// TODO optimization: check if within bounds first\r\n\r\n\t\tif (L.Polyline.prototype._containsPoint.call(this, p, true)) {\r\n\t\t\t// click on polygon border\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// ray casting algorithm for detecting if point is in polygon\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tp1 = part[j];\r\n\t\t\t\tp2 = part[k];\r\n\r\n\t\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) &&\r\n\t\t\t\t\t\t(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\r\n\t\t\t\t\tinside = !inside;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn inside;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Circle with Canvas-specific code.\r\n */\r\n\r\nL.Circle.include(!L.Path.CANVAS ? {} : {\r\n\t_drawPath: function () {\r\n\t\tvar p = this._point;\r\n\t\tthis._ctx.beginPath();\r\n\t\tthis._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);\r\n\t},\r\n\r\n\t_containsPoint: function (p) {\r\n\t\tvar center = this._point,\r\n\t\t    w2 = this.options.stroke ? this.options.weight / 2 : 0;\r\n\r\n\t\treturn (p.distanceTo(center) <= this._radius + w2);\r\n\t}\r\n});\r\n\n\n/*\n * CircleMarker canvas specific drawing parts.\n */\n\nL.CircleMarker.include(!L.Path.CANVAS ? {} : {\n\t_updateStyle: function () {\n\t\tL.Path.prototype._updateStyle.call(this);\n\t}\n});\n\n\n/*\r\n * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\r\n */\r\n\r\nL.GeoJSON = L.FeatureGroup.extend({\r\n\r\n\tinitialize: function (geojson, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\r\n\t\tif (geojson) {\r\n\t\t\tthis.addData(geojson);\r\n\t\t}\r\n\t},\r\n\r\n\taddData: function (geojson) {\r\n\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\r\n\t\t    i, len, feature;\r\n\r\n\t\tif (features) {\r\n\t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n\t\t\t\t// Only add this if geometry or geometries are set and not null\r\n\t\t\t\tfeature = features[i];\r\n\t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n\t\t\t\t\tthis.addData(features[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.filter && !options.filter(geojson)) { return; }\r\n\r\n\t\tvar layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);\r\n\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\r\n\r\n\t\tlayer.defaultOptions = layer.options;\r\n\t\tthis.resetStyle(layer);\r\n\r\n\t\tif (options.onEachFeature) {\r\n\t\t\toptions.onEachFeature(geojson, layer);\r\n\t\t}\r\n\r\n\t\treturn this.addLayer(layer);\r\n\t},\r\n\r\n\tresetStyle: function (layer) {\r\n\t\tvar style = this.options.style;\r\n\t\tif (style) {\r\n\t\t\t// reset any custom styles\r\n\t\t\tL.Util.extend(layer.options, layer.defaultOptions);\r\n\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}, this);\r\n\t},\r\n\r\n\t_setLayerStyle: function (layer, style) {\r\n\t\tif (typeof style === 'function') {\r\n\t\t\tstyle = style(layer.feature);\r\n\t\t}\r\n\t\tif (layer.setStyle) {\r\n\t\t\tlayer.setStyle(style);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.extend(L.GeoJSON, {\r\n\tgeometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {\r\n\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n\t\t    coords = geometry.coordinates,\r\n\t\t    layers = [],\r\n\t\t    latlng, latlngs, i, len;\r\n\r\n\t\tcoordsToLatLng = coordsToLatLng || this.coordsToLatLng;\r\n\r\n\t\tswitch (geometry.type) {\r\n\t\tcase 'Point':\r\n\t\t\tlatlng = coordsToLatLng(coords);\r\n\t\t\treturn pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\r\n\r\n\t\tcase 'MultiPoint':\r\n\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\t\tlatlng = coordsToLatLng(coords[i]);\r\n\t\t\t\tlayers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tcase 'LineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);\r\n\t\t\treturn new L.Polyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'Polygon':\r\n\t\t\tif (coords.length === 2 && !coords[1].length) {\r\n\t\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t\t}\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.Polygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiLineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiPolygon':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'GeometryCollection':\r\n\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n\r\n\t\t\t\tlayers.push(this.geometryToLayer({\r\n\t\t\t\t\tgeometry: geometry.geometries[i],\r\n\t\t\t\t\ttype: 'Feature',\r\n\t\t\t\t\tproperties: geojson.properties\r\n\t\t\t\t}, pointToLayer, coordsToLatLng, vectorOptions));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t}\r\n\t},\r\n\r\n\tcoordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng\r\n\t\treturn new L.LatLng(coords[1], coords[0], coords[2]);\r\n\t},\r\n\r\n\tcoordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array\r\n\t\tvar latlng, i, len,\r\n\t\t    latlngs = [];\r\n\r\n\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\tlatlng = levelsDeep ?\r\n\t\t\t        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :\r\n\t\t\t        (coordsToLatLng || this.coordsToLatLng)(coords[i]);\r\n\r\n\t\t\tlatlngs.push(latlng);\r\n\t\t}\r\n\r\n\t\treturn latlngs;\r\n\t},\r\n\r\n\tlatLngToCoords: function (latlng) {\r\n\t\tvar coords = [latlng.lng, latlng.lat];\r\n\r\n\t\tif (latlng.alt !== undefined) {\r\n\t\t\tcoords.push(latlng.alt);\r\n\t\t}\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tlatLngsToCoords: function (latLngs) {\r\n\t\tvar coords = [];\r\n\r\n\t\tfor (var i = 0, len = latLngs.length; i < len; i++) {\r\n\t\t\tcoords.push(L.GeoJSON.latLngToCoords(latLngs[i]));\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tgetFeature: function (layer, newGeometry) {\r\n\t\treturn layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);\r\n\t},\r\n\r\n\tasFeature: function (geoJSON) {\r\n\t\tif (geoJSON.type === 'Feature') {\r\n\t\t\treturn geoJSON;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: 'Feature',\r\n\t\t\tproperties: {},\r\n\t\t\tgeometry: geoJSON\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar PointToGeoJSON = {\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Point',\r\n\t\t\tcoordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\r\n\t\t});\r\n\t}\r\n};\r\n\r\nL.Marker.include(PointToGeoJSON);\r\nL.Circle.include(PointToGeoJSON);\r\nL.CircleMarker.include(PointToGeoJSON);\r\n\r\nL.Polyline.include({\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'LineString',\r\n\t\t\tcoordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())\r\n\t\t});\r\n\t}\r\n});\r\n\r\nL.Polygon.include({\r\n\ttoGeoJSON: function () {\r\n\t\tvar coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],\r\n\t\t    i, len, hole;\r\n\r\n\t\tcoords[0].push(coords[0][0]);\r\n\r\n\t\tif (this._holes) {\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = L.GeoJSON.latLngsToCoords(this._holes[i]);\r\n\t\t\t\thole.push(hole[0]);\r\n\t\t\t\tcoords.push(hole);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Polygon',\r\n\t\t\tcoordinates: coords\r\n\t\t});\r\n\t}\r\n});\r\n\r\n(function () {\r\n\tfunction multiToGeoJSON(type) {\r\n\t\treturn function () {\r\n\t\t\tvar coords = [];\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tcoords.push(layer.toGeoJSON().geometry.coordinates);\r\n\t\t\t});\r\n\r\n\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\ttype: type,\r\n\t\t\t\tcoordinates: coords\r\n\t\t\t});\r\n\t\t};\r\n\t}\r\n\r\n\tL.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});\r\n\tL.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});\r\n\r\n\tL.LayerGroup.include({\r\n\t\ttoGeoJSON: function () {\r\n\r\n\t\t\tvar geometry = this.feature && this.feature.geometry,\r\n\t\t\t\tjsons = [],\r\n\t\t\t\tjson;\r\n\r\n\t\t\tif (geometry && geometry.type === 'MultiPoint') {\r\n\t\t\t\treturn multiToGeoJSON('MultiPoint').call(this);\r\n\t\t\t}\r\n\r\n\t\t\tvar isGeometryCollection = geometry && geometry.type === 'GeometryCollection';\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tif (layer.toGeoJSON) {\r\n\t\t\t\t\tjson = layer.toGeoJSON();\r\n\t\t\t\t\tjsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (isGeometryCollection) {\r\n\t\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\t\tgeometries: jsons,\r\n\t\t\t\t\ttype: 'GeometryCollection'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\ttype: 'FeatureCollection',\r\n\t\t\t\tfeatures: jsons\r\n\t\t\t};\r\n\t\t}\r\n\t});\r\n}());\r\n\r\nL.geoJson = function (geojson, options) {\r\n\treturn new L.GeoJSON(geojson, options);\r\n};\r\n\n\n/*\r\n * L.DomEvent contains functions for working with DOM events.\r\n */\r\n\r\nL.DomEvent = {\r\n\t/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */\r\n\taddListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler, originalHandler, newType;\r\n\r\n\t\tif (obj[key]) { return this; }\r\n\r\n\t\thandler = function (e) {\r\n\t\t\treturn fn.call(context || obj, e || L.DomEvent._getEvent());\r\n\t\t};\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\treturn this.addPointerListener(obj, type, handler, id);\r\n\t\t}\r\n\t\tif (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {\r\n\t\t\tthis.addDoubleTapListener(obj, handler, id);\r\n\t\t}\r\n\r\n\t\tif ('addEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.addEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\tnewType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');\r\n\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\tif (!L.DomEvent._checkMouse(obj, e)) { return; }\r\n\t\t\t\t\treturn originalHandler(e);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(newType, handler, false);\r\n\r\n\t\t\t} else if (type === 'click' && L.Browser.android) {\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\treturn L.DomEvent._filterClick(e, originalHandler);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t}\r\n\r\n\t\t} else if ('attachEvent' in obj) {\r\n\t\t\tobj.attachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = handler;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveListener: function (obj, type, fn) {  // (HTMLElement, String, Function)\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler = obj[key];\r\n\r\n\t\tif (!handler) { return this; }\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\tthis.removePointerListener(obj, type, id);\r\n\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {\r\n\t\t\tthis.removeDoubleTapListener(obj, id);\r\n\r\n\t\t} else if ('removeEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.removeEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\t\t\t\tobj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\t\t\t}\r\n\t\t} else if ('detachEvent' in obj) {\r\n\t\t\tobj.detachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = null;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopPropagation: function (e) {\r\n\r\n\t\tif (e.stopPropagation) {\r\n\t\t\te.stopPropagation();\r\n\t\t} else {\r\n\t\t\te.cancelBubble = true;\r\n\t\t}\r\n\t\tL.DomEvent._skipped(e);\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdisableScrollPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'mousewheel', stop)\r\n\t\t\t.on(el, 'MozMousePixelScroll', stop);\r\n\t},\r\n\r\n\tdisableClickPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(el, L.Draggable.START[i], stop);\r\n\t\t}\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'click', L.DomEvent._fakeStop)\r\n\t\t\t.on(el, 'dblclick', stop);\r\n\t},\r\n\r\n\tpreventDefault: function (e) {\r\n\r\n\t\tif (e.preventDefault) {\r\n\t\t\te.preventDefault();\r\n\t\t} else {\r\n\t\t\te.returnValue = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstop: function (e) {\r\n\t\treturn L.DomEvent\r\n\t\t\t.preventDefault(e)\r\n\t\t\t.stopPropagation(e);\r\n\t},\r\n\r\n\tgetMousePosition: function (e, container) {\r\n\t\tif (!container) {\r\n\t\t\treturn new L.Point(e.clientX, e.clientY);\r\n\t\t}\r\n\r\n\t\tvar rect = container.getBoundingClientRect();\r\n\r\n\t\treturn new L.Point(\r\n\t\t\te.clientX - rect.left - container.clientLeft,\r\n\t\t\te.clientY - rect.top - container.clientTop);\r\n\t},\r\n\r\n\tgetWheelDelta: function (e) {\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif (e.wheelDelta) {\r\n\t\t\tdelta = e.wheelDelta / 120;\r\n\t\t}\r\n\t\tif (e.detail) {\r\n\t\t\tdelta = -e.detail / 3;\r\n\t\t}\r\n\t\treturn delta;\r\n\t},\r\n\r\n\t_skipEvents: {},\r\n\r\n\t_fakeStop: function (e) {\r\n\t\t// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\r\n\t\tL.DomEvent._skipEvents[e.type] = true;\r\n\t},\r\n\r\n\t_skipped: function (e) {\r\n\t\tvar skipped = this._skipEvents[e.type];\r\n\t\t// reset when checking, as it's only used in map container and propagates outside of the map\r\n\t\tthis._skipEvents[e.type] = false;\r\n\t\treturn skipped;\r\n\t},\r\n\r\n\t// check if element really left/entered the event target (for mouseenter/mouseleave)\r\n\t_checkMouse: function (el, e) {\r\n\r\n\t\tvar related = e.relatedTarget;\r\n\r\n\t\tif (!related) { return true; }\r\n\r\n\t\ttry {\r\n\t\t\twhile (related && (related !== el)) {\r\n\t\t\t\trelated = related.parentNode;\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn (related !== el);\r\n\t},\r\n\r\n\t_getEvent: function () { // evil magic for IE\r\n\t\t/*jshint noarg:false */\r\n\t\tvar e = window.event;\r\n\t\tif (!e) {\r\n\t\t\tvar caller = arguments.callee.caller;\r\n\t\t\twhile (caller) {\r\n\t\t\t\te = caller['arguments'][0];\r\n\t\t\t\tif (e && window.Event === e.constructor) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcaller = caller.caller;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn e;\r\n\t},\r\n\r\n\t// this is a horrible workaround for a bug in Android where a single touch triggers two click events\r\n\t_filterClick: function (e, handler) {\r\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t// on the same event should be triggered far faster;\r\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\r\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tL.DomEvent._lastClick = timeStamp;\r\n\r\n\t\treturn handler(e);\r\n\t}\r\n};\r\n\r\nL.DomEvent.on = L.DomEvent.addListener;\r\nL.DomEvent.off = L.DomEvent.removeListener;\r\n\n\n/*\r\n * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\r\n */\r\n\r\nL.Draggable = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tSTART: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\r\n\t\tEND: {\r\n\t\t\tmousedown: 'mouseup',\r\n\t\t\ttouchstart: 'touchend',\r\n\t\t\tpointerdown: 'touchend',\r\n\t\t\tMSPointerDown: 'touchend'\r\n\t\t},\r\n\t\tMOVE: {\r\n\t\t\tmousedown: 'mousemove',\r\n\t\t\ttouchstart: 'touchmove',\r\n\t\t\tpointerdown: 'touchmove',\r\n\t\t\tMSPointerDown: 'touchmove'\r\n\t\t}\r\n\t},\r\n\r\n\tinitialize: function (element, dragStartTarget) {\r\n\t\tthis._element = element;\r\n\t\tthis._dragStartTarget = dragStartTarget || element;\r\n\t},\r\n\r\n\tenable: function () {\r\n\t\tif (this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = true;\r\n\t},\r\n\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = false;\r\n\t\tthis._moved = false;\r\n\t},\r\n\r\n\t_onDown: function (e) {\r\n\t\tthis._moved = false;\r\n\r\n\t\tif (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\r\n\r\n\t\tL.DomEvent.stopPropagation(e);\r\n\r\n\t\tif (L.Draggable._disabled) { return; }\r\n\r\n\t\tL.DomUtil.disableImageDrag();\r\n\t\tL.DomUtil.disableTextSelection();\r\n\r\n\t\tif (this._moving) { return; }\r\n\r\n\t\tvar first = e.touches ? e.touches[0] : e;\r\n\r\n\t\tthis._startPoint = new L.Point(first.clientX, first.clientY);\r\n\t\tthis._startPos = this._newPos = L.DomUtil.getPosition(this._element);\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)\r\n\t\t    .on(document, L.Draggable.END[e.type], this._onUp, this);\r\n\t},\r\n\r\n\t_onMove: function (e) {\r\n\t\tif (e.touches && e.touches.length > 1) {\r\n\t\t\tthis._moved = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n\t\t    newPoint = new L.Point(first.clientX, first.clientY),\r\n\t\t    offset = newPoint.subtract(this._startPoint);\r\n\r\n\t\tif (!offset.x && !offset.y) { return; }\r\n\t\tif (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }\r\n\r\n\t\tL.DomEvent.preventDefault(e);\r\n\r\n\t\tif (!this._moved) {\r\n\t\t\tthis.fire('dragstart');\r\n\r\n\t\t\tthis._moved = true;\r\n\t\t\tthis._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\r\n\r\n\t\t\tL.DomUtil.addClass(document.body, 'leaflet-dragging');\r\n\t\t\tthis._lastTarget = e.target || e.srcElement;\r\n\t\t\tL.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t}\r\n\r\n\t\tthis._newPos = this._startPos.add(offset);\r\n\t\tthis._moving = true;\r\n\r\n\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\t\tthis._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tthis.fire('predrag');\r\n\t\tL.DomUtil.setPosition(this._element, this._newPos);\r\n\t\tthis.fire('drag');\r\n\t},\r\n\r\n\t_onUp: function () {\r\n\t\tL.DomUtil.removeClass(document.body, 'leaflet-dragging');\r\n\r\n\t\tif (this._lastTarget) {\r\n\t\t\tL.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t\tthis._lastTarget = null;\r\n\t\t}\r\n\r\n\t\tfor (var i in L.Draggable.MOVE) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(document, L.Draggable.MOVE[i], this._onMove)\r\n\t\t\t    .off(document, L.Draggable.END[i], this._onUp);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.enableImageDrag();\r\n\t\tL.DomUtil.enableTextSelection();\r\n\r\n\t\tif (this._moved && this._moving) {\r\n\t\t\t// ensure drag is not fired after dragend\r\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\r\n\t\t\tthis.fire('dragend', {\r\n\t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._moving = false;\r\n\t}\r\n});\r\n\n\n/*\n\tL.Handler is a base class for handler classes that are used internally to inject\n\tinteraction features like dragging to classes like Map and Marker.\n*/\n\nL.Handler = L.Class.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t},\n\n\tenable: function () {\n\t\tif (this._enabled) { return; }\n\n\t\tthis._enabled = true;\n\t\tthis.addHooks();\n\t},\n\n\tdisable: function () {\n\t\tif (!this._enabled) { return; }\n\n\t\tthis._enabled = false;\n\t\tthis.removeHooks();\n\t},\n\n\tenabled: function () {\n\t\treturn !!this._enabled;\n\t}\n});\n\n\n/*\n * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdragging: true,\n\n\tinertia: !L.Browser.android23,\n\tinertiaDeceleration: 3400, // px/s^2\n\tinertiaMaxSpeed: Infinity, // px/s\n\tinertiaThreshold: L.Browser.touch ? 32 : 18, // ms\n\teaseLinearity: 0.25,\n\n\t// TODO refactor, move to CRS\n\tworldCopyJump: false\n});\n\nL.Map.Drag = L.Handler.extend({\n\taddHooks: function () {\n\t\tif (!this._draggable) {\n\t\t\tvar map = this._map;\n\n\t\t\tthis._draggable = new L.Draggable(map._mapPane, map._container);\n\n\t\t\tthis._draggable.on({\n\t\t\t\t'dragstart': this._onDragStart,\n\t\t\t\t'drag': this._onDrag,\n\t\t\t\t'dragend': this._onDragEnd\n\t\t\t}, this);\n\n\t\t\tif (map.options.worldCopyJump) {\n\t\t\t\tthis._draggable.on('predrag', this._onPreDrag, this);\n\t\t\t\tmap.on('viewreset', this._onViewReset, this);\n\n\t\t\t\tmap.whenReady(this._onViewReset, this);\n\t\t\t}\n\t\t}\n\t\tthis._draggable.enable();\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable.disable();\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tvar map = this._map;\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tmap\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\n\t\tif (map.options.inertia) {\n\t\t\tthis._positions = [];\n\t\t\tthis._times = [];\n\t\t}\n\t},\n\n\t_onDrag: function () {\n\t\tif (this._map.options.inertia) {\n\t\t\tvar time = this._lastTime = +new Date(),\n\t\t\t    pos = this._lastPos = this._draggable._newPos;\n\n\t\t\tthis._positions.push(pos);\n\t\t\tthis._times.push(time);\n\n\t\t\tif (time - this._times[0] > 200) {\n\t\t\t\tthis._positions.shift();\n\t\t\t\tthis._times.shift();\n\t\t\t}\n\t\t}\n\n\t\tthis._map\n\t\t    .fire('move')\n\t\t    .fire('drag');\n\t},\n\n\t_onViewReset: function () {\n\t\t// TODO fix hardcoded Earth values\n\t\tvar pxCenter = this._map.getSize()._divideBy(2),\n\t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n\t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n\t\tthis._worldWidth = this._map.project([0, 180]).x;\n\t},\n\n\t_onPreDrag: function () {\n\t\t// TODO refactor to be able to adjust map pane position after zoom\n\t\tvar worldWidth = this._worldWidth,\n\t\t    halfWidth = Math.round(worldWidth / 2),\n\t\t    dx = this._initialWorldOffset,\n\t\t    x = this._draggable._newPos.x,\n\t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n\t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n\t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n\t\tthis._draggable._newPos.x = newX;\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tvar map = this._map,\n\t\t    options = map.options,\n\t\t    delay = +new Date() - this._lastTime,\n\n\t\t    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];\n\n\t\tmap.fire('dragend', e);\n\n\t\tif (noInertia) {\n\t\t\tmap.fire('moveend');\n\n\t\t} else {\n\n\t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n\t\t\t    duration = (this._lastTime + delay - this._times[0]) / 1000,\n\t\t\t    ease = options.easeLinearity,\n\n\t\t\t    speedVector = direction.multiplyBy(ease / duration),\n\t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n\t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n\t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n\t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n\t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n\t\t\tif (!offset.x || !offset.y) {\n\t\t\t\tmap.fire('moveend');\n\n\t\t\t} else {\n\t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n\t\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\t\tmap.panBy(offset, {\n\t\t\t\t\t\tduration: decelerationDuration,\n\t\t\t\t\t\teaseLinearity: ease,\n\t\t\t\t\t\tnoMoveStart: true\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\n\n/*\n * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdoubleClickZoom: true\n});\n\nL.Map.DoubleClickZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tthis._map.on('dblclick', this._onDoubleClick, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._map.off('dblclick', this._onDoubleClick, this);\n\t},\n\n\t_onDoubleClick: function (e) {\n\t\tvar map = this._map,\n\t\t    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);\n\n\t\tif (map.options.doubleClickZoom === 'center') {\n\t\t\tmap.setZoom(zoom);\n\t\t} else {\n\t\t\tmap.setZoomAround(e.containerPoint, zoom);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\n\n/*\n * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n */\n\nL.Map.mergeOptions({\n\tscrollWheelZoom: true\n});\n\nL.Map.ScrollWheelZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n\t\tL.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t\tthis._delta = 0;\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);\n\t\tL.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t},\n\n\t_onWheelScroll: function (e) {\n\t\tvar delta = L.DomEvent.getWheelDelta(e);\n\n\t\tthis._delta += delta;\n\t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n\t\tif (!this._startTime) {\n\t\t\tthis._startTime = +new Date();\n\t\t}\n\n\t\tvar left = Math.max(40 - (+new Date() - this._startTime), 0);\n\n\t\tclearTimeout(this._timer);\n\t\tthis._timer = setTimeout(L.bind(this._performZoom, this), left);\n\n\t\tL.DomEvent.preventDefault(e);\n\t\tL.DomEvent.stopPropagation(e);\n\t},\n\n\t_performZoom: function () {\n\t\tvar map = this._map,\n\t\t    delta = this._delta,\n\t\t    zoom = map.getZoom();\n\n\t\tdelta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\t\tdelta = Math.max(Math.min(delta, 4), -4);\n\t\tdelta = map._limitZoom(zoom + delta) - zoom;\n\n\t\tthis._delta = 0;\n\t\tthis._startTime = null;\n\n\t\tif (!delta) { return; }\n\n\t\tif (map.options.scrollWheelZoom === 'center') {\n\t\t\tmap.setZoom(zoom + delta);\n\t\t} else {\n\t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\n\n/*\r\n * Extends the event handling code with double tap support for mobile browsers.\r\n */\r\n\r\nL.extend(L.DomEvent, {\r\n\r\n\t_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\r\n\t_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\r\n\r\n\t// inspired by Zepto touch code by Thomas Fuchs\r\n\taddDoubleTapListener: function (obj, handler, id) {\r\n\t\tvar last,\r\n\t\t    doubleTap = false,\r\n\t\t    delay = 250,\r\n\t\t    touch,\r\n\t\t    pre = '_leaflet_',\r\n\t\t    touchstart = this._touchstart,\r\n\t\t    touchend = this._touchend,\r\n\t\t    trackedTouches = [];\r\n\r\n\t\tfunction onTouchStart(e) {\r\n\t\t\tvar count;\r\n\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\ttrackedTouches.push(e.pointerId);\r\n\t\t\t\tcount = trackedTouches.length;\r\n\t\t\t} else {\r\n\t\t\t\tcount = e.touches.length;\r\n\t\t\t}\r\n\t\t\tif (count > 1) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar now = Date.now(),\r\n\t\t\t\tdelta = now - (last || now);\r\n\r\n\t\t\ttouch = e.touches ? e.touches[0] : e;\r\n\t\t\tdoubleTap = (delta > 0 && delta <= delay);\r\n\t\t\tlast = now;\r\n\t\t}\r\n\r\n\t\tfunction onTouchEnd(e) {\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\tvar idx = trackedTouches.indexOf(e.pointerId);\r\n\t\t\t\tif (idx === -1) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\ttrackedTouches.splice(idx, 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (doubleTap) {\r\n\t\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\t\t// work around .type being readonly with MSPointer* events\r\n\t\t\t\t\tvar newTouch = { },\r\n\t\t\t\t\t\tprop;\r\n\r\n\t\t\t\t\t// jshint forin:false\r\n\t\t\t\t\tfor (var i in touch) {\r\n\t\t\t\t\t\tprop = touch[i];\r\n\t\t\t\t\t\tif (typeof prop === 'function') {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop.bind(touch);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttouch = newTouch;\r\n\t\t\t\t}\r\n\t\t\t\ttouch.type = 'dblclick';\r\n\t\t\t\thandler(touch);\r\n\t\t\t\tlast = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tobj[pre + touchstart + id] = onTouchStart;\r\n\t\tobj[pre + touchend + id] = onTouchEnd;\r\n\r\n\t\t// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen\r\n\t\t// will not come through to us, so we will lose track of how many touches are ongoing\r\n\t\tvar endElement = L.Browser.pointer ? document.documentElement : obj;\r\n\r\n\t\tobj.addEventListener(touchstart, onTouchStart, false);\r\n\t\tendElement.addEventListener(touchend, onTouchEnd, false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tendElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveDoubleTapListener: function (obj, id) {\r\n\t\tvar pre = '_leaflet_';\r\n\r\n\t\tobj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\r\n\t\t(L.Browser.pointer ? document.documentElement : obj).removeEventListener(\r\n\t\t        this._touchend, obj[pre + this._touchend + id], false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tdocument.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],\r\n\t\t\t\tfalse);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\n * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n */\n\nL.extend(L.DomEvent, {\n\n\t//static\n\tPOINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',\n\tPOINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',\n\tPOINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',\n\tPOINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n\n\t_pointers: [],\n\t_pointerDocumentListener: false,\n\n\t// Provides a touch events wrapper for (ms)pointer events.\n\t// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019\n\t//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n\taddPointerListener: function (obj, type, handler, id) {\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\treturn this.addPointerListenerStart(obj, type, handler, id);\n\t\tcase 'touchend':\n\t\t\treturn this.addPointerListenerEnd(obj, type, handler, id);\n\t\tcase 'touchmove':\n\t\t\treturn this.addPointerListenerMove(obj, type, handler, id);\n\t\tdefault:\n\t\t\tthrow 'Unknown touch event type';\n\t\t}\n\t},\n\n\taddPointerListenerStart: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    pointers = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tif (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n\t\t\t\tL.DomEvent.preventDefault(e);\n\t\t\t}\n\n\t\t\tvar alreadyInArray = false;\n\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\talreadyInArray = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!alreadyInArray) {\n\t\t\t\tpointers.push(e);\n\t\t\t}\n\n\t\t\te.touches = pointers.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchstart' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_DOWN, cb, false);\n\n\t\t// need to also listen for end events to keep the _pointers list accurate\n\t\t// this needs to be on the body and never go away\n\t\tif (!this._pointerDocumentListener) {\n\t\t\tvar internalCb = function (e) {\n\t\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\t\tpointers.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_UP, internalCb, false);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);\n\n\t\t\tthis._pointerDocumentListener = true;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerMove: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tfunction cb(e) {\n\n\t\t\t// don't fire touch moves when mouse isn't down\n\t\t\tif ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }\n\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches[i] = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t}\n\n\t\tobj[pre + 'touchmove' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_MOVE, cb, false);\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerEnd: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchend' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_UP, cb, false);\n\t\tobj.addEventListener(this.POINTER_CANCEL, cb, false);\n\n\t\treturn this;\n\t},\n\n\tremovePointerListener: function (obj, type, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    cb = obj[pre + type + id];\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\tobj.removeEventListener(this.POINTER_DOWN, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchmove':\n\t\t\tobj.removeEventListener(this.POINTER_MOVE, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchend':\n\t\t\tobj.removeEventListener(this.POINTER_UP, cb, false);\n\t\t\tobj.removeEventListener(this.POINTER_CANCEL, cb, false);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\n\n/*\n * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n */\n\nL.Map.mergeOptions({\n\ttouchZoom: L.Browser.touch && !L.Browser.android23,\n\tbounceAtZoomLimits: true\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]),\n\t\t    viewCenter = map._getCenterLayerPoint();\n\n\t\tthis._startCenter = p1.add(p2)._divideBy(2);\n\t\tthis._startDist = p1.distanceTo(p2);\n\n\t\tthis._moved = false;\n\t\tthis._zooming = true;\n\n\t\tthis._centerOffset = viewCenter.subtract(this._startCenter);\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(document, 'touchmove', this._onTouchMove, this)\n\t\t    .on(document, 'touchend', this._onTouchEnd, this);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]);\n\n\t\tthis._scale = p1.distanceTo(p2) / this._startDist;\n\t\tthis._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);\n\n\t\tif (this._scale === 1) { return; }\n\n\t\tif (!map.options.bounceAtZoomLimits) {\n\t\t\tif ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||\n\t\t\t    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }\n\t\t}\n\n\t\tif (!this._moved) {\n\t\t\tL.DomUtil.addClass(map._mapPane, 'leaflet-touching');\n\n\t\t\tmap\n\t\t\t    .fire('movestart')\n\t\t\t    .fire('zoomstart');\n\n\t\t\tthis._moved = true;\n\t\t}\n\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\t\tthis._animRequest = L.Util.requestAnimFrame(\n\t\t        this._updateOnMove, this, true, this._map._container);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_updateOnMove: function () {\n\t\tvar map = this._map,\n\t\t    origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\t\t    zoom = map.getScaleZoom(this._scale);\n\n\t\tmap._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);\n\t},\n\n\t_onTouchEnd: function () {\n\t\tif (!this._moved || !this._zooming) {\n\t\t\tthis._zooming = false;\n\t\t\treturn;\n\t\t}\n\n\t\tvar map = this._map;\n\n\t\tthis._zooming = false;\n\t\tL.DomUtil.removeClass(map._mapPane, 'leaflet-touching');\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\tL.DomEvent\n\t\t    .off(document, 'touchmove', this._onTouchMove)\n\t\t    .off(document, 'touchend', this._onTouchEnd);\n\n\t\tvar origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\n\t\t    oldZoom = map.getZoom(),\n\t\t    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,\n\t\t    roundZoomDelta = (floatZoomDelta > 0 ?\n\t\t            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),\n\n\t\t    zoom = map._limitZoom(oldZoom + roundZoomDelta),\n\t\t    scale = map.getZoomScale(zoom) / this._scale;\n\n\t\tmap._animateZoom(center, zoom, origin, scale);\n\t},\n\n\t_getScaleOrigin: function () {\n\t\tvar centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);\n\t\treturn this._startCenter.add(centerOffset);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\n\n/*\n * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n */\n\nL.Map.mergeOptions({\n\ttap: true,\n\ttapTolerance: 15\n});\n\nL.Map.Tap = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\t_onDown: function (e) {\n\t\tif (!e.touches) { return; }\n\n\t\tL.DomEvent.preventDefault(e);\n\n\t\tthis._fireClick = true;\n\n\t\t// don't simulate click or track longpress if more than 1 touch\n\t\tif (e.touches.length > 1) {\n\t\t\tthis._fireClick = false;\n\t\t\tclearTimeout(this._holdTimeout);\n\t\t\treturn;\n\t\t}\n\n\t\tvar first = e.touches[0],\n\t\t    el = first.target;\n\n\t\tthis._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\n\t\t// if touching a link, highlight it\n\t\tif (el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\tL.DomUtil.addClass(el, 'leaflet-active');\n\t\t}\n\n\t\t// simulate long hold but setting a timeout\n\t\tthis._holdTimeout = setTimeout(L.bind(function () {\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._fireClick = false;\n\t\t\t\tthis._onUp();\n\t\t\t\tthis._simulateEvent('contextmenu', first);\n\t\t\t}\n\t\t}, this), 1000);\n\n\t\tL.DomEvent\n\t\t\t.on(document, 'touchmove', this._onMove, this)\n\t\t\t.on(document, 'touchend', this._onUp, this);\n\t},\n\n\t_onUp: function (e) {\n\t\tclearTimeout(this._holdTimeout);\n\n\t\tL.DomEvent\n\t\t\t.off(document, 'touchmove', this._onMove, this)\n\t\t\t.off(document, 'touchend', this._onUp, this);\n\n\t\tif (this._fireClick && e && e.changedTouches) {\n\n\t\t\tvar first = e.changedTouches[0],\n\t\t\t    el = first.target;\n\n\t\t\tif (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\t\tL.DomUtil.removeClass(el, 'leaflet-active');\n\t\t\t}\n\n\t\t\t// simulate click if the touch didn't move too much\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._simulateEvent('click', first);\n\t\t\t}\n\t\t}\n\t},\n\n\t_isTapValid: function () {\n\t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n\t},\n\n\t_onMove: function (e) {\n\t\tvar first = e.touches[0];\n\t\tthis._newPos = new L.Point(first.clientX, first.clientY);\n\t},\n\n\t_simulateEvent: function (type, e) {\n\t\tvar simulatedEvent = document.createEvent('MouseEvents');\n\n\t\tsimulatedEvent._simulated = true;\n\t\te.target._simulatedClick = true;\n\n\t\tsimulatedEvent.initMouseEvent(\n\t\t        type, true, true, window, 1,\n\t\t        e.screenX, e.screenY,\n\t\t        e.clientX, e.clientY,\n\t\t        false, false, false, false, 0, null);\n\n\t\te.target.dispatchEvent(simulatedEvent);\n\t}\n});\n\nif (L.Browser.touch && !L.Browser.pointer) {\n\tL.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n}\n\n\n/*\n * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n  * (zoom to a selected bounding box), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tboxZoom: true\n});\n\nL.Map.BoxZoom = L.Handler.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._pane = map._panes.overlayPane;\n\t\tthis._moved = false;\n\t},\n\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._container, 'mousedown', this._onMouseDown);\n\t\tthis._moved = false;\n\t},\n\n\tmoved: function () {\n\t\treturn this._moved;\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tthis._moved = false;\n\n\t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n\t\tL.DomUtil.disableTextSelection();\n\t\tL.DomUtil.disableImageDrag();\n\n\t\tthis._startLayerPoint = this._map.mouseEventToLayerPoint(e);\n\n\t\tL.DomEvent\n\t\t    .on(document, 'mousemove', this._onMouseMove, this)\n\t\t    .on(document, 'mouseup', this._onMouseUp, this)\n\t\t    .on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._moved) {\n\t\t\tthis._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);\n\t\t\tL.DomUtil.setPosition(this._box, this._startLayerPoint);\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = 'crosshair';\n\t\t\tthis._map.fire('boxzoomstart');\n\t\t}\n\n\t\tvar startPoint = this._startLayerPoint,\n\t\t    box = this._box,\n\n\t\t    layerPoint = this._map.mouseEventToLayerPoint(e),\n\t\t    offset = layerPoint.subtract(startPoint),\n\n\t\t    newPos = new L.Point(\n\t\t        Math.min(layerPoint.x, startPoint.x),\n\t\t        Math.min(layerPoint.y, startPoint.y));\n\n\t\tL.DomUtil.setPosition(box, newPos);\n\n\t\tthis._moved = true;\n\n\t\t// TODO refactor: remove hardcoded 4 pixels\n\t\tbox.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';\n\t\tbox.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';\n\t},\n\n\t_finish: function () {\n\t\tif (this._moved) {\n\t\t\tthis._pane.removeChild(this._box);\n\t\t\tthis._container.style.cursor = '';\n\t\t}\n\n\t\tL.DomUtil.enableTextSelection();\n\t\tL.DomUtil.enableImageDrag();\n\n\t\tL.DomEvent\n\t\t    .off(document, 'mousemove', this._onMouseMove)\n\t\t    .off(document, 'mouseup', this._onMouseUp)\n\t\t    .off(document, 'keydown', this._onKeyDown);\n\t},\n\n\t_onMouseUp: function (e) {\n\n\t\tthis._finish();\n\n\t\tvar map = this._map,\n\t\t    layerPoint = map.mouseEventToLayerPoint(e);\n\n\t\tif (this._startLayerPoint.equals(layerPoint)) { return; }\n\n\t\tvar bounds = new L.LatLngBounds(\n\t\t        map.layerPointToLatLng(this._startLayerPoint),\n\t\t        map.layerPointToLatLng(layerPoint));\n\n\t\tmap.fitBounds(bounds);\n\n\t\tmap.fire('boxzoomend', {\n\t\t\tboxZoomBounds: bounds\n\t\t});\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tif (e.keyCode === 27) {\n\t\t\tthis._finish();\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\n\n/*\n * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tkeyboard: true,\n\tkeyboardPanOffset: 80,\n\tkeyboardZoomOffset: 1\n});\n\nL.Map.Keyboard = L.Handler.extend({\n\n\tkeyCodes: {\n\t\tleft:    [37],\n\t\tright:   [39],\n\t\tdown:    [40],\n\t\tup:      [38],\n\t\tzoomIn:  [187, 107, 61, 171],\n\t\tzoomOut: [189, 109, 173]\n\t},\n\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\n\t\tthis._setPanOffset(map.options.keyboardPanOffset);\n\t\tthis._setZoomOffset(map.options.keyboardZoomOffset);\n\t},\n\n\taddHooks: function () {\n\t\tvar container = this._map._container;\n\n\t\t// make the container focusable by tabbing\n\t\tif (container.tabIndex === -1) {\n\t\t\tcontainer.tabIndex = '0';\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(container, 'focus', this._onFocus, this)\n\t\t    .on(container, 'blur', this._onBlur, this)\n\t\t    .on(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .on('focus', this._addHooks, this)\n\t\t    .on('blur', this._removeHooks, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._removeHooks();\n\n\t\tvar container = this._map._container;\n\n\t\tL.DomEvent\n\t\t    .off(container, 'focus', this._onFocus, this)\n\t\t    .off(container, 'blur', this._onBlur, this)\n\t\t    .off(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .off('focus', this._addHooks, this)\n\t\t    .off('blur', this._removeHooks, this);\n\t},\n\n\t_onMouseDown: function () {\n\t\tif (this._focused) { return; }\n\n\t\tvar body = document.body,\n\t\t    docEl = document.documentElement,\n\t\t    top = body.scrollTop || docEl.scrollTop,\n\t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n\t\tthis._map._container.focus();\n\n\t\twindow.scrollTo(left, top);\n\t},\n\n\t_onFocus: function () {\n\t\tthis._focused = true;\n\t\tthis._map.fire('focus');\n\t},\n\n\t_onBlur: function () {\n\t\tthis._focused = false;\n\t\tthis._map.fire('blur');\n\t},\n\n\t_setPanOffset: function (pan) {\n\t\tvar keys = this._panKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n\t\t\tkeys[codes.left[i]] = [-1 * pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n\t\t\tkeys[codes.right[i]] = [pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n\t\t\tkeys[codes.down[i]] = [0, pan];\n\t\t}\n\t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n\t\t\tkeys[codes.up[i]] = [0, -1 * pan];\n\t\t}\n\t},\n\n\t_setZoomOffset: function (zoom) {\n\t\tvar keys = this._zoomKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n\t\t\tkeys[codes.zoomIn[i]] = zoom;\n\t\t}\n\t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n\t\t\tkeys[codes.zoomOut[i]] = -zoom;\n\t\t}\n\t},\n\n\t_addHooks: function () {\n\t\tL.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_removeHooks: function () {\n\t\tL.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tvar key = e.keyCode,\n\t\t    map = this._map;\n\n\t\tif (key in this._panKeys) {\n\n\t\t\tif (map._panAnim && map._panAnim._inProgress) { return; }\n\n\t\t\tmap.panBy(this._panKeys[key]);\n\n\t\t\tif (map.options.maxBounds) {\n\t\t\t\tmap.panInsideBounds(map.options.maxBounds);\n\t\t\t}\n\n\t\t} else if (key in this._zoomKeys) {\n\t\t\tmap.setZoom(map.getZoom() + this._zoomKeys[key]);\n\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tL.DomEvent.stop(e);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\n\n/*\n * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n */\n\nL.Handler.MarkerDrag = L.Handler.extend({\n\tinitialize: function (marker) {\n\t\tthis._marker = marker;\n\t},\n\n\taddHooks: function () {\n\t\tvar icon = this._marker._icon;\n\t\tif (!this._draggable) {\n\t\t\tthis._draggable = new L.Draggable(icon, icon);\n\t\t}\n\n\t\tthis._draggable\n\t\t\t.on('dragstart', this._onDragStart, this)\n\t\t\t.on('drag', this._onDrag, this)\n\t\t\t.on('dragend', this._onDragEnd, this);\n\t\tthis._draggable.enable();\n\t\tL.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable\n\t\t\t.off('dragstart', this._onDragStart, this)\n\t\t\t.off('drag', this._onDrag, this)\n\t\t\t.off('dragend', this._onDragEnd, this);\n\n\t\tthis._draggable.disable();\n\t\tL.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tthis._marker\n\t\t    .closePopup()\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\t},\n\n\t_onDrag: function () {\n\t\tvar marker = this._marker,\n\t\t    shadow = marker._shadow,\n\t\t    iconPos = L.DomUtil.getPosition(marker._icon),\n\t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n\t\t// update shadow position\n\t\tif (shadow) {\n\t\t\tL.DomUtil.setPosition(shadow, iconPos);\n\t\t}\n\n\t\tmarker._latlng = latlng;\n\n\t\tmarker\n\t\t    .fire('move', {latlng: latlng})\n\t\t    .fire('drag');\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tthis._marker\n\t\t    .fire('moveend')\n\t\t    .fire('dragend', e);\n\t}\n});\n\n\n/*\r\n * L.Control is a base class for implementing map controls. Handles positioning.\r\n * All other controls extend from this class.\r\n */\r\n\r\nL.Control = L.Class.extend({\r\n\toptions: {\r\n\t\tposition: 'topright'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\t\treturn this.options.position;\r\n\t},\r\n\r\n\tsetPosition: function (position) {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.removeControl(this);\r\n\t\t}\r\n\r\n\t\tthis.options.position = position;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.addControl(this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tvar container = this._container = this.onAdd(map),\r\n\t\t    pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-control');\r\n\r\n\t\tif (pos.indexOf('bottom') !== -1) {\r\n\t\t\tcorner.insertBefore(container, corner.firstChild);\r\n\t\t} else {\r\n\t\t\tcorner.appendChild(container);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveFrom: function (map) {\r\n\t\tvar pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tcorner.removeChild(this._container);\r\n\t\tthis._map = null;\r\n\r\n\t\tif (this.onRemove) {\r\n\t\t\tthis.onRemove(map);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_refocusOnMap: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.getContainer().focus();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.control = function (options) {\r\n\treturn new L.Control(options);\r\n};\r\n\r\n\r\n// adds control-related methods to L.Map\r\n\r\nL.Map.include({\r\n\taddControl: function (control) {\r\n\t\tcontrol.addTo(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveControl: function (control) {\r\n\t\tcontrol.removeFrom(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initControlPos: function () {\r\n\t\tvar corners = this._controlCorners = {},\r\n\t\t    l = 'leaflet-',\r\n\t\t    container = this._controlContainer =\r\n\t\t            L.DomUtil.create('div', l + 'control-container', this._container);\r\n\r\n\t\tfunction createCorner(vSide, hSide) {\r\n\t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\r\n\t\t\tcorners[vSide + hSide] = L.DomUtil.create('div', className, container);\r\n\t\t}\r\n\r\n\t\tcreateCorner('top', 'left');\r\n\t\tcreateCorner('top', 'right');\r\n\t\tcreateCorner('bottom', 'left');\r\n\t\tcreateCorner('bottom', 'right');\r\n\t},\r\n\r\n\t_clearControlPos: function () {\r\n\t\tthis._container.removeChild(this._controlContainer);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.Control.Zoom is used for the default zoom buttons on the map.\r\n */\r\n\r\nL.Control.Zoom = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'topleft',\r\n\t\tzoomInText: '+',\r\n\t\tzoomInTitle: 'Zoom in',\r\n\t\tzoomOutText: '-',\r\n\t\tzoomOutTitle: 'Zoom out'\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tvar zoomName = 'leaflet-control-zoom',\r\n\t\t    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');\r\n\r\n\t\tthis._map = map;\r\n\r\n\t\tthis._zoomInButton  = this._createButton(\r\n\t\t        this.options.zoomInText, this.options.zoomInTitle,\r\n\t\t        zoomName + '-in',  container, this._zoomIn,  this);\r\n\t\tthis._zoomOutButton = this._createButton(\r\n\t\t        this.options.zoomOutText, this.options.zoomOutTitle,\r\n\t\t        zoomName + '-out', container, this._zoomOut, this);\r\n\r\n\t\tthis._updateDisabled();\r\n\t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\t},\r\n\r\n\t_zoomIn: function (e) {\r\n\t\tthis._map.zoomIn(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_zoomOut: function (e) {\r\n\t\tthis._map.zoomOut(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_createButton: function (html, title, className, container, fn, context) {\r\n\t\tvar link = L.DomUtil.create('a', className, container);\r\n\t\tlink.innerHTML = html;\r\n\t\tlink.href = '#';\r\n\t\tlink.title = title;\r\n\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(link, 'click', stop)\r\n\t\t    .on(link, 'mousedown', stop)\r\n\t\t    .on(link, 'dblclick', stop)\r\n\t\t    .on(link, 'click', L.DomEvent.preventDefault)\r\n\t\t    .on(link, 'click', fn, context)\r\n\t\t    .on(link, 'click', this._refocusOnMap, context);\r\n\r\n\t\treturn link;\r\n\t},\r\n\r\n\t_updateDisabled: function () {\r\n\t\tvar map = this._map,\r\n\t\t\tclassName = 'leaflet-disabled';\r\n\r\n\t\tL.DomUtil.removeClass(this._zoomInButton, className);\r\n\t\tL.DomUtil.removeClass(this._zoomOutButton, className);\r\n\r\n\t\tif (map._zoom === map.getMinZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomOutButton, className);\r\n\t\t}\r\n\t\tif (map._zoom === map.getMaxZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomInButton, className);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tzoomControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.zoomControl) {\r\n\t\tthis.zoomControl = new L.Control.Zoom();\r\n\t\tthis.addControl(this.zoomControl);\r\n\t}\r\n});\r\n\r\nL.control.zoom = function (options) {\r\n\treturn new L.Control.Zoom(options);\r\n};\r\n\r\n\n\n/*\r\n * L.Control.Attribution is used for displaying attribution on the map (added by default).\r\n */\r\n\r\nL.Control.Attribution = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'bottomright',\r\n\t\tprefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._attributions = {};\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-control-attribution');\r\n\t\tL.DomEvent.disableClickPropagation(this._container);\r\n\r\n\t\tfor (var i in map._layers) {\r\n\t\t\tif (map._layers[i].getAttribution) {\r\n\t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerAdd, this)\r\n\t\t    .on('layerremove', this._onLayerRemove, this);\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerAdd)\r\n\t\t    .off('layerremove', this._onLayerRemove);\r\n\r\n\t},\r\n\r\n\tsetPrefix: function (prefix) {\r\n\t\tthis.options.prefix = prefix;\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (!this._attributions[text]) {\r\n\t\t\tthis._attributions[text] = 0;\r\n\t\t}\r\n\t\tthis._attributions[text]++;\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (this._attributions[text]) {\r\n\t\t\tthis._attributions[text]--;\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar attribs = [];\r\n\r\n\t\tfor (var i in this._attributions) {\r\n\t\t\tif (this._attributions[i]) {\r\n\t\t\t\tattribs.push(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar prefixAndAttribs = [];\r\n\r\n\t\tif (this.options.prefix) {\r\n\t\t\tprefixAndAttribs.push(this.options.prefix);\r\n\t\t}\r\n\t\tif (attribs.length) {\r\n\t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n\t\t}\r\n\r\n\t\tthis._container.innerHTML = prefixAndAttribs.join(' | ');\r\n\t},\r\n\r\n\t_onLayerAdd: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.addAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t},\r\n\r\n\t_onLayerRemove: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.removeAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tattributionControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.attributionControl) {\r\n\t\tthis.attributionControl = (new L.Control.Attribution()).addTo(this);\r\n\t}\r\n});\r\n\r\nL.control.attribution = function (options) {\r\n\treturn new L.Control.Attribution(options);\r\n};\r\n\n\n/*\n * L.Control.Scale is used for displaying metric/imperial scale on the map.\n */\n\nL.Control.Scale = L.Control.extend({\n\toptions: {\n\t\tposition: 'bottomleft',\n\t\tmaxWidth: 100,\n\t\tmetric: true,\n\t\timperial: true,\n\t\tupdateWhenIdle: false\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tvar className = 'leaflet-control-scale',\n\t\t    container = L.DomUtil.create('div', className),\n\t\t    options = this.options;\n\n\t\tthis._addScales(options, className, container);\n\n\t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t\tmap.whenReady(this._update, this);\n\n\t\treturn container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t},\n\n\t_addScales: function (options, className, container) {\n\t\tif (options.metric) {\n\t\t\tthis._mScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t\tif (options.imperial) {\n\t\t\tthis._iScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tvar bounds = this._map.getBounds(),\n\t\t    centerLat = bounds.getCenter().lat,\n\t\t    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),\n\t\t    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,\n\n\t\t    size = this._map.getSize(),\n\t\t    options = this.options,\n\t\t    maxMeters = 0;\n\n\t\tif (size.x > 0) {\n\t\t\tmaxMeters = dist * (options.maxWidth / size.x);\n\t\t}\n\n\t\tthis._updateScales(options, maxMeters);\n\t},\n\n\t_updateScales: function (options, maxMeters) {\n\t\tif (options.metric && maxMeters) {\n\t\t\tthis._updateMetric(maxMeters);\n\t\t}\n\n\t\tif (options.imperial && maxMeters) {\n\t\t\tthis._updateImperial(maxMeters);\n\t\t}\n\t},\n\n\t_updateMetric: function (maxMeters) {\n\t\tvar meters = this._getRoundNum(maxMeters);\n\n\t\tthis._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';\n\t\tthis._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\t},\n\n\t_updateImperial: function (maxMeters) {\n\t\tvar maxFeet = maxMeters * 3.2808399,\n\t\t    scale = this._iScale,\n\t\t    maxMiles, miles, feet;\n\n\t\tif (maxFeet > 5280) {\n\t\t\tmaxMiles = maxFeet / 5280;\n\t\t\tmiles = this._getRoundNum(maxMiles);\n\n\t\t\tscale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';\n\t\t\tscale.innerHTML = miles + ' mi';\n\n\t\t} else {\n\t\t\tfeet = this._getRoundNum(maxFeet);\n\n\t\t\tscale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';\n\t\t\tscale.innerHTML = feet + ' ft';\n\t\t}\n\t},\n\n\t_getScaleWidth: function (ratio) {\n\t\treturn Math.round(this.options.maxWidth * ratio) - 10;\n\t},\n\n\t_getRoundNum: function (num) {\n\t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n\t\t    d = num / pow10;\n\n\t\td = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n\n\t\treturn pow10 * d;\n\t}\n});\n\nL.control.scale = function (options) {\n\treturn new L.Control.Scale(options);\n};\n\n\n/*\r\n * L.Control.Layers is a control to allow users to switch between different layers on the map.\r\n */\r\n\r\nL.Control.Layers = L.Control.extend({\r\n\toptions: {\r\n\t\tcollapsed: true,\r\n\t\tposition: 'topright',\r\n\t\tautoZIndex: true\r\n\t},\r\n\r\n\tinitialize: function (baseLayers, overlays, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._lastZIndex = 0;\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tfor (var i in baseLayers) {\r\n\t\t\tthis._addLayer(baseLayers[i], i);\r\n\t\t}\r\n\r\n\t\tfor (i in overlays) {\r\n\t\t\tthis._addLayer(overlays[i], i, true);\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._initLayout();\r\n\t\tthis._update();\r\n\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerChange, this)\r\n\t\t    .on('layerremove', this._onLayerChange, this);\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerChange, this)\r\n\t\t    .off('layerremove', this._onLayerChange, this);\r\n\t},\r\n\r\n\taddBaseLayer: function (layer, name) {\r\n\t\tthis._addLayer(layer, name);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOverlay: function (layer, name) {\r\n\t\tthis._addLayer(layer, name, true);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\t\tdelete this._layers[id];\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar className = 'leaflet-control-layers',\r\n\t\t    container = this._container = L.DomUtil.create('div', className);\r\n\r\n\t\t//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released\r\n\t\tcontainer.setAttribute('aria-haspopup', true);\r\n\r\n\t\tif (!L.Browser.touch) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.disableClickPropagation(container)\r\n\t\t\t\t.disableScrollPropagation(container);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);\r\n\t\t}\r\n\r\n\t\tvar form = this._form = L.DomUtil.create('form', className + '-list');\r\n\r\n\t\tif (this.options.collapsed) {\r\n\t\t\tif (!L.Browser.android) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(container, 'mouseover', this._expand, this)\r\n\t\t\t\t    .on(container, 'mouseout', this._collapse, this);\r\n\t\t\t}\r\n\t\t\tvar link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\r\n\t\t\tlink.href = '#';\r\n\t\t\tlink.title = 'Layers';\r\n\r\n\t\t\tif (L.Browser.touch) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(link, 'click', L.DomEvent.stop)\r\n\t\t\t\t    .on(link, 'click', this._expand, this);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tL.DomEvent.on(link, 'focus', this._expand, this);\r\n\t\t\t}\r\n\t\t\t//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033\r\n\t\t\tL.DomEvent.on(form, 'click', function () {\r\n\t\t\t\tsetTimeout(L.bind(this._onInputClick, this), 0);\r\n\t\t\t}, this);\r\n\r\n\t\t\tthis._map.on('click', this._collapse, this);\r\n\t\t\t// TODO keyboard accessibility\r\n\t\t} else {\r\n\t\t\tthis._expand();\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList = L.DomUtil.create('div', className + '-base', form);\r\n\t\tthis._separator = L.DomUtil.create('div', className + '-separator', form);\r\n\t\tthis._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\r\n\r\n\t\tcontainer.appendChild(form);\r\n\t},\r\n\r\n\t_addLayer: function (layer, name, overlay) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tthis._layers[id] = {\r\n\t\t\tlayer: layer,\r\n\t\t\tname: name,\r\n\t\t\toverlay: overlay\r\n\t\t};\r\n\r\n\t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n\t\t\tthis._lastZIndex++;\r\n\t\t\tlayer.setZIndex(this._lastZIndex);\r\n\t\t}\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._container) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList.innerHTML = '';\r\n\t\tthis._overlaysList.innerHTML = '';\r\n\r\n\t\tvar baseLayersPresent = false,\r\n\t\t    overlaysPresent = false,\r\n\t\t    i, obj;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tobj = this._layers[i];\r\n\t\t\tthis._addItem(obj);\r\n\t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n\t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n\t\t}\r\n\r\n\t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\t},\r\n\r\n\t_onLayerChange: function (e) {\r\n\t\tvar obj = this._layers[L.stamp(e.layer)];\r\n\r\n\t\tif (!obj) { return; }\r\n\r\n\t\tif (!this._handlingClick) {\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tvar type = obj.overlay ?\r\n\t\t\t(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :\r\n\t\t\t(e.type === 'layeradd' ? 'baselayerchange' : null);\r\n\r\n\t\tif (type) {\r\n\t\t\tthis._map.fire(type, obj);\r\n\t\t}\r\n\t},\r\n\r\n\t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\r\n\t_createRadioElement: function (name, checked) {\r\n\r\n\t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"';\r\n\t\tif (checked) {\r\n\t\t\tradioHtml += ' checked=\"checked\"';\r\n\t\t}\r\n\t\tradioHtml += '/>';\r\n\r\n\t\tvar radioFragment = document.createElement('div');\r\n\t\tradioFragment.innerHTML = radioHtml;\r\n\r\n\t\treturn radioFragment.firstChild;\r\n\t},\r\n\r\n\t_addItem: function (obj) {\r\n\t\tvar label = document.createElement('label'),\r\n\t\t    input,\r\n\t\t    checked = this._map.hasLayer(obj.layer);\r\n\r\n\t\tif (obj.overlay) {\r\n\t\t\tinput = document.createElement('input');\r\n\t\t\tinput.type = 'checkbox';\r\n\t\t\tinput.className = 'leaflet-control-layers-selector';\r\n\t\t\tinput.defaultChecked = checked;\r\n\t\t} else {\r\n\t\t\tinput = this._createRadioElement('leaflet-base-layers', checked);\r\n\t\t}\r\n\r\n\t\tinput.layerId = L.stamp(obj.layer);\r\n\r\n\t\tL.DomEvent.on(input, 'click', this._onInputClick, this);\r\n\r\n\t\tvar name = document.createElement('span');\r\n\t\tname.innerHTML = ' ' + obj.name;\r\n\r\n\t\tlabel.appendChild(input);\r\n\t\tlabel.appendChild(name);\r\n\r\n\t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n\t\tcontainer.appendChild(label);\r\n\r\n\t\treturn label;\r\n\t},\r\n\r\n\t_onInputClick: function () {\r\n\t\tvar i, input, obj,\r\n\t\t    inputs = this._form.getElementsByTagName('input'),\r\n\t\t    inputsLen = inputs.length;\r\n\r\n\t\tthis._handlingClick = true;\r\n\r\n\t\tfor (i = 0; i < inputsLen; i++) {\r\n\t\t\tinput = inputs[i];\r\n\t\t\tobj = this._layers[input.layerId];\r\n\r\n\t\t\tif (input.checked && !this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.addLayer(obj.layer);\r\n\r\n\t\t\t} else if (!input.checked && this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.removeLayer(obj.layer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tthis._refocusOnMap();\r\n\t},\r\n\r\n\t_expand: function () {\r\n\t\tL.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\r\n\t},\r\n\r\n\t_collapse: function () {\r\n\t\tthis._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');\r\n\t}\r\n});\r\n\r\nL.control.layers = function (baseLayers, overlays, options) {\r\n\treturn new L.Control.Layers(baseLayers, overlays, options);\r\n};\r\n\n\n/*\n * L.PosAnimation is used by Leaflet internally for pan animations.\n */\n\nL.PosAnimation = L.Class.extend({\n\tincludes: L.Mixin.Events,\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._newPos = newPos;\n\n\t\tthis.fire('start');\n\n\t\tel.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +\n\t\t        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';\n\n\t\tL.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\t\tL.DomUtil.setPosition(el, newPos);\n\n\t\t// toggle reflow, Chrome flickers for some reason if you don't do this\n\t\tL.Util.falseFn(el.offsetWidth);\n\n\t\t// there's no native way to track value updates of transitioned properties, so we imitate this\n\t\tthis._stepTimer = setInterval(L.bind(this._onStep, this), 50);\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\t// if we just removed the transition property, the element would jump to its final position,\n\t\t// so we need to make it stay at the current position\n\n\t\tL.DomUtil.setPosition(this._el, this._getPos());\n\t\tthis._onTransitionEnd();\n\t\tL.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation\n\t},\n\n\t_onStep: function () {\n\t\tvar stepPos = this._getPos();\n\t\tif (!stepPos) {\n\t\t\tthis._onTransitionEnd();\n\t\t\treturn;\n\t\t}\n\t\t// jshint camelcase: false\n\t\t// make L.DomUtil.getPosition return intermediate position value during animation\n\t\tthis._el._leaflet_pos = stepPos;\n\n\t\tthis.fire('step');\n\t},\n\n\t// you can't easily get intermediate values of properties animated with CSS3 Transitions,\n\t// we need to parse computed style (in case of transform it returns matrix string)\n\n\t_transformRe: /([-+]?(?:\\d*\\.)?\\d+)\\D*, ([-+]?(?:\\d*\\.)?\\d+)\\D*\\)/,\n\n\t_getPos: function () {\n\t\tvar left, top, matches,\n\t\t    el = this._el,\n\t\t    style = window.getComputedStyle(el);\n\n\t\tif (L.Browser.any3d) {\n\t\t\tmatches = style[L.DomUtil.TRANSFORM].match(this._transformRe);\n\t\t\tif (!matches) { return; }\n\t\t\tleft = parseFloat(matches[1]);\n\t\t\ttop  = parseFloat(matches[2]);\n\t\t} else {\n\t\t\tleft = parseFloat(style.left);\n\t\t\ttop  = parseFloat(style.top);\n\t\t}\n\n\t\treturn new L.Point(left, top, true);\n\t},\n\n\t_onTransitionEnd: function () {\n\t\tL.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\n\t\tif (!this._inProgress) { return; }\n\t\tthis._inProgress = false;\n\n\t\tthis._el.style[L.DomUtil.TRANSITION] = '';\n\n\t\t// jshint camelcase: false\n\t\t// make sure L.DomUtil.getPosition returns the final position value after animation\n\t\tthis._el._leaflet_pos = this._newPos;\n\n\t\tclearInterval(this._stepTimer);\n\n\t\tthis.fire('step').fire('end');\n\t}\n\n});\n\n\n/*\n * Extends L.Map to handle panning animations.\n */\n\nL.Map.include({\n\n\tsetView: function (center, zoom, options) {\n\n\t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n\t\tcenter = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n\t\toptions = options || {};\n\n\t\tif (this._panAnim) {\n\t\t\tthis._panAnim.stop();\n\t\t}\n\n\t\tif (this._loaded && !options.reset && options !== true) {\n\n\t\t\tif (options.animate !== undefined) {\n\t\t\t\toptions.zoom = L.extend({animate: options.animate}, options.zoom);\n\t\t\t\toptions.pan = L.extend({animate: options.animate}, options.pan);\n\t\t\t}\n\n\t\t\t// try animating pan or zoom\n\t\t\tvar animated = (this._zoom !== zoom) ?\n\t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\n\t\t\t\tthis._tryAnimatedPan(center, options.pan);\n\n\t\t\tif (animated) {\n\t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\n\t\t\t\tclearTimeout(this._sizeTimer);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// animation didn't start, just reset the map view\n\t\tthis._resetView(center, zoom);\n\n\t\treturn this;\n\t},\n\n\tpanBy: function (offset, options) {\n\t\toffset = L.point(offset).round();\n\t\toptions = options || {};\n\n\t\tif (!offset.x && !offset.y) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!this._panAnim) {\n\t\t\tthis._panAnim = new L.PosAnimation();\n\n\t\t\tthis._panAnim.on({\n\t\t\t\t'step': this._onPanTransitionStep,\n\t\t\t\t'end': this._onPanTransitionEnd\n\t\t\t}, this);\n\t\t}\n\n\t\t// don't fire movestart if animating inertia\n\t\tif (!options.noMoveStart) {\n\t\t\tthis.fire('movestart');\n\t\t}\n\n\t\t// animate pan unless animate: false specified\n\t\tif (options.animate !== false) {\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n\n\t\t\tvar newPos = this._getMapPanePos().subtract(offset);\n\t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n\t\t} else {\n\t\t\tthis._rawPanBy(offset);\n\t\t\tthis.fire('move').fire('moveend');\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_onPanTransitionStep: function () {\n\t\tthis.fire('move');\n\t},\n\n\t_onPanTransitionEnd: function () {\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n\t\tthis.fire('moveend');\n\t},\n\n\t_tryAnimatedPan: function (center, options) {\n\t\t// difference between the new and current centers in pixels\n\t\tvar offset = this._getCenterOffset(center)._floor();\n\n\t\t// don't animate too far unless animate: true specified in options\n\t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis.panBy(offset, options);\n\n\t\treturn true;\n\t}\n});\n\n\n/*\n * L.PosAnimation fallback implementation that powers Leaflet pan animations\n * in browsers that don't support CSS3 Transitions.\n */\n\nL.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._duration = duration || 0.25;\n\t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n\t\tthis._startPos = L.DomUtil.getPosition(el);\n\t\tthis._offset = newPos.subtract(this._startPos);\n\t\tthis._startTime = +new Date();\n\n\t\tthis.fire('start');\n\n\t\tthis._animate();\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\tthis._step();\n\t\tthis._complete();\n\t},\n\n\t_animate: function () {\n\t\t// animation loop\n\t\tthis._animId = L.Util.requestAnimFrame(this._animate, this);\n\t\tthis._step();\n\t},\n\n\t_step: function () {\n\t\tvar elapsed = (+new Date()) - this._startTime,\n\t\t    duration = this._duration * 1000;\n\n\t\tif (elapsed < duration) {\n\t\t\tthis._runFrame(this._easeOut(elapsed / duration));\n\t\t} else {\n\t\t\tthis._runFrame(1);\n\t\t\tthis._complete();\n\t\t}\n\t},\n\n\t_runFrame: function (progress) {\n\t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n\t\tL.DomUtil.setPosition(this._el, pos);\n\n\t\tthis.fire('step');\n\t},\n\n\t_complete: function () {\n\t\tL.Util.cancelAnimFrame(this._animId);\n\n\t\tthis._inProgress = false;\n\t\tthis.fire('end');\n\t},\n\n\t_easeOut: function (t) {\n\t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n\t}\n});\n\n\n/*\n * Extends L.Map to handle zoom animations.\n */\n\nL.Map.mergeOptions({\n\tzoomAnimation: true,\n\tzoomAnimationThreshold: 4\n});\n\nif (L.DomUtil.TRANSITION) {\n\n\tL.Map.addInitHook(function () {\n\t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\t\tthis._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&\n\t\t\t\tL.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;\n\n\t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\n\t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\t\tif (this._zoomAnimated) {\n\t\t\tL.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n\t\t}\n\t});\n}\n\nL.Map.include(!L.DomUtil.TRANSITION ? {} : {\n\n\t_catchTransitionEnd: function (e) {\n\t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n\t\t\tthis._onZoomTransitionEnd();\n\t\t}\n\t},\n\n\t_nothingToAnimate: function () {\n\t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n\t},\n\n\t_tryAnimatedZoom: function (center, zoom, options) {\n\n\t\tif (this._animatingZoom) { return true; }\n\n\t\toptions = options || {};\n\n\t\t// don't animate if disabled, not supported or zoom difference is too large\n\t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\n\t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\n\n\t\t// offset is the pixel coords of the zoom origin relative to the current center\n\t\tvar scale = this.getZoomScale(zoom),\n\t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),\n\t\t\torigin = this._getCenterLayerPoint()._add(offset);\n\n\t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis\n\t\t    .fire('movestart')\n\t\t    .fire('zoomstart');\n\n\t\tthis._animateZoom(center, zoom, origin, scale, null, true);\n\n\t\treturn true;\n\t},\n\n\t_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {\n\n\t\tif (!forTouchZoom) {\n\t\t\tthis._animatingZoom = true;\n\t\t}\n\n\t\t// put transform transition on all layers with leaflet-zoom-animated class\n\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\t// remember what center/zoom to set after animation\n\t\tthis._animateToCenter = center;\n\t\tthis._animateToZoom = zoom;\n\n\t\t// disable any dragging during animation\n\t\tif (L.Draggable) {\n\t\t\tL.Draggable._disabled = true;\n\t\t}\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis.fire('zoomanim', {\n\t\t\t\tcenter: center,\n\t\t\t\tzoom: zoom,\n\t\t\t\torigin: origin,\n\t\t\t\tscale: scale,\n\t\t\t\tdelta: delta,\n\t\t\t\tbackwards: backwards\n\t\t\t});\n\t\t\t// horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689\n\t\t\tsetTimeout(L.bind(this._onZoomTransitionEnd, this), 250);\n\t\t}, this);\n\t},\n\n\t_onZoomTransitionEnd: function () {\n\t\tif (!this._animatingZoom) { return; }\n\n\t\tthis._animatingZoom = false;\n\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis._resetView(this._animateToCenter, this._animateToZoom, true, true);\n\n\t\t\tif (L.Draggable) {\n\t\t\t\tL.Draggable._disabled = false;\n\t\t\t}\n\t\t}, this);\n\t}\n});\n\n\n/*\n\tZoom animation logic for L.TileLayer.\n*/\n\nL.TileLayer.include({\n\t_animateZoom: function (e) {\n\t\tif (!this._animating) {\n\t\t\tthis._animating = true;\n\t\t\tthis._prepareBgBuffer();\n\t\t}\n\n\t\tvar bg = this._bgBuffer,\n\t\t    transform = L.DomUtil.TRANSFORM,\n\t\t    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],\n\t\t    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);\n\n\t\tbg.style[transform] = e.backwards ?\n\t\t\t\tscaleStr + ' ' + initialTransform :\n\t\t\t\tinitialTransform + ' ' + scaleStr;\n\t},\n\n\t_endZoomAnim: function () {\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\tfront.style.visibility = '';\n\t\tfront.parentNode.appendChild(front); // Bring to fore\n\n\t\t// force reflow\n\t\tL.Util.falseFn(bg.offsetWidth);\n\n\t\tvar zoom = this._map.getZoom();\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t\t\tthis._clearBgBuffer();\n\t\t}\n\n\t\tthis._animating = false;\n\t},\n\n\t_clearBgBuffer: function () {\n\t\tvar map = this._map;\n\n\t\tif (map && !map._animatingZoom && !map.touchZoom._zooming) {\n\t\t\tthis._bgBuffer.innerHTML = '';\n\t\t\tthis._bgBuffer.style[L.DomUtil.TRANSFORM] = '';\n\t\t}\n\t},\n\n\t_prepareBgBuffer: function () {\n\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\t// if foreground layer doesn't have many tiles but bg layer does,\n\t\t// keep the existing bg layer and just zoom it some more\n\n\t\tvar bgLoaded = this._getLoadedTilesPercentage(bg),\n\t\t    frontLoaded = this._getLoadedTilesPercentage(front);\n\n\t\tif (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {\n\n\t\t\tfront.style.visibility = 'hidden';\n\t\t\tthis._stopLoadingImages(front);\n\t\t\treturn;\n\t\t}\n\n\t\t// prepare the buffer to become the front tile pane\n\t\tbg.style.visibility = 'hidden';\n\t\tbg.style[L.DomUtil.TRANSFORM] = '';\n\n\t\t// switch out the current layer to be the new bg layer (and vice-versa)\n\t\tthis._tileContainer = bg;\n\t\tbg = this._bgBuffer = front;\n\n\t\tthis._stopLoadingImages(bg);\n\n\t\t//prevent bg buffer from clearing right after zoom\n\t\tclearTimeout(this._clearBgBufferTimer);\n\t},\n\n\t_getLoadedTilesPercentage: function (container) {\n\t\tvar tiles = container.getElementsByTagName('img'),\n\t\t    i, len, count = 0;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\tif (tiles[i].complete) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count / len;\n\t},\n\n\t// stops loading all tiles in the background layer\n\t_stopLoadingImages: function (container) {\n\t\tvar tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),\n\t\t    i, len, tile;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\ttile = tiles[i];\n\n\t\t\tif (!tile.complete) {\n\t\t\t\ttile.onload = L.Util.falseFn;\n\t\t\t\ttile.onerror = L.Util.falseFn;\n\t\t\t\ttile.src = L.Util.emptyImageUrl;\n\n\t\t\t\ttile.parentNode.removeChild(tile);\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n/*\r\n * Provides L.Map with convenient shortcuts for using browser geolocation features.\r\n */\r\n\r\nL.Map.include({\r\n\t_defaultLocateOptions: {\r\n\t\twatch: false,\r\n\t\tsetView: false,\r\n\t\tmaxZoom: Infinity,\r\n\t\ttimeout: 10000,\r\n\t\tmaximumAge: 0,\r\n\t\tenableHighAccuracy: false\r\n\t},\r\n\r\n\tlocate: function (/*Object*/ options) {\r\n\r\n\t\toptions = this._locateOptions = L.extend(this._defaultLocateOptions, options);\r\n\r\n\t\tif (!navigator.geolocation) {\r\n\t\t\tthis._handleGeolocationError({\r\n\t\t\t\tcode: 0,\r\n\t\t\t\tmessage: 'Geolocation not supported.'\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar onResponse = L.bind(this._handleGeolocationResponse, this),\r\n\t\t\tonError = L.bind(this._handleGeolocationError, this);\r\n\r\n\t\tif (options.watch) {\r\n\t\t\tthis._locationWatchId =\r\n\t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n\t\t} else {\r\n\t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopLocate: function () {\r\n\t\tif (navigator.geolocation) {\r\n\t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n\t\t}\r\n\t\tif (this._locateOptions) {\r\n\t\t\tthis._locateOptions.setView = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_handleGeolocationError: function (error) {\r\n\t\tvar c = error.code,\r\n\t\t    message = error.message ||\r\n\t\t            (c === 1 ? 'permission denied' :\r\n\t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n\t\tif (this._locateOptions.setView && !this._loaded) {\r\n\t\t\tthis.fitWorld();\r\n\t\t}\r\n\r\n\t\tthis.fire('locationerror', {\r\n\t\t\tcode: c,\r\n\t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n\t\t});\r\n\t},\r\n\r\n\t_handleGeolocationResponse: function (pos) {\r\n\t\tvar lat = pos.coords.latitude,\r\n\t\t    lng = pos.coords.longitude,\r\n\t\t    latlng = new L.LatLng(lat, lng),\r\n\r\n\t\t    latAccuracy = 180 * pos.coords.accuracy / 40075017,\r\n\t\t    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),\r\n\r\n\t\t    bounds = L.latLngBounds(\r\n\t\t            [lat - latAccuracy, lng - lngAccuracy],\r\n\t\t            [lat + latAccuracy, lng + lngAccuracy]),\r\n\r\n\t\t    options = this._locateOptions;\r\n\r\n\t\tif (options.setView) {\r\n\t\t\tvar zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);\r\n\t\t\tthis.setView(latlng, zoom);\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tbounds: bounds,\r\n\t\t\ttimestamp: pos.timestamp\r\n\t\t};\r\n\r\n\t\tfor (var i in pos.coords) {\r\n\t\t\tif (typeof pos.coords[i] === 'number') {\r\n\t\t\t\tdata[i] = pos.coords[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.fire('locationfound', data);\r\n\t}\r\n});\r\n\n\n}(window, document));\n},{}],4:[function(require,module,exports){\n/*!\nCopyright (c) 2016 Dominik Moritz\n\nThis file is part of the leaflet locate control. It is licensed under the MIT license.\nYou can find the project at: https://github.com/domoritz/leaflet-locatecontrol\n*/\n(function (factory, window) {\n     // see https://github.com/Leaflet/Leaflet/blob/master/PLUGIN-GUIDE.md#module-loaders\n     // for details on how to structure a leaflet plugin.\n\n    // define an AMD module that relies on 'leaflet'\n    if (typeof define === 'function' && define.amd) {\n        define(['leaflet'], factory);\n\n    // define a Common JS module that relies on 'leaflet'\n    } else if (typeof exports === 'object') {\n        if (typeof window !== 'undefined' && window.L) {\n            module.exports = factory(L);\n        } else {\n            module.exports = factory(require('leaflet'));\n        }\n    }\n\n    // attach your plugin to the global 'L' variable\n    if(typeof window !== 'undefined' && window.L){\n        window.L.Control.Locate = factory(L);\n    }\n} (function (L) {\n    var LocateControl = L.Control.extend({\n        options: {\n            /** Position of the control */\n            position: 'topleft',\n            /** The layer that the user's location should be drawn on. By default creates a new layer. */\n            layer: undefined,\n            /**\n             * Automatically sets the map view (zoom and pan) to the user's location as it updates.\n             * While the map is following the user's location, the control is in the `following` state,\n             * which changes the style of the control and the circle marker.\n             *\n             * Possible values:\n             *  - false: never updates the map view when location changes.\n             *  - 'once': set the view when the location is first determined\n             *  - 'always': always updates the map view when location changes.\n             *              The map view follows the users location.\n             *  - 'untilPan': (default) like 'always', except stops updating the\n             *                view if the user has manually panned the map.\n             *                The map view follows the users location until she pans.\n             */\n            setView: 'untilPan',\n            /** Keep the current map zoom level when setting the view and only pan. */\n            keepCurrentZoomLevel: false,\n            /**\n             * The user location can be inside and outside the current view when the user clicks on the\n             * control that is already active. Both cases can be configures separately.\n             * Possible values are:\n             *  - 'setView': zoom and pan to the current location\n             *  - 'stop': stop locating and remove the location marker\n             */\n            clickBehavior: {\n                /** What should happen if the user clicks on the control while the location is within the current view. */\n                inView: 'stop',\n                /** What should happen if the user clicks on the control while the location is outside the current view. */\n                outOfView: 'setView',\n            },\n            /** If set, a circle that shows the location accuracy is drawn. */\n            drawCircle: true,\n            /** If set, the marker at the users' location is drawn. */\n            drawMarker: true,\n            /** The class to be used to create the marker. For example L.CircleMarker or L.Marker */\n            markerClass: L.CircleMarker,\n            /** Accuracy circle style properties. */\n            circleStyle: {\n                color: '#136AEC',\n                fillColor: '#136AEC',\n                fillOpacity: 0.15,\n                weight: 2,\n                opacity: 0.5\n            },\n            /** Inner marker style properties. */\n            markerStyle: {\n                color: '#136AEC',\n                fillColor: '#2A93EE',\n                fillOpacity: 0.7,\n                weight: 2,\n                opacity: 0.9,\n                radius: 5\n            },\n            /**\n             * Changes to accuracy circle and inner marker while following.\n             * It is only necessary to provide the properties that should change.\n             */\n            followCircleStyle: {},\n            followMarkerStyle: {\n                // color: '#FFA500',\n                // fillColor: '#FFB000'\n            },\n            /** The CSS class for the icon. For example fa-location-arrow or fa-map-marker */\n            icon: 'fa fa-map-marker',\n            iconLoading: 'fa fa-spinner fa-spin',\n            /** The element to be created for icons. For example span or i */\n            iconElementTag: 'span',\n            /** Padding around the accuracy circle. */\n            circlePadding: [0, 0],\n            /** Use metric units. */\n            metric: true,\n            /** This event is called in case of any location error that is not a time out error. */\n            onLocationError: function(err, control) {\n                alert(err.message);\n            },\n            /**\n             * This even is called when the user's location is outside the bounds set on the map.\n             * The event is called repeatedly when the location changes.\n             */\n            onLocationOutsideMapBounds: function(control) {\n                control.stop();\n                alert(control.options.strings.outsideMapBoundsMsg);\n            },\n            /** Display a pop-up when the user click on the inner marker. */\n            showPopup: true,\n            strings: {\n                title: \"Show me where I am\",\n                metersUnit: \"meters\",\n                feetUnit: \"feet\",\n                popup: \"You are within {distance} {unit} from this point\",\n                outsideMapBoundsMsg: \"You seem located outside the boundaries of the map\"\n            },\n            /** The default options passed to leaflets locate method. */\n            locateOptions: {\n                maxZoom: Infinity,\n                watch: true,  // if you overwrite this, visualization cannot be updated\n                setView: false // have to set this to false because we have to\n                               // do setView manually\n            }\n        },\n\n        initialize: function (options) {\n            // set default options if nothing is set (merge one step deep)\n            for (var i in options) {\n                if (typeof this.options[i] === 'object') {\n                    L.extend(this.options[i], options[i]);\n                } else {\n                    this.options[i] = options[i];\n                }\n            }\n\n            // extend the follow marker style and circle from the normal style\n            this.options.followMarkerStyle = L.extend({}, this.options.markerStyle, this.options.followMarkerStyle);\n            this.options.followCircleStyle = L.extend({}, this.options.circleStyle, this.options.followCircleStyle);\n        },\n\n        /**\n         * Add control to map. Returns the container for the control.\n         */\n        onAdd: function (map) {\n            var container = L.DomUtil.create('div',\n                'leaflet-control-locate leaflet-bar leaflet-control');\n\n            this._layer = this.options.layer || new L.LayerGroup();\n            this._layer.addTo(map);\n            this._event = undefined;\n\n            this._link = L.DomUtil.create('a', 'leaflet-bar-part leaflet-bar-part-single', container);\n            this._link.href = '#';\n            this._link.title = this.options.strings.title;\n            this._icon = L.DomUtil.create(this.options.iconElementTag, this.options.icon, this._link);\n\n            L.DomEvent\n                .on(this._link, 'click', L.DomEvent.stopPropagation)\n                .on(this._link, 'click', L.DomEvent.preventDefault)\n                .on(this._link, 'click', this._onClick, this)\n                .on(this._link, 'dblclick', L.DomEvent.stopPropagation);\n\n            this._resetVariables();\n\n            this._map.on('unload', this._unload, this);\n\n            return container;\n        },\n\n        /**\n         * This method is called when the user clicks on the control.\n         */\n        _onClick: function() {\n            this._justClicked = true;\n            this._userPanned = false;\n\n            if (this._active && !this._event) {\n                // click while requesting\n                this.stop();\n            } else if (this._active && this._event !== undefined) {\n                var behavior = this._map.getBounds().contains(this._event.latlng) ?\n                    this.options.clickBehavior.inView : this.options.clickBehavior.outOfView;\n                switch (behavior) {\n                    case 'setView':\n                        this.setView();\n                        break;\n                    case 'stop':\n                        this.stop();\n                        break;\n                }\n            } else {\n                this.start();\n            }\n\n            this._updateContainerStyle();\n        },\n\n        /**\n         * Starts the plugin:\n         * - activates the engine\n         * - draws the marker (if coordinates available)\n         */\n        start: function() {\n            this._activate();\n\n            if (this._event) {\n                this._drawMarker(this._map);\n\n                // if we already have a location but the user clicked on the control\n                if (this.options.setView) {\n                    this.setView();\n                }\n            }\n            this._updateContainerStyle();\n        },\n\n        /**\n         * Stops the plugin:\n         * - deactivates the engine\n         * - reinitializes the button\n         * - removes the marker\n         */\n        stop: function() {\n            this._deactivate();\n\n            this._cleanClasses();\n            this._resetVariables();\n\n            this._removeMarker();\n        },\n\n        /**\n         * This method launches the location engine.\n         * It is called before the marker is updated,\n         * event if it does not mean that the event will be ready.\n         *\n         * Override it if you want to add more functionalities.\n         * It should set the this._active to true and do nothing if\n         * this._active is true.\n         */\n        _activate: function() {\n            if (!this._active) {\n                this._map.locate(this.options.locateOptions);\n                this._active = true;\n\n                // bind event listeners\n                this._map.on('locationfound', this._onLocationFound, this);\n                this._map.on('locationerror', this._onLocationError, this);\n                this._map.on('dragstart', this._onDrag, this);\n            }\n        },\n\n        /**\n         * Called to stop the location engine.\n         *\n         * Override it to shutdown any functionalities you added on start.\n         */\n        _deactivate: function() {\n            this._map.stopLocate();\n            this._active = false;\n\n            // unbind event listeners\n            this._map.off('locationfound', this._onLocationFound, this);\n            this._map.off('locationerror', this._onLocationError, this);\n            this._map.off('dragstart', this._onDrag, this);\n        },\n\n        /**\n         * Zoom (unless we should keep the zoom level) and an to the current view.\n         */\n        setView: function() {\n            if (this._isOutsideMapBounds()) {\n                this.options.onLocationOutsideMapBounds(this);\n            } else {\n                if (this.options.keepCurrentZoomLevel) {\n                    this._map.panTo([this._event.latitude, this._event.longitude]);\n                } else {\n                    this._map.fitBounds(this._event.bounds, {\n                        padding: this.options.circlePadding,\n                        maxZoom: this.options.locateOptions.maxZoom\n                    });\n                }\n            }\n            this._drawMarker();\n        },\n\n        /**\n         * Draw the marker and accuracy circle on the map.\n         *\n         * Uses the event retrieved from onLocationFound from the map.\n         */\n        _drawMarker: function() {\n            if (this._event.accuracy === undefined) {\n                this._event.accuracy = 0;\n            }\n\n            var radius = this._event.accuracy;\n            var latlng = this._event.latlng;\n\n            // circle with the radius of the location's accuracy\n            if (this.options.drawCircle) {\n                var style = this._isFollowing() ? this.options.followCircleStyle : this.options.circleStyle;\n\n                if (!this._circle) {\n                    this._circle = L.circle(latlng, radius, style).addTo(this._layer);\n                } else {\n                    this._circle.setLatLng(latlng).setRadius(radius).setStyle(style);\n                }\n            }\n\n            var distance, unit;\n            if (this.options.metric) {\n                distance = radius.toFixed(0);\n                unit =  this.options.strings.metersUnit;\n            } else {\n                distance = (radius * 3.2808399).toFixed(0);\n                unit = this.options.strings.feetUnit;\n            }\n\n            // small inner marker\n            if (this.options.drawMarker) {\n                var mStyle = this._isFollowing() ? this.options.followMarkerStyle : this.options.markerStyle;\n\n                if (!this._marker) {\n                    this._marker = new this.options.markerClass(latlng, mStyle).addTo(this._layer);\n                } else {\n                    this._marker.setLatLng(latlng).setStyle(mStyle);\n                }\n            }\n\n            var t = this.options.strings.popup;\n            if (this.options.showPopup && t && this._marker) {\n                this._marker\n                    .bindPopup(L.Util.template(t, {distance: distance, unit: unit}))\n                    ._popup.setLatLng(latlng);\n            }\n        },\n\n        /**\n         * Remove the marker from map.\n         */\n        _removeMarker: function() {\n            this._layer.clearLayers();\n            this._marker = undefined;\n            this._circle = undefined;\n        },\n\n        /**\n         * Unload the plugin and all event listeners.\n         * Kind of the opposite of onAdd.\n         */\n        _unload: function() {\n            this.stop();\n            this._map.off('unload', this._unload, this);\n        },\n\n        /**\n         * Calls deactivate and dispatches an error.\n         */\n        _onLocationError: function(err) {\n            // ignore time out error if the location is watched\n            if (err.code == 3 && this.options.locateOptions.watch) {\n                return;\n            }\n\n            this.stop();\n            this.options.onLocationError(err, this);\n        },\n\n        /**\n         * Stores the received event and updates the marker.\n         */\n        _onLocationFound: function(e) {\n            // no need to do anything if the location has not changed\n            if (this._event &&\n                (this._event.latlng.lat === e.latlng.lat &&\n                 this._event.latlng.lng === e.latlng.lng &&\n                     this._event.accuracy === e.accuracy)) {\n                return;\n            }\n\n            if (!this._active) {\n                // we may have a stray event\n                return;\n            }\n\n            this._event = e;\n\n            this._drawMarker();\n            this._updateContainerStyle();\n\n            switch (this.options.setView) {\n                case 'once':\n                    if (this._justClicked) {\n                        this.setView();\n                    }\n                    break;\n                case 'untilPan':\n                    if (!this._userPanned) {\n                        this.setView();\n                    }\n                    break;\n                case 'always':\n                    this.setView();\n                    break;\n                case false:\n                    // don't set the view\n                    break;\n            }\n\n            this._justClicked = false;\n        },\n\n        /**\n         * When the user drags. Need a separate even so we can bind and unbind even listeners.\n         */\n        _onDrag: function() {\n            // only react to drags once we have a location\n            if (this._event) {\n                this._userPanned = true;\n                this._updateContainerStyle();\n                this._drawMarker();\n            }\n        },\n\n        /**\n         * Compute whether the map is following the user location with pan and zoom.\n         */\n        _isFollowing: function() {\n            if (!this._active) {\n                return false;\n            }\n\n            if (this.options.setView === 'always') {\n                return true;\n            } else if (this.options.setView === 'untilPan') {\n                return !this._userPanned;\n            }\n        },\n\n        /**\n         * Check if location is in map bounds\n         */\n        _isOutsideMapBounds: function() {\n            if (this._event === undefined) {\n                return false;\n            }\n            return this._map.options.maxBounds &&\n                !this._map.options.maxBounds.contains(this._event.latlng);\n        },\n\n        /**\n         * Toggles button class between following and active.\n         */\n        _updateContainerStyle: function() {\n            if (!this._container) {\n                return;\n            }\n\n            if (this._active && !this._event) {\n                // active but don't have a location yet\n                this._setClasses('requesting');\n            } else if (this._isFollowing()) {\n                this._setClasses('following');\n            } else if (this._active) {\n                this._setClasses('active');\n            } else {\n                this._cleanClasses();\n            }\n        },\n\n        /**\n         * Sets the CSS classes for the state.\n         */\n        _setClasses: function(state) {\n            if (state == 'requesting') {\n                L.DomUtil.removeClasses(this._container, \"active following\");\n                L.DomUtil.addClasses(this._container, \"requesting\");\n\n                L.DomUtil.removeClasses(this._icon, this.options.icon);\n                L.DomUtil.addClasses(this._icon, this.options.iconLoading);\n            } else if (state == 'active') {\n                L.DomUtil.removeClasses(this._container, \"requesting following\");\n                L.DomUtil.addClasses(this._container, \"active\");\n\n                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);\n                L.DomUtil.addClasses(this._icon, this.options.icon);\n            } else if (state == 'following') {\n                L.DomUtil.removeClasses(this._container, \"requesting\");\n                L.DomUtil.addClasses(this._container, \"active following\");\n\n                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);\n                L.DomUtil.addClasses(this._icon, this.options.icon);\n            }\n        },\n\n        /**\n         * Removes all classes from button.\n         */\n        _cleanClasses: function() {\n            L.DomUtil.removeClass(this._container, \"requesting\");\n            L.DomUtil.removeClass(this._container, \"active\");\n            L.DomUtil.removeClass(this._container, \"following\");\n\n            L.DomUtil.removeClasses(this._icon, this.options.iconLoading);\n            L.DomUtil.addClasses(this._icon, this.options.icon);\n        },\n\n        /**\n         * Reinitializes state variables.\n         */\n        _resetVariables: function() {\n            // whether locate is active or not\n            this._active = false;\n\n            // true if the control was clicked for the first time\n            // we need this so we can pan and zoom once we have the location\n            this._justClicked = false;\n\n            // true if the user has panned the map after clicking the control\n            this._userPanned = false;\n        }\n    });\n\n    L.control.locate = function (options) {\n        return new L.Control.Locate(options);\n    };\n\n    (function(){\n      // leaflet.js raises bug when trying to addClass / removeClass multiple classes at once\n      // Let's create a wrapper on it which fixes it.\n      var LDomUtilApplyClassesMethod = function(method, element, classNames) {\n        classNames = classNames.split(' ');\n        classNames.forEach(function(className) {\n            L.DomUtil[method].call(this, element, className);\n        });\n      };\n\n      L.DomUtil.addClasses = function(el, names) { LDomUtilApplyClassesMethod('addClass', el, names); };\n      L.DomUtil.removeClasses = function(el, names) { LDomUtilApplyClassesMethod('removeClass', el, names); };\n    })();\n\n    return LocateControl;\n}, window));\n\n},{\"leaflet\":3}],5:[function(require,module,exports){\n/*\n Leaflet 1.0.0-beta.2 (55fe462), a JS library for interactive maps. http://leafletjs.com\n (c) 2010-2015 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n*/\n(function (window, document, undefined) {\r\nvar L = {\r\n\tversion: '1.0.0-beta.2'\r\n};\r\n\r\nfunction expose() {\r\n\tvar oldL = window.L;\r\n\r\n\tL.noConflict = function () {\r\n\t\twindow.L = oldL;\r\n\t\treturn this;\r\n\t};\r\n\r\n\twindow.L = L;\r\n}\r\n\r\n// define Leaflet for Node module pattern loaders, including Browserify\r\nif (typeof module === 'object' && typeof module.exports === 'object') {\r\n\tmodule.exports = L;\r\n\r\n// define Leaflet as an AMD module\r\n} else if (typeof define === 'function' && define.amd) {\r\n\tdefine(L);\r\n}\r\n\r\n// define Leaflet as a global L variable, saving the original L to restore later if needed\r\nif (typeof window !== 'undefined') {\r\n\texpose();\r\n}\r\n\n\n\n/*\r\n * L.Util contains various utility functions used throughout Leaflet code.\r\n */\r\n\r\nL.Util = {\r\n\t// extend an object with properties of one or more other objects\r\n\textend: function (dest) {\r\n\t\tvar i, j, len, src;\r\n\r\n\t\tfor (j = 1, len = arguments.length; j < len; j++) {\r\n\t\t\tsrc = arguments[j];\r\n\t\t\tfor (i in src) {\r\n\t\t\t\tdest[i] = src[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dest;\r\n\t},\r\n\r\n\t// create an object from a given prototype\r\n\tcreate: Object.create || (function () {\r\n\t\tfunction F() {}\r\n\t\treturn function (proto) {\r\n\t\t\tF.prototype = proto;\r\n\t\t\treturn new F();\r\n\t\t};\r\n\t})(),\r\n\r\n\t// bind a function to be called with a given context\r\n\tbind: function (fn, obj) {\r\n\t\tvar slice = Array.prototype.slice;\r\n\r\n\t\tif (fn.bind) {\r\n\t\t\treturn fn.bind.apply(fn, slice.call(arguments, 1));\r\n\t\t}\r\n\r\n\t\tvar args = slice.call(arguments, 2);\r\n\r\n\t\treturn function () {\r\n\t\t\treturn fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\r\n\t\t};\r\n\t},\r\n\r\n\t// return unique ID of an object\r\n\tstamp: function (obj) {\r\n\t\t/*eslint-disable */\r\n\t\tobj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;\r\n\t\treturn obj._leaflet_id;\r\n\t\t/*eslint-enable */\r\n\t},\r\n\r\n\tlastId: 0,\r\n\r\n\t// return a function that won't be called more often than the given interval\r\n\tthrottle: function (fn, time, context) {\r\n\t\tvar lock, args, wrapperFn, later;\r\n\r\n\t\tlater = function () {\r\n\t\t\t// reset lock and call if queued\r\n\t\t\tlock = false;\r\n\t\t\tif (args) {\r\n\t\t\t\twrapperFn.apply(context, args);\r\n\t\t\t\targs = false;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\twrapperFn = function () {\r\n\t\t\tif (lock) {\r\n\t\t\t\t// called too soon, queue to call later\r\n\t\t\t\targs = arguments;\r\n\r\n\t\t\t} else {\r\n\t\t\t\t// call and lock until later\r\n\t\t\t\tfn.apply(context, arguments);\r\n\t\t\t\tsetTimeout(later, time);\r\n\t\t\t\tlock = true;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\treturn wrapperFn;\r\n\t},\r\n\r\n\t// wrap the given number to lie within a certain range (used for wrapping longitude)\r\n\twrapNum: function (x, range, includeMax) {\r\n\t\tvar max = range[1],\r\n\t\t    min = range[0],\r\n\t\t    d = max - min;\r\n\t\treturn x === max && includeMax ? x : ((x - min) % d + d) % d + min;\r\n\t},\r\n\r\n\t// do nothing (used as a noop throughout the code)\r\n\tfalseFn: function () { return false; },\r\n\r\n\t// round a given number to a given precision\r\n\tformatNum: function (num, digits) {\r\n\t\tvar pow = Math.pow(10, digits || 5);\r\n\t\treturn Math.round(num * pow) / pow;\r\n\t},\r\n\r\n\t// trim whitespace from both sides of a string\r\n\ttrim: function (str) {\r\n\t\treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n\t},\r\n\r\n\t// split a string into words\r\n\tsplitWords: function (str) {\r\n\t\treturn L.Util.trim(str).split(/\\s+/);\r\n\t},\r\n\r\n\t// set options to an object, inheriting parent's options as well\r\n\tsetOptions: function (obj, options) {\r\n\t\tif (!obj.hasOwnProperty('options')) {\r\n\t\t\tobj.options = obj.options ? L.Util.create(obj.options) : {};\r\n\t\t}\r\n\t\tfor (var i in options) {\r\n\t\t\tobj.options[i] = options[i];\r\n\t\t}\r\n\t\treturn obj.options;\r\n\t},\r\n\r\n\t// make a URL with GET parameters out of a set of properties/values\r\n\tgetParamString: function (obj, existingUrl, uppercase) {\r\n\t\tvar params = [];\r\n\t\tfor (var i in obj) {\r\n\t\t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n\t\t}\r\n\t\treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n\t},\r\n\r\n\t// super-simple templating facility, used for TileLayer URLs\r\n\ttemplate: function (str, data) {\r\n\t\treturn str.replace(L.Util.templateRe, function (str, key) {\r\n\t\t\tvar value = data[key];\r\n\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tthrow new Error('No value provided for variable ' + str);\r\n\r\n\t\t\t} else if (typeof value === 'function') {\r\n\t\t\t\tvalue = value(data);\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t});\r\n\t},\r\n\r\n\ttemplateRe: /\\{ *([\\w_]+) *\\}/g,\r\n\r\n\tisArray: Array.isArray || function (obj) {\r\n\t\treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n\t},\r\n\r\n\tindexOf: function (array, el) {\r\n\t\tfor (var i = 0; i < array.length; i++) {\r\n\t\t\tif (array[i] === el) { return i; }\r\n\t\t}\r\n\t\treturn -1;\r\n\t},\r\n\r\n\t// minimal image URI, set to an image when disposing to flush memory\r\n\temptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\r\n};\r\n\r\n(function () {\r\n\t// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n\tfunction getPrefixed(name) {\r\n\t\treturn window['webkit' + name] || window['moz' + name] || window['ms' + name];\r\n\t}\r\n\r\n\tvar lastTime = 0;\r\n\r\n\t// fallback for IE 7-8\r\n\tfunction timeoutDefer(fn) {\r\n\t\tvar time = +new Date(),\r\n\t\t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n\t\tlastTime = time + timeToCall;\r\n\t\treturn window.setTimeout(fn, timeToCall);\r\n\t}\r\n\r\n\tvar requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,\r\n\t    cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||\r\n\t               getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };\r\n\r\n\r\n\tL.Util.requestAnimFrame = function (fn, context, immediate) {\r\n\t\tif (immediate && requestFn === timeoutDefer) {\r\n\t\t\tfn.call(context);\r\n\t\t} else {\r\n\t\t\treturn requestFn.call(window, L.bind(fn, context));\r\n\t\t}\r\n\t};\r\n\r\n\tL.Util.cancelAnimFrame = function (id) {\r\n\t\tif (id) {\r\n\t\t\tcancelFn.call(window, id);\r\n\t\t}\r\n\t};\r\n})();\r\n\r\n// shortcuts for most used utility functions\r\nL.extend = L.Util.extend;\r\nL.bind = L.Util.bind;\r\nL.stamp = L.Util.stamp;\r\nL.setOptions = L.Util.setOptions;\r\n\n\n\n/*\r\n * L.Class powers the OOP facilities of the library.\r\n * Thanks to John Resig and Dean Edwards for inspiration!\r\n */\r\n\r\nL.Class = function () {};\r\n\r\nL.Class.extend = function (props) {\r\n\r\n\t// extended class with the new prototype\r\n\tvar NewClass = function () {\r\n\r\n\t\t// call the constructor\r\n\t\tif (this.initialize) {\r\n\t\t\tthis.initialize.apply(this, arguments);\r\n\t\t}\r\n\r\n\t\t// call all constructor hooks\r\n\t\tthis.callInitHooks();\r\n\t};\r\n\r\n\tvar parentProto = NewClass.__super__ = this.prototype;\r\n\r\n\tvar proto = L.Util.create(parentProto);\r\n\tproto.constructor = NewClass;\r\n\r\n\tNewClass.prototype = proto;\r\n\r\n\t// inherit parent's statics\r\n\tfor (var i in this) {\r\n\t\tif (this.hasOwnProperty(i) && i !== 'prototype') {\r\n\t\t\tNewClass[i] = this[i];\r\n\t\t}\r\n\t}\r\n\r\n\t// mix static properties into the class\r\n\tif (props.statics) {\r\n\t\tL.extend(NewClass, props.statics);\r\n\t\tdelete props.statics;\r\n\t}\r\n\r\n\t// mix includes into the prototype\r\n\tif (props.includes) {\r\n\t\tL.Util.extend.apply(null, [proto].concat(props.includes));\r\n\t\tdelete props.includes;\r\n\t}\r\n\r\n\t// merge options\r\n\tif (proto.options) {\r\n\t\tprops.options = L.Util.extend(L.Util.create(proto.options), props.options);\r\n\t}\r\n\r\n\t// mix given properties into the prototype\r\n\tL.extend(proto, props);\r\n\r\n\tproto._initHooks = [];\r\n\r\n\t// add method for calling all hooks\r\n\tproto.callInitHooks = function () {\r\n\r\n\t\tif (this._initHooksCalled) { return; }\r\n\r\n\t\tif (parentProto.callInitHooks) {\r\n\t\t\tparentProto.callInitHooks.call(this);\r\n\t\t}\r\n\r\n\t\tthis._initHooksCalled = true;\r\n\r\n\t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n\t\t\tproto._initHooks[i].call(this);\r\n\t\t}\r\n\t};\r\n\r\n\treturn NewClass;\r\n};\r\n\r\n\r\n// method for adding properties to prototype\r\nL.Class.include = function (props) {\r\n\tL.extend(this.prototype, props);\r\n};\r\n\r\n// merge new default options to the Class\r\nL.Class.mergeOptions = function (options) {\r\n\tL.extend(this.prototype.options, options);\r\n};\r\n\r\n// add a constructor hook\r\nL.Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n\tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n\tvar init = typeof fn === 'function' ? fn : function () {\r\n\t\tthis[fn].apply(this, args);\r\n\t};\r\n\r\n\tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n\tthis.prototype._initHooks.push(init);\r\n};\r\n\n\n\n/*\r\n * L.Evented is a base class that Leaflet classes inherit from to handle custom events.\r\n */\r\n\r\nL.Evented = L.Class.extend({\r\n\r\n\ton: function (types, fn, context) {\r\n\r\n\t\t// types can be a map of types/handlers\r\n\t\tif (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\t// we don't process space-separated events here for performance;\r\n\t\t\t\t// it's a hot path since Layer uses the on(obj) syntax\r\n\t\t\t\tthis._on(type, types[type], fn);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\t// types can be a string of space-separated words\r\n\t\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\tthis._on(types[i], fn, context);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\toff: function (types, fn, context) {\r\n\r\n\t\tif (!types) {\r\n\t\t\t// clear all listeners if called without arguments\r\n\t\t\tdelete this._events;\r\n\r\n\t\t} else if (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\tthis._off(type, types[type], fn);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\tthis._off(types[i], fn, context);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// attach listener (without syntactic sugar now)\r\n\t_on: function (type, fn, context) {\r\n\r\n\t\tvar events = this._events = this._events || {},\r\n\t\t    contextId = context && context !== this && L.stamp(context);\r\n\r\n\t\tif (contextId) {\r\n\t\t\t// store listeners with custom context in a separate hash (if it has an id);\r\n\t\t\t// gives a major performance boost when firing and removing events (e.g. on map object)\r\n\r\n\t\t\tvar indexKey = type + '_idx',\r\n\t\t\t    indexLenKey = type + '_len',\r\n\t\t\t    typeIndex = events[indexKey] = events[indexKey] || {},\r\n\t\t\t    id = L.stamp(fn) + '_' + contextId;\r\n\r\n\t\t\tif (!typeIndex[id]) {\r\n\t\t\t\ttypeIndex[id] = {fn: fn, ctx: context};\r\n\r\n\t\t\t\t// keep track of the number of keys in the index to quickly check if it's empty\r\n\t\t\t\tevents[indexLenKey] = (events[indexLenKey] || 0) + 1;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\t// individual layers mostly use \"this\" for context and don't fire listeners too often\r\n\t\t\t// so simple array makes the memory footprint better while not degrading performance\r\n\r\n\t\t\tevents[type] = events[type] || [];\r\n\t\t\tevents[type].push({fn: fn});\r\n\t\t}\r\n\t},\r\n\r\n\t_off: function (type, fn, context) {\r\n\t\tvar events = this._events,\r\n\t\t    indexKey = type + '_idx',\r\n\t\t    indexLenKey = type + '_len';\r\n\r\n\t\tif (!events) { return; }\r\n\r\n\t\tif (!fn) {\r\n\t\t\t// clear all listeners for a type if function isn't specified\r\n\t\t\tdelete events[type];\r\n\t\t\tdelete events[indexKey];\r\n\t\t\tdelete events[indexLenKey];\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar contextId = context && context !== this && L.stamp(context),\r\n\t\t    listeners, i, len, listener, id;\r\n\r\n\t\tif (contextId) {\r\n\t\t\tid = L.stamp(fn) + '_' + contextId;\r\n\t\t\tlisteners = events[indexKey];\r\n\r\n\t\t\tif (listeners && listeners[id]) {\r\n\t\t\t\tlistener = listeners[id];\r\n\t\t\t\tdelete listeners[id];\r\n\t\t\t\tevents[indexLenKey]--;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tlisteners = events[type];\r\n\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tif (listeners[i].fn === fn) {\r\n\t\t\t\t\t\tlistener = listeners[i];\r\n\t\t\t\t\t\tlisteners.splice(i, 1);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// set the removed listener to noop so that's not called if remove happens in fire\r\n\t\tif (listener) {\r\n\t\t\tlistener.fn = L.Util.falseFn;\r\n\t\t}\r\n\t},\r\n\r\n\tfire: function (type, data, propagate) {\r\n\t\tif (!this.listens(type, propagate)) { return this; }\r\n\r\n\t\tvar event = L.Util.extend({}, data, {type: type, target: this}),\r\n\t\t    events = this._events;\r\n\r\n\t\tif (events) {\r\n\t\t\tvar typeIndex = events[type + '_idx'],\r\n\t\t\t    i, len, listeners, id;\r\n\r\n\t\t\tif (events[type]) {\r\n\t\t\t\t// make sure adding/removing listeners inside other listeners won't cause infinite loop\r\n\t\t\t\tlisteners = events[type].slice();\r\n\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tlisteners[i].fn.call(this, event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// fire event for the context-indexed listeners as well\r\n\t\t\tfor (id in typeIndex) {\r\n\t\t\t\ttypeIndex[id].fn.call(typeIndex[id].ctx, event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (propagate) {\r\n\t\t\t// propagate the event to parents (set with addEventParent)\r\n\t\t\tthis._propagateEvent(event);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tlistens: function (type, propagate) {\r\n\t\tvar events = this._events;\r\n\r\n\t\tif (events && (events[type] || events[type + '_len'])) { return true; }\r\n\r\n\t\tif (propagate) {\r\n\t\t\t// also check parents for listeners if event propagates\r\n\t\t\tfor (var id in this._eventParents) {\r\n\t\t\t\tif (this._eventParents[id].listens(type, propagate)) { return true; }\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tonce: function (types, fn, context) {\r\n\r\n\t\tif (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\tthis.once(type, types[type], fn);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar handler = L.bind(function () {\r\n\t\t\tthis\r\n\t\t\t    .off(types, fn, context)\r\n\t\t\t    .off(types, handler, context);\r\n\t\t}, this);\r\n\r\n\t\t// add a listener that's executed once and removed after that\r\n\t\treturn this\r\n\t\t    .on(types, fn, context)\r\n\t\t    .on(types, handler, context);\r\n\t},\r\n\r\n\t// adds a parent to propagate events to (when you fire with true as a 3rd argument)\r\n\taddEventParent: function (obj) {\r\n\t\tthis._eventParents = this._eventParents || {};\r\n\t\tthis._eventParents[L.stamp(obj)] = obj;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveEventParent: function (obj) {\r\n\t\tif (this._eventParents) {\r\n\t\t\tdelete this._eventParents[L.stamp(obj)];\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_propagateEvent: function (e) {\r\n\t\tfor (var id in this._eventParents) {\r\n\t\t\tthis._eventParents[id].fire(e.type, L.extend({layer: e.target}, e), true);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar proto = L.Evented.prototype;\r\n\r\n// aliases; we should ditch those eventually\r\nproto.addEventListener = proto.on;\r\nproto.removeEventListener = proto.clearAllEventListeners = proto.off;\r\nproto.addOneTimeEventListener = proto.once;\r\nproto.fireEvent = proto.fire;\r\nproto.hasEventListeners = proto.listens;\r\n\r\nL.Mixin = {Events: proto};\r\n\n\n\n/*\r\n * L.Browser handles different browser and feature detections for internal Leaflet use.\r\n */\r\n\r\n(function () {\r\n\r\n\tvar ua = navigator.userAgent.toLowerCase(),\r\n\t    doc = document.documentElement,\r\n\r\n\t    ie = 'ActiveXObject' in window,\r\n\r\n\t    webkit    = ua.indexOf('webkit') !== -1,\r\n\t    phantomjs = ua.indexOf('phantom') !== -1,\r\n\t    android23 = ua.search('android [23]') !== -1,\r\n\t    chrome    = ua.indexOf('chrome') !== -1,\r\n\t    gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,\r\n\r\n\t    mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,\r\n\t    msPointer = !window.PointerEvent && window.MSPointerEvent,\r\n\t    pointer = (window.PointerEvent && navigator.pointerEnabled) || msPointer,\r\n\r\n\t    ie3d = ie && ('transition' in doc.style),\r\n\t    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,\r\n\t    gecko3d = 'MozPerspective' in doc.style,\r\n\t    opera12 = 'OTransition' in doc.style;\r\n\r\n\tvar touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||\r\n\t\t\t(window.DocumentTouch && document instanceof window.DocumentTouch));\r\n\r\n\tL.Browser = {\r\n\t\tie: ie,\r\n\t\tielt9: ie && !document.addEventListener,\r\n\t\twebkit: webkit,\r\n\t\tgecko: gecko,\r\n\t\tandroid: ua.indexOf('android') !== -1,\r\n\t\tandroid23: android23,\r\n\t\tchrome: chrome,\r\n\t\tsafari: !chrome && ua.indexOf('safari') !== -1,\r\n\r\n\t\tie3d: ie3d,\r\n\t\twebkit3d: webkit3d,\r\n\t\tgecko3d: gecko3d,\r\n\t\topera12: opera12,\r\n\t\tany3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,\r\n\r\n\t\tmobile: mobile,\r\n\t\tmobileWebkit: mobile && webkit,\r\n\t\tmobileWebkit3d: mobile && webkit3d,\r\n\t\tmobileOpera: mobile && window.opera,\r\n\t\tmobileGecko: mobile && gecko,\r\n\r\n\t\ttouch: !!touch,\r\n\t\tmsPointer: !!msPointer,\r\n\t\tpointer: !!pointer,\r\n\r\n\t\tretina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1\r\n\t};\r\n\r\n}());\r\n\n\n\n/*\r\n * L.Point represents a point with x and y coordinates.\r\n */\r\n\r\nL.Point = function (x, y, round) {\r\n\tthis.x = (round ? Math.round(x) : x);\r\n\tthis.y = (round ? Math.round(y) : y);\r\n};\r\n\r\nL.Point.prototype = {\r\n\r\n\tclone: function () {\r\n\t\treturn new L.Point(this.x, this.y);\r\n\t},\r\n\r\n\t// non-destructive, returns a new point\r\n\tadd: function (point) {\r\n\t\treturn this.clone()._add(L.point(point));\r\n\t},\r\n\r\n\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n\t_add: function (point) {\r\n\t\tthis.x += point.x;\r\n\t\tthis.y += point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsubtract: function (point) {\r\n\t\treturn this.clone()._subtract(L.point(point));\r\n\t},\r\n\r\n\t_subtract: function (point) {\r\n\t\tthis.x -= point.x;\r\n\t\tthis.y -= point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdivideBy: function (num) {\r\n\t\treturn this.clone()._divideBy(num);\r\n\t},\r\n\r\n\t_divideBy: function (num) {\r\n\t\tthis.x /= num;\r\n\t\tthis.y /= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tmultiplyBy: function (num) {\r\n\t\treturn this.clone()._multiplyBy(num);\r\n\t},\r\n\r\n\t_multiplyBy: function (num) {\r\n\t\tthis.x *= num;\r\n\t\tthis.y *= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tscaleBy: function (point) {\r\n\t\treturn new L.Point(this.x * point.x, this.y * point.y);\r\n\t},\r\n\r\n\tunscaleBy: function (point) {\r\n\t\treturn new L.Point(this.x / point.x, this.y / point.y);\r\n\t},\r\n\r\n\tround: function () {\r\n\t\treturn this.clone()._round();\r\n\t},\r\n\r\n\t_round: function () {\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfloor: function () {\r\n\t\treturn this.clone()._floor();\r\n\t},\r\n\r\n\t_floor: function () {\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tceil: function () {\r\n\t\treturn this.clone()._ceil();\r\n\t},\r\n\r\n\t_ceil: function () {\r\n\t\tthis.x = Math.ceil(this.x);\r\n\t\tthis.y = Math.ceil(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdistanceTo: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tvar x = point.x - this.x,\r\n\t\t    y = point.y - this.y;\r\n\r\n\t\treturn Math.sqrt(x * x + y * y);\r\n\t},\r\n\r\n\tequals: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn point.x === this.x &&\r\n\t\t       point.y === this.y;\r\n\t},\r\n\r\n\tcontains: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n\t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn 'Point(' +\r\n\t\t        L.Util.formatNum(this.x) + ', ' +\r\n\t\t        L.Util.formatNum(this.y) + ')';\r\n\t}\r\n};\r\n\r\nL.point = function (x, y, round) {\r\n\tif (x instanceof L.Point) {\r\n\t\treturn x;\r\n\t}\r\n\tif (L.Util.isArray(x)) {\r\n\t\treturn new L.Point(x[0], x[1]);\r\n\t}\r\n\tif (x === undefined || x === null) {\r\n\t\treturn x;\r\n\t}\r\n\treturn new L.Point(x, y, round);\r\n};\r\n\n\n\n/*\r\n * L.Bounds represents a rectangular area on the screen in pixel coordinates.\r\n */\r\n\r\nL.Bounds = function (a, b) { // (Point, Point) or Point[]\r\n\tif (!a) { return; }\r\n\r\n\tvar points = b ? [a, b] : a;\r\n\r\n\tfor (var i = 0, len = points.length; i < len; i++) {\r\n\t\tthis.extend(points[i]);\r\n\t}\r\n};\r\n\r\nL.Bounds.prototype = {\r\n\t// extend the bounds to contain the given point\r\n\textend: function (point) { // (Point)\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tif (!this.min && !this.max) {\r\n\t\t\tthis.min = point.clone();\r\n\t\t\tthis.max = point.clone();\r\n\t\t} else {\r\n\t\t\tthis.min.x = Math.min(point.x, this.min.x);\r\n\t\t\tthis.max.x = Math.max(point.x, this.max.x);\r\n\t\t\tthis.min.y = Math.min(point.y, this.min.y);\r\n\t\t\tthis.max.y = Math.max(point.y, this.max.y);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetCenter: function (round) { // (Boolean) -> Point\r\n\t\treturn new L.Point(\r\n\t\t        (this.min.x + this.max.x) / 2,\r\n\t\t        (this.min.y + this.max.y) / 2, round);\r\n\t},\r\n\r\n\tgetBottomLeft: function () { // -> Point\r\n\t\treturn new L.Point(this.min.x, this.max.y);\r\n\t},\r\n\r\n\tgetTopRight: function () { // -> Point\r\n\t\treturn new L.Point(this.max.x, this.min.y);\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\treturn this.max.subtract(this.min);\r\n\t},\r\n\r\n\tcontains: function (obj) { // (Bounds) or (Point) -> Boolean\r\n\t\tvar min, max;\r\n\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.Point) {\r\n\t\t\tobj = L.point(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.bounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.Bounds) {\r\n\t\t\tmin = obj.min;\r\n\t\t\tmax = obj.max;\r\n\t\t} else {\r\n\t\t\tmin = max = obj;\r\n\t\t}\r\n\r\n\t\treturn (min.x >= this.min.x) &&\r\n\t\t       (max.x <= this.max.x) &&\r\n\t\t       (min.y >= this.min.y) &&\r\n\t\t       (max.y <= this.max.y);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (Bounds) -> Boolean\r\n\t\tbounds = L.bounds(bounds);\r\n\r\n\t\tvar min = this.min,\r\n\t\t    max = this.max,\r\n\t\t    min2 = bounds.min,\r\n\t\t    max2 = bounds.max,\r\n\t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n\t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n\t\treturn xIntersects && yIntersects;\r\n\t},\r\n\r\n\toverlaps: function (bounds) { // (Bounds) -> Boolean\r\n\t\tbounds = L.bounds(bounds);\r\n\r\n\t\tvar min = this.min,\r\n\t\t    max = this.max,\r\n\t\t    min2 = bounds.min,\r\n\t\t    max2 = bounds.max,\r\n\t\t    xOverlaps = (max2.x > min.x) && (min2.x < max.x),\r\n\t\t    yOverlaps = (max2.y > min.y) && (min2.y < max.y);\r\n\r\n\t\treturn xOverlaps && yOverlaps;\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this.min && this.max);\r\n\t}\r\n};\r\n\r\nL.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])\r\n\tif (!a || a instanceof L.Bounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.Bounds(a, b);\r\n};\r\n\n\n\n/*\r\n * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\r\n */\r\n\r\nL.Transformation = function (a, b, c, d) {\r\n\tthis._a = a;\r\n\tthis._b = b;\r\n\tthis._c = c;\r\n\tthis._d = d;\r\n};\r\n\r\nL.Transformation.prototype = {\r\n\ttransform: function (point, scale) { // (Point, Number) -> Point\r\n\t\treturn this._transform(point.clone(), scale);\r\n\t},\r\n\r\n\t// destructive transform (faster)\r\n\t_transform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\tpoint.x = scale * (this._a * point.x + this._b);\r\n\t\tpoint.y = scale * (this._c * point.y + this._d);\r\n\t\treturn point;\r\n\t},\r\n\r\n\tuntransform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\treturn new L.Point(\r\n\t\t        (point.x / scale - this._b) / this._a,\r\n\t\t        (point.y / scale - this._d) / this._c);\r\n\t}\r\n};\r\n\n\n\n/*\r\n * L.DomUtil contains various utility functions for working with DOM.\r\n */\r\n\r\nL.DomUtil = {\r\n\tget: function (id) {\r\n\t\treturn typeof id === 'string' ? document.getElementById(id) : id;\r\n\t},\r\n\r\n\tgetStyle: function (el, style) {\r\n\r\n\t\tvar value = el.style[style] || (el.currentStyle && el.currentStyle[style]);\r\n\r\n\t\tif ((!value || value === 'auto') && document.defaultView) {\r\n\t\t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n\t\t\tvalue = css ? css[style] : null;\r\n\t\t}\r\n\r\n\t\treturn value === 'auto' ? null : value;\r\n\t},\r\n\r\n\tcreate: function (tagName, className, container) {\r\n\r\n\t\tvar el = document.createElement(tagName);\r\n\t\tel.className = className;\r\n\r\n\t\tif (container) {\r\n\t\t\tcontainer.appendChild(el);\r\n\t\t}\r\n\r\n\t\treturn el;\r\n\t},\r\n\r\n\tremove: function (el) {\r\n\t\tvar parent = el.parentNode;\r\n\t\tif (parent) {\r\n\t\t\tparent.removeChild(el);\r\n\t\t}\r\n\t},\r\n\r\n\tempty: function (el) {\r\n\t\twhile (el.firstChild) {\r\n\t\t\tel.removeChild(el.firstChild);\r\n\t\t}\r\n\t},\r\n\r\n\ttoFront: function (el) {\r\n\t\tel.parentNode.appendChild(el);\r\n\t},\r\n\r\n\ttoBack: function (el) {\r\n\t\tvar parent = el.parentNode;\r\n\t\tparent.insertBefore(el, parent.firstChild);\r\n\t},\r\n\r\n\thasClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\treturn el.classList.contains(name);\r\n\t\t}\r\n\t\tvar className = L.DomUtil.getClass(el);\r\n\t\treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n\t},\r\n\r\n\taddClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tvar classes = L.Util.splitWords(name);\r\n\t\t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n\t\t\t\tel.classList.add(classes[i]);\r\n\t\t\t}\r\n\t\t} else if (!L.DomUtil.hasClass(el, name)) {\r\n\t\t\tvar className = L.DomUtil.getClass(el);\r\n\t\t\tL.DomUtil.setClass(el, (className ? className + ' ' : '') + name);\r\n\t\t}\r\n\t},\r\n\r\n\tremoveClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tel.classList.remove(name);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n\t\t}\r\n\t},\r\n\r\n\tsetClass: function (el, name) {\r\n\t\tif (el.className.baseVal === undefined) {\r\n\t\t\tel.className = name;\r\n\t\t} else {\r\n\t\t\t// in case of SVG element\r\n\t\t\tel.className.baseVal = name;\r\n\t\t}\r\n\t},\r\n\r\n\tgetClass: function (el) {\r\n\t\treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n\t},\r\n\r\n\tsetOpacity: function (el, value) {\r\n\r\n\t\tif ('opacity' in el.style) {\r\n\t\t\tel.style.opacity = value;\r\n\r\n\t\t} else if ('filter' in el.style) {\r\n\t\t\tL.DomUtil._setOpacityIE(el, value);\r\n\t\t}\r\n\t},\r\n\r\n\t_setOpacityIE: function (el, value) {\r\n\t\tvar filter = false,\r\n\t\t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n\t\t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n\t\ttry {\r\n\t\t\tfilter = el.filters.item(filterName);\r\n\t\t} catch (e) {\r\n\t\t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n\t\t\t// it isn't needed and breaks transparent pngs.\r\n\t\t\tif (value === 1) { return; }\r\n\t\t}\r\n\r\n\t\tvalue = Math.round(value * 100);\r\n\r\n\t\tif (filter) {\r\n\t\t\tfilter.Enabled = (value !== 100);\r\n\t\t\tfilter.Opacity = value;\r\n\t\t} else {\r\n\t\t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n\t\t}\r\n\t},\r\n\r\n\ttestProp: function (props) {\r\n\r\n\t\tvar style = document.documentElement.style;\r\n\r\n\t\tfor (var i = 0; i < props.length; i++) {\r\n\t\t\tif (props[i] in style) {\r\n\t\t\t\treturn props[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tsetTransform: function (el, offset, scale) {\r\n\t\tvar pos = offset || new L.Point(0, 0);\r\n\r\n\t\tel.style[L.DomUtil.TRANSFORM] =\r\n\t\t\t(L.Browser.ie3d ?\r\n\t\t\t\t'translate(' + pos.x + 'px,' + pos.y + 'px)' :\r\n\t\t\t\t'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +\r\n\t\t\t(scale ? ' scale(' + scale + ')' : '');\r\n\t},\r\n\r\n\tsetPosition: function (el, point) { // (HTMLElement, Point[, Boolean])\r\n\r\n\t\t/*eslint-disable */\r\n\t\tel._leaflet_pos = point;\r\n\t\t/*eslint-enable */\r\n\r\n\t\tif (L.Browser.any3d) {\r\n\t\t\tL.DomUtil.setTransform(el, point);\r\n\t\t} else {\r\n\t\t\tel.style.left = point.x + 'px';\r\n\t\t\tel.style.top = point.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\tgetPosition: function (el) {\r\n\t\t// this method is only used for elements previously positioned using setPosition,\r\n\t\t// so it's safe to cache the position for performance\r\n\r\n\t\treturn el._leaflet_pos;\r\n\t}\r\n};\r\n\r\n\r\n(function () {\r\n\t// prefix style property names\r\n\r\n\tL.DomUtil.TRANSFORM = L.DomUtil.testProp(\r\n\t\t\t['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n\r\n\t// webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n\t// the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\n\tvar transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(\r\n\t\t\t['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\n\tL.DomUtil.TRANSITION_END =\r\n\t\t\ttransition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';\r\n\r\n\r\n\tif ('onselectstart' in document) {\r\n\t\tL.DomUtil.disableTextSelection = function () {\r\n\t\t\tL.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\r\n\t\t};\r\n\t\tL.DomUtil.enableTextSelection = function () {\r\n\t\t\tL.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\r\n\t\t};\r\n\r\n\t} else {\r\n\t\tvar userSelectProperty = L.DomUtil.testProp(\r\n\t\t\t['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n\t\tL.DomUtil.disableTextSelection = function () {\r\n\t\t\tif (userSelectProperty) {\r\n\t\t\t\tvar style = document.documentElement.style;\r\n\t\t\t\tthis._userSelect = style[userSelectProperty];\r\n\t\t\t\tstyle[userSelectProperty] = 'none';\r\n\t\t\t}\r\n\t\t};\r\n\t\tL.DomUtil.enableTextSelection = function () {\r\n\t\t\tif (userSelectProperty) {\r\n\t\t\t\tdocument.documentElement.style[userSelectProperty] = this._userSelect;\r\n\t\t\t\tdelete this._userSelect;\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tL.DomUtil.disableImageDrag = function () {\r\n\t\tL.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t};\r\n\tL.DomUtil.enableImageDrag = function () {\r\n\t\tL.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t};\r\n\r\n\tL.DomUtil.preventOutline = function (element) {\r\n\t\twhile (element.tabIndex === -1) {\r\n\t\t\telement = element.parentNode;\r\n\t\t}\r\n\t\tif (!element || !element.style) { return; }\r\n\t\tL.DomUtil.restoreOutline();\r\n\t\tthis._outlineElement = element;\r\n\t\tthis._outlineStyle = element.style.outline;\r\n\t\telement.style.outline = 'none';\r\n\t\tL.DomEvent.on(window, 'keydown', L.DomUtil.restoreOutline, this);\r\n\t};\r\n\tL.DomUtil.restoreOutline = function () {\r\n\t\tif (!this._outlineElement) { return; }\r\n\t\tthis._outlineElement.style.outline = this._outlineStyle;\r\n\t\tdelete this._outlineElement;\r\n\t\tdelete this._outlineStyle;\r\n\t\tL.DomEvent.off(window, 'keydown', L.DomUtil.restoreOutline, this);\r\n\t};\r\n})();\r\n\n\n\n/*\r\n * L.LatLng represents a geographical point with latitude and longitude coordinates.\r\n */\r\n\r\nL.LatLng = function (lat, lng, alt) {\r\n\tif (isNaN(lat) || isNaN(lng)) {\r\n\t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n\t}\r\n\r\n\tthis.lat = +lat;\r\n\tthis.lng = +lng;\r\n\r\n\tif (alt !== undefined) {\r\n\t\tthis.alt = +alt;\r\n\t}\r\n};\r\n\r\nL.LatLng.prototype = {\r\n\tequals: function (obj, maxMargin) {\r\n\t\tif (!obj) { return false; }\r\n\r\n\t\tobj = L.latLng(obj);\r\n\r\n\t\tvar margin = Math.max(\r\n\t\t        Math.abs(this.lat - obj.lat),\r\n\t\t        Math.abs(this.lng - obj.lng));\r\n\r\n\t\treturn margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\r\n\t},\r\n\r\n\ttoString: function (precision) {\r\n\t\treturn 'LatLng(' +\r\n\t\t        L.Util.formatNum(this.lat, precision) + ', ' +\r\n\t\t        L.Util.formatNum(this.lng, precision) + ')';\r\n\t},\r\n\r\n\tdistanceTo: function (other) {\r\n\t\treturn L.CRS.Earth.distance(this, L.latLng(other));\r\n\t},\r\n\r\n\twrap: function () {\r\n\t\treturn L.CRS.Earth.wrapLatLng(this);\r\n\t},\r\n\r\n\ttoBounds: function (sizeInMeters) {\r\n\t\tvar latAccuracy = 180 * sizeInMeters / 40075017,\r\n\t\t    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);\r\n\r\n\t\treturn L.latLngBounds(\r\n\t\t        [this.lat - latAccuracy, this.lng - lngAccuracy],\r\n\t\t        [this.lat + latAccuracy, this.lng + lngAccuracy]);\r\n\t},\r\n\r\n\tclone: function () {\r\n\t\treturn new L.LatLng(this.lat, this.lng, this.alt);\r\n\t}\r\n};\r\n\r\n\r\n// constructs LatLng with different signatures\r\n// (LatLng) or ([Number, Number]) or (Number, Number) or (Object)\r\n\r\nL.latLng = function (a, b, c) {\r\n\tif (a instanceof L.LatLng) {\r\n\t\treturn a;\r\n\t}\r\n\tif (L.Util.isArray(a) && typeof a[0] !== 'object') {\r\n\t\tif (a.length === 3) {\r\n\t\t\treturn new L.LatLng(a[0], a[1], a[2]);\r\n\t\t}\r\n\t\tif (a.length === 2) {\r\n\t\t\treturn new L.LatLng(a[0], a[1]);\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\tif (a === undefined || a === null) {\r\n\t\treturn a;\r\n\t}\r\n\tif (typeof a === 'object' && 'lat' in a) {\r\n\t\treturn new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\r\n\t}\r\n\tif (b === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\treturn new L.LatLng(a, b, c);\r\n};\r\n\n\n\n/*\r\n * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\r\n */\r\n\r\nL.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])\r\n\tif (!southWest) { return; }\r\n\r\n\tvar latlngs = northEast ? [southWest, northEast] : southWest;\r\n\r\n\tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n\t\tthis.extend(latlngs[i]);\r\n\t}\r\n};\r\n\r\nL.LatLngBounds.prototype = {\r\n\r\n\t// extend the bounds to contain the given point or bounds\r\n\textend: function (obj) { // (LatLng) or (LatLngBounds)\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2, ne2;\r\n\r\n\t\tif (obj instanceof L.LatLng) {\r\n\t\t\tsw2 = obj;\r\n\t\t\tne2 = obj;\r\n\r\n\t\t} else if (obj instanceof L.LatLngBounds) {\r\n\t\t\tsw2 = obj._southWest;\r\n\t\t\tne2 = obj._northEast;\r\n\r\n\t\t\tif (!sw2 || !ne2) { return this; }\r\n\r\n\t\t} else {\r\n\t\t\treturn obj ? this.extend(L.latLng(obj) || L.latLngBounds(obj)) : this;\r\n\t\t}\r\n\r\n\t\tif (!sw && !ne) {\r\n\t\t\tthis._southWest = new L.LatLng(sw2.lat, sw2.lng);\r\n\t\t\tthis._northEast = new L.LatLng(ne2.lat, ne2.lng);\r\n\t\t} else {\r\n\t\t\tsw.lat = Math.min(sw2.lat, sw.lat);\r\n\t\t\tsw.lng = Math.min(sw2.lng, sw.lng);\r\n\t\t\tne.lat = Math.max(ne2.lat, ne.lat);\r\n\t\t\tne.lng = Math.max(ne2.lng, ne.lng);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// extend the bounds by a percentage\r\n\tpad: function (bufferRatio) { // (Number) -> LatLngBounds\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n\t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n\t\t        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n\t},\r\n\r\n\tgetCenter: function () { // -> LatLng\r\n\t\treturn new L.LatLng(\r\n\t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n\t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n\t},\r\n\r\n\tgetSouthWest: function () {\r\n\t\treturn this._southWest;\r\n\t},\r\n\r\n\tgetNorthEast: function () {\r\n\t\treturn this._northEast;\r\n\t},\r\n\r\n\tgetNorthWest: function () {\r\n\t\treturn new L.LatLng(this.getNorth(), this.getWest());\r\n\t},\r\n\r\n\tgetSouthEast: function () {\r\n\t\treturn new L.LatLng(this.getSouth(), this.getEast());\r\n\t},\r\n\r\n\tgetWest: function () {\r\n\t\treturn this._southWest.lng;\r\n\t},\r\n\r\n\tgetSouth: function () {\r\n\t\treturn this._southWest.lat;\r\n\t},\r\n\r\n\tgetEast: function () {\r\n\t\treturn this._northEast.lng;\r\n\t},\r\n\r\n\tgetNorth: function () {\r\n\t\treturn this._northEast.lat;\r\n\t},\r\n\r\n\tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\r\n\t\t\tobj = L.latLng(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2, ne2;\r\n\r\n\t\tif (obj instanceof L.LatLngBounds) {\r\n\t\t\tsw2 = obj.getSouthWest();\r\n\t\t\tne2 = obj.getNorthEast();\r\n\t\t} else {\r\n\t\t\tsw2 = ne2 = obj;\r\n\t\t}\r\n\r\n\t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n\t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (LatLngBounds) -> Boolean\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2 = bounds.getSouthWest(),\r\n\t\t    ne2 = bounds.getNorthEast(),\r\n\r\n\t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n\t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n\t\treturn latIntersects && lngIntersects;\r\n\t},\r\n\r\n\toverlaps: function (bounds) { // (LatLngBounds) -> Boolean\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2 = bounds.getSouthWest(),\r\n\t\t    ne2 = bounds.getNorthEast(),\r\n\r\n\t\t    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),\r\n\t\t    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);\r\n\r\n\t\treturn latOverlaps && lngOverlaps;\r\n\t},\r\n\r\n\ttoBBoxString: function () {\r\n\t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n\t},\r\n\r\n\tequals: function (bounds) { // (LatLngBounds)\r\n\t\tif (!bounds) { return false; }\r\n\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\treturn this._southWest.equals(bounds.getSouthWest()) &&\r\n\t\t       this._northEast.equals(bounds.getNorthEast());\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this._southWest && this._northEast);\r\n\t}\r\n};\r\n\r\n// TODO International date line?\r\n\r\nL.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)\r\n\tif (!a || a instanceof L.LatLngBounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.LatLngBounds(a, b);\r\n};\r\n\n\n\n/*\r\n * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\r\n */\r\n\r\nL.Projection = {};\r\n\r\nL.Projection.LonLat = {\r\n\tproject: function (latlng) {\r\n\t\treturn new L.Point(latlng.lng, latlng.lat);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\treturn new L.LatLng(point.y, point.x);\r\n\t},\r\n\r\n\tbounds: L.bounds([-180, -90], [180, 90])\r\n};\r\n\n\n\n/*\r\n * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\r\n */\r\n\r\nL.Projection.SphericalMercator = {\r\n\r\n\tR: 6378137,\r\n\tMAX_LATITUDE: 85.0511287798,\r\n\r\n\tproject: function (latlng) {\r\n\t\tvar d = Math.PI / 180,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    sin = Math.sin(lat * d);\r\n\r\n\t\treturn new L.Point(\r\n\t\t\t\tthis.R * latlng.lng * d,\r\n\t\t\t\tthis.R * Math.log((1 + sin) / (1 - sin)) / 2);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\tvar d = 180 / Math.PI;\r\n\r\n\t\treturn new L.LatLng(\r\n\t\t\t(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,\r\n\t\t\tpoint.x * d / this.R);\r\n\t},\r\n\r\n\tbounds: (function () {\r\n\t\tvar d = 6378137 * Math.PI;\r\n\t\treturn L.bounds([-d, -d], [d, d]);\r\n\t})()\r\n};\r\n\n\n\n/*\r\n * L.CRS is the base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\r\n */\r\n\r\nL.CRS = {\r\n\t// converts geo coords to pixel ones\r\n\tlatLngToPoint: function (latlng, zoom) {\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    scale = this.scale(zoom);\r\n\r\n\t\treturn this.transformation._transform(projectedPoint, scale);\r\n\t},\r\n\r\n\t// converts pixel coords to geo coords\r\n\tpointToLatLng: function (point, zoom) {\r\n\t\tvar scale = this.scale(zoom),\r\n\t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n\t\treturn this.projection.unproject(untransformedPoint);\r\n\t},\r\n\r\n\t// converts geo coords to projection-specific coords (e.g. in meters)\r\n\tproject: function (latlng) {\r\n\t\treturn this.projection.project(latlng);\r\n\t},\r\n\r\n\t// converts projected coords to geo coords\r\n\tunproject: function (point) {\r\n\t\treturn this.projection.unproject(point);\r\n\t},\r\n\r\n\t// defines how the world scales with zoom\r\n\tscale: function (zoom) {\r\n\t\treturn 256 * Math.pow(2, zoom);\r\n\t},\r\n\r\n\tzoom: function (scale) {\r\n\t\treturn Math.log(scale / 256) / Math.LN2;\r\n\t},\r\n\r\n\t// returns the bounds of the world in projected coords if applicable\r\n\tgetProjectedBounds: function (zoom) {\r\n\t\tif (this.infinite) { return null; }\r\n\r\n\t\tvar b = this.projection.bounds,\r\n\t\t    s = this.scale(zoom),\r\n\t\t    min = this.transformation.transform(b.min, s),\r\n\t\t    max = this.transformation.transform(b.max, s);\r\n\r\n\t\treturn L.bounds(min, max);\r\n\t},\r\n\r\n\t// whether a coordinate axis wraps in a given range (e.g. longitude from -180 to 180); depends on CRS\r\n\t// wrapLng: [min, max],\r\n\t// wrapLat: [min, max],\r\n\r\n\t// if true, the coordinate space will be unbounded (infinite in all directions)\r\n\t// infinite: false,\r\n\r\n\t// wraps geo coords in certain ranges if applicable\r\n\twrapLatLng: function (latlng) {\r\n\t\tvar lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\r\n\t\t    lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\r\n\t\t    alt = latlng.alt;\r\n\r\n\t\treturn L.latLng(lat, lng, alt);\r\n\t}\r\n};\r\n\n\n\n/*\n * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n */\n\nL.CRS.Simple = L.extend({}, L.CRS, {\n\tprojection: L.Projection.LonLat,\n\ttransformation: new L.Transformation(1, 0, -1, 0),\n\n\tscale: function (zoom) {\n\t\treturn Math.pow(2, zoom);\n\t},\n\n\tzoom: function (scale) {\n\t\treturn Math.log(scale) / Math.LN2;\n\t},\n\n\tdistance: function (latlng1, latlng2) {\n\t\tvar dx = latlng2.lng - latlng1.lng,\n\t\t    dy = latlng2.lat - latlng1.lat;\n\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t},\n\n\tinfinite: true\n});\n\n\n\n/*\n * L.CRS.Earth is the base class for all CRS representing Earth.\n */\n\nL.CRS.Earth = L.extend({}, L.CRS, {\n\twrapLng: [-180, 180],\n\n\tR: 6378137,\n\n\t// distance between two geographical points using spherical law of cosines approximation\n\tdistance: function (latlng1, latlng2) {\n\t\tvar rad = Math.PI / 180,\n\t\t    lat1 = latlng1.lat * rad,\n\t\t    lat2 = latlng2.lat * rad,\n\t\t    a = Math.sin(lat1) * Math.sin(lat2) +\n\t\t        Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);\n\n\t\treturn this.R * Math.acos(Math.min(a, 1));\n\t}\n});\n\n\n\n/*\r\n * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping and is used by Leaflet by default.\r\n */\r\n\r\nL.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {\r\n\tcode: 'EPSG:3857',\r\n\tprojection: L.Projection.SphericalMercator,\r\n\r\n\ttransformation: (function () {\r\n\t\tvar scale = 0.5 / (Math.PI * L.Projection.SphericalMercator.R);\r\n\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\r\n\t}())\r\n});\r\n\r\nL.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\r\n\tcode: 'EPSG:900913'\r\n});\r\n\n\n\n/*\r\n * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\r\n */\r\n\r\nL.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {\r\n\tcode: 'EPSG:4326',\r\n\tprojection: L.Projection.LonLat,\r\n\ttransformation: new L.Transformation(1 / 180, 1, -1 / 180, 0.5)\r\n});\r\n\n\n\n/*\r\n * L.Map is the central class of the API - it is used to create a map.\r\n */\r\n\r\nL.Map = L.Evented.extend({\r\n\r\n\toptions: {\r\n\t\tcrs: L.CRS.EPSG3857,\r\n\r\n\t\t/*\r\n\t\tcenter: LatLng,\r\n\t\tzoom: Number,\r\n\t\tlayers: Array,\r\n\t\t*/\r\n\r\n\t\tfadeAnimation: true,\r\n\t\ttrackResize: true,\r\n\t\tmarkerZoomAnimation: true,\r\n\t\tmaxBoundsViscosity: 0.0,\r\n\t\ttransform3DLimit: 8388608 // Precision limit of a 32-bit float\r\n\t},\r\n\r\n\tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\tthis._initContainer(id);\r\n\t\tthis._initLayout();\r\n\r\n\t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n\t\tthis._onResize = L.bind(this._onResize, this);\r\n\r\n\t\tthis._initEvents();\r\n\r\n\t\tif (options.maxBounds) {\r\n\t\t\tthis.setMaxBounds(options.maxBounds);\r\n\t\t}\r\n\r\n\t\tif (options.zoom !== undefined) {\r\n\t\t\tthis._zoom = this._limitZoom(options.zoom);\r\n\t\t}\r\n\r\n\t\tif (options.center && options.zoom !== undefined) {\r\n\t\t\tthis.setView(L.latLng(options.center), options.zoom, {reset: true});\r\n\t\t}\r\n\r\n\t\tthis._handlers = [];\r\n\t\tthis._layers = {};\r\n\t\tthis._zoomBoundLayers = {};\r\n\t\tthis._sizeChanged = true;\r\n\r\n\t\tthis.callInitHooks();\r\n\r\n\t\tthis._addLayers(this.options.layers);\r\n\t},\r\n\r\n\r\n\t// public methods that modify map state\r\n\r\n\t// replaced by animation-powered implementation in Map.PanAnimation.js\r\n\tsetView: function (center, zoom) {\r\n\t\tzoom = zoom === undefined ? this.getZoom() : zoom;\r\n\t\tthis._resetView(L.latLng(center), zoom);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZoom: function (zoom, options) {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthis._zoom = zoom;\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n\t},\r\n\r\n\tzoomIn: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom + (delta || 1), options);\r\n\t},\r\n\r\n\tzoomOut: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom - (delta || 1), options);\r\n\t},\r\n\r\n\tsetZoomAround: function (latlng, zoom, options) {\r\n\t\tvar scale = this.getZoomScale(zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n\t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n\t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n\t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n\t},\r\n\r\n\t_getBoundsCenterZoom: function (bounds, options) {\r\n\r\n\t\toptions = options || {};\r\n\t\tbounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\r\n\r\n\t\tvar paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n\t\t    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n\t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\r\n\t\tzoom = options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n\t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n\t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n\t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n\t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n\t\treturn {\r\n\t\t\tcenter: center,\r\n\t\t\tzoom: zoom\r\n\t\t};\r\n\t},\r\n\r\n\tfitBounds: function (bounds, options) {\r\n\t\tvar target = this._getBoundsCenterZoom(bounds, options);\r\n\t\treturn this.setView(target.center, target.zoom, options);\r\n\t},\r\n\r\n\tfitWorld: function (options) {\r\n\t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n\t},\r\n\r\n\tpanTo: function (center, options) { // (LatLng)\r\n\t\treturn this.setView(center, this._zoom, {pan: options});\r\n\t},\r\n\r\n\tpanBy: function (offset) { // (Point)\r\n\t\t// replaced with animated panBy in Map.PanAnimation.js\r\n\t\tthis.fire('movestart');\r\n\r\n\t\tthis._rawPanBy(L.point(offset));\r\n\r\n\t\tthis.fire('move');\r\n\t\treturn this.fire('moveend');\r\n\t},\r\n\r\n\tsetMaxBounds: function (bounds) {\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tif (!bounds) {\r\n\t\t\treturn this.off('moveend', this._panInsideMaxBounds);\r\n\t\t} else if (this.options.maxBounds) {\r\n\t\t\tthis.off('moveend', this._panInsideMaxBounds);\r\n\t\t}\r\n\r\n\t\tthis.options.maxBounds = bounds;\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._panInsideMaxBounds();\r\n\t\t}\r\n\r\n\t\treturn this.on('moveend', this._panInsideMaxBounds);\r\n\t},\r\n\r\n\tsetMinZoom: function (zoom) {\r\n\t\tthis.options.minZoom = zoom;\r\n\r\n\t\tif (this._loaded && this.getZoom() < this.options.minZoom) {\r\n\t\t\treturn this.setZoom(zoom);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetMaxZoom: function (zoom) {\r\n\t\tthis.options.maxZoom = zoom;\r\n\r\n\t\tif (this._loaded && (this.getZoom() > this.options.maxZoom)) {\r\n\t\t\treturn this.setZoom(zoom);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tpanInsideBounds: function (bounds, options) {\r\n\t\tthis._enforcingBounds = true;\r\n\t\tvar center = this.getCenter(),\r\n\t\t    newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));\r\n\r\n\t\tif (center.equals(newCenter)) { return this; }\r\n\r\n\t\tthis.panTo(newCenter, options);\r\n\t\tthis._enforcingBounds = false;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvalidateSize: function (options) {\r\n\t\tif (!this._loaded) { return this; }\r\n\r\n\t\toptions = L.extend({\r\n\t\t\tanimate: false,\r\n\t\t\tpan: true\r\n\t\t}, options === true ? {animate: true} : options);\r\n\r\n\t\tvar oldSize = this.getSize();\r\n\t\tthis._sizeChanged = true;\r\n\t\tthis._lastCenter = null;\r\n\r\n\t\tvar newSize = this.getSize(),\r\n\t\t    oldCenter = oldSize.divideBy(2).round(),\r\n\t\t    newCenter = newSize.divideBy(2).round(),\r\n\t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n\t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n\t\tif (options.animate && options.pan) {\r\n\t\t\tthis.panBy(offset);\r\n\r\n\t\t} else {\r\n\t\t\tif (options.pan) {\r\n\t\t\t\tthis._rawPanBy(offset);\r\n\t\t\t}\r\n\r\n\t\t\tthis.fire('move');\r\n\r\n\t\t\tif (options.debounceMoveend) {\r\n\t\t\t\tclearTimeout(this._sizeTimer);\r\n\t\t\t\tthis._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\r\n\t\t\t} else {\r\n\t\t\t\tthis.fire('moveend');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.fire('resize', {\r\n\t\t\toldSize: oldSize,\r\n\t\t\tnewSize: newSize\r\n\t\t});\r\n\t},\r\n\r\n\tstop: function () {\r\n\t\tL.Util.cancelAnimFrame(this._flyToFrame);\r\n\t\tif (this._panAnim) {\r\n\t\t\tthis._panAnim.stop();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// TODO handler.addTo\r\n\taddHandler: function (name, HandlerClass) {\r\n\t\tif (!HandlerClass) { return this; }\r\n\r\n\t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n\t\tthis._handlers.push(handler);\r\n\r\n\t\tif (this.options[name]) {\r\n\t\t\thandler.enable();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremove: function () {\r\n\r\n\t\tthis._initEvents(true);\r\n\r\n\t\ttry {\r\n\t\t\t// throws error in IE6-8\r\n\t\t\tdelete this._container._leaflet;\r\n\t\t} catch (e) {\r\n\t\t\tthis._container._leaflet = undefined;\r\n\t\t}\r\n\r\n\t\tL.DomUtil.remove(this._mapPane);\r\n\r\n\t\tif (this._clearControlPos) {\r\n\t\t\tthis._clearControlPos();\r\n\t\t}\r\n\r\n\t\tthis._clearHandlers();\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('unload');\r\n\t\t}\r\n\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tthis._layers[i].remove();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tcreatePane: function (name, container) {\r\n\t\tvar className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\r\n\t\t    pane = L.DomUtil.create('div', className, container || this._mapPane);\r\n\r\n\t\tif (name) {\r\n\t\t\tthis._panes[name] = pane;\r\n\t\t}\r\n\t\treturn pane;\r\n\t},\r\n\r\n\r\n\t// public methods for getting map state\r\n\r\n\tgetCenter: function () { // (Boolean) -> LatLng\r\n\t\tthis._checkIfLoaded();\r\n\r\n\t\tif (this._lastCenter && !this._moved()) {\r\n\t\t\treturn this._lastCenter;\r\n\t\t}\r\n\t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\tgetZoom: function () {\r\n\t\treturn this._zoom;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = this.getPixelBounds(),\r\n\t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n\t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n\t\treturn new L.LatLngBounds(sw, ne);\r\n\t},\r\n\r\n\tgetMinZoom: function () {\r\n\t\treturn this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\r\n\t},\r\n\r\n\tgetMaxZoom: function () {\r\n\t\treturn this.options.maxZoom === undefined ?\r\n\t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n\t\t\tthis.options.maxZoom;\r\n\t},\r\n\r\n\tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar zoom = this.getMinZoom() - (inside ? 1 : 0),\r\n\t\t    maxZoom = this.getMaxZoom(),\r\n\t\t    size = this.getSize(),\r\n\r\n\t\t    nw = bounds.getNorthWest(),\r\n\t\t    se = bounds.getSouthEast(),\r\n\r\n\t\t    zoomNotFound = true,\r\n\t\t    boundsSize;\r\n\r\n\t\tpadding = L.point(padding || [0, 0]);\r\n\r\n\t\tdo {\r\n\t\t\tzoom++;\r\n\t\t\tboundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding).floor();\r\n\t\t\tzoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\r\n\r\n\t\t} while (zoomNotFound && zoom <= maxZoom);\r\n\r\n\t\tif (zoomNotFound && inside) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn inside ? zoom : zoom - 1;\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\tif (!this._size || this._sizeChanged) {\r\n\t\t\tthis._size = new L.Point(\r\n\t\t\t\tthis._container.clientWidth,\r\n\t\t\t\tthis._container.clientHeight);\r\n\r\n\t\t\tthis._sizeChanged = false;\r\n\t\t}\r\n\t\treturn this._size.clone();\r\n\t},\r\n\r\n\tgetPixelBounds: function (center, zoom) {\r\n\t\tvar topLeftPoint = this._getTopLeftPoint(center, zoom);\r\n\t\treturn new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n\t},\r\n\r\n\tgetPixelOrigin: function () {\r\n\t\tthis._checkIfLoaded();\r\n\t\treturn this._pixelOrigin;\r\n\t},\r\n\r\n\tgetPixelWorldBounds: function (zoom) {\r\n\t\treturn this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\r\n\t},\r\n\r\n\tgetPane: function (pane) {\r\n\t\treturn typeof pane === 'string' ? this._panes[pane] : pane;\r\n\t},\r\n\r\n\tgetPanes: function () {\r\n\t\treturn this._panes;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\r\n\t// TODO replace with universal implementation after refactoring projections\r\n\r\n\tgetZoomScale: function (toZoom, fromZoom) {\r\n\t\tvar crs = this.options.crs;\r\n\t\tfromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n\t\treturn crs.scale(toZoom) / crs.scale(fromZoom);\r\n\t},\r\n\r\n\tgetScaleZoom: function (scale, fromZoom) {\r\n\t\tvar crs = this.options.crs;\r\n\t\tfromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n\t\treturn crs.zoom(scale * crs.scale(fromZoom));\r\n\t},\r\n\r\n\t// conversion methods\r\n\r\n\tproject: function (latlng, zoom) { // (LatLng[, Number]) -> Point\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\r\n\t},\r\n\r\n\tunproject: function (point, zoom) { // (Point[, Number]) -> LatLng\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.pointToLatLng(L.point(point), zoom);\r\n\t},\r\n\r\n\tlayerPointToLatLng: function (point) { // (Point)\r\n\t\tvar projectedPoint = L.point(point).add(this.getPixelOrigin());\r\n\t\treturn this.unproject(projectedPoint);\r\n\t},\r\n\r\n\tlatLngToLayerPoint: function (latlng) { // (LatLng)\r\n\t\tvar projectedPoint = this.project(L.latLng(latlng))._round();\r\n\t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n\t},\r\n\r\n\twrapLatLng: function (latlng) {\r\n\t\treturn this.options.crs.wrapLatLng(L.latLng(latlng));\r\n\t},\r\n\r\n\tdistance: function (latlng1, latlng2) {\r\n\t\treturn this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2));\r\n\t},\r\n\r\n\tcontainerPointToLayerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\tlayerPointToContainerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).add(this._getMapPanePos());\r\n\t},\r\n\r\n\tcontainerPointToLatLng: function (point) {\r\n\t\tvar layerPoint = this.containerPointToLayerPoint(L.point(point));\r\n\t\treturn this.layerPointToLatLng(layerPoint);\r\n\t},\r\n\r\n\tlatLngToContainerPoint: function (latlng) {\r\n\t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\r\n\t},\r\n\r\n\tmouseEventToContainerPoint: function (e) { // (MouseEvent)\r\n\t\treturn L.DomEvent.getMousePosition(e, this._container);\r\n\t},\r\n\r\n\tmouseEventToLayerPoint: function (e) { // (MouseEvent)\r\n\t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n\t},\r\n\r\n\tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n\t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n\t},\r\n\r\n\r\n\t// map initialization methods\r\n\r\n\t_initContainer: function (id) {\r\n\t\tvar container = this._container = L.DomUtil.get(id);\r\n\r\n\t\tif (!container) {\r\n\t\t\tthrow new Error('Map container not found.');\r\n\t\t} else if (container._leaflet) {\r\n\t\t\tthrow new Error('Map container is already initialized.');\r\n\t\t}\r\n\r\n\t\tL.DomEvent.addListener(container, 'scroll', this._onScroll, this);\r\n\t\tcontainer._leaflet = true;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar container = this._container;\r\n\r\n\t\tthis._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-container' +\r\n\t\t\t(L.Browser.touch ? ' leaflet-touch' : '') +\r\n\t\t\t(L.Browser.retina ? ' leaflet-retina' : '') +\r\n\t\t\t(L.Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n\t\t\t(L.Browser.safari ? ' leaflet-safari' : '') +\r\n\t\t\t(this._fadeAnimated ? ' leaflet-fade-anim' : ''));\r\n\r\n\t\tvar position = L.DomUtil.getStyle(container, 'position');\r\n\r\n\t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n\t\t\tcontainer.style.position = 'relative';\r\n\t\t}\r\n\r\n\t\tthis._initPanes();\r\n\r\n\t\tif (this._initControlPos) {\r\n\t\t\tthis._initControlPos();\r\n\t\t}\r\n\t},\r\n\r\n\t_initPanes: function () {\r\n\t\tvar panes = this._panes = {};\r\n\t\tthis._paneRenderers = {};\r\n\r\n\t\tthis._mapPane = this.createPane('mapPane', this._container);\r\n\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\r\n\t\tthis.createPane('tilePane');\r\n\t\tthis.createPane('shadowPane');\r\n\t\tthis.createPane('overlayPane');\r\n\t\tthis.createPane('markerPane');\r\n\t\tthis.createPane('popupPane');\r\n\r\n\t\tif (!this.options.markerZoomAnimation) {\r\n\t\t\tL.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');\r\n\t\t\tL.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// private methods that modify map state\r\n\r\n\t_resetView: function (center, zoom) {\r\n\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\r\n\t\tvar loading = !this._loaded;\r\n\t\tthis._loaded = true;\r\n\t\tzoom = this._limitZoom(zoom);\r\n\r\n\t\tvar zoomChanged = this._zoom !== zoom;\r\n\t\tthis\r\n\t\t\t._moveStart(zoomChanged)\r\n\t\t\t._move(center, zoom)\r\n\t\t\t._moveEnd(zoomChanged);\r\n\r\n\t\tthis.fire('viewreset');\r\n\r\n\t\tif (loading) {\r\n\t\t\tthis.fire('load');\r\n\t\t}\r\n\t},\r\n\r\n\t_moveStart: function (zoomChanged) {\r\n\t\tif (zoomChanged) {\r\n\t\t\tthis.fire('zoomstart');\r\n\t\t}\r\n\t\treturn this.fire('movestart');\r\n\t},\r\n\r\n\t_move: function (center, zoom, data) {\r\n\t\tif (zoom === undefined) {\r\n\t\t\tzoom = this._zoom;\r\n\t\t}\r\n\r\n\t\tvar zoomChanged = this._zoom !== zoom;\r\n\r\n\t\tthis._zoom = zoom;\r\n\t\tthis._lastCenter = center;\r\n\t\tthis._pixelOrigin = this._getNewPixelOrigin(center);\r\n\r\n\t\tif (zoomChanged) {\r\n\t\t\tthis.fire('zoom', data);\r\n\t\t}\r\n\t\treturn this.fire('move', data);\r\n\t},\r\n\r\n\t_moveEnd: function (zoomChanged) {\r\n\t\tif (zoomChanged) {\r\n\t\t\tthis.fire('zoomend');\r\n\t\t}\r\n\t\treturn this.fire('moveend');\r\n\t},\r\n\r\n\t_rawPanBy: function (offset) {\r\n\t\tL.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n\t},\r\n\r\n\t_getZoomSpan: function () {\r\n\t\treturn this.getMaxZoom() - this.getMinZoom();\r\n\t},\r\n\r\n\t_panInsideMaxBounds: function () {\r\n\t\tif (!this._enforcingBounds) {\r\n\t\t\tthis.panInsideBounds(this.options.maxBounds);\r\n\t\t}\r\n\t},\r\n\r\n\t_checkIfLoaded: function () {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthrow new Error('Set map center and zoom first.');\r\n\t\t}\r\n\t},\r\n\r\n\t// DOM event handling\r\n\r\n\t_initEvents: function (remove) {\r\n\t\tif (!L.DomEvent) { return; }\r\n\r\n\t\tthis._targets = {};\r\n\t\tthis._targets[L.stamp(this._container)] = this;\r\n\r\n\t\tvar onOff = remove ? 'off' : 'on';\r\n\r\n\t\tL.DomEvent[onOff](this._container, 'click dblclick mousedown mouseup ' +\r\n\t\t\t'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);\r\n\r\n\t\tif (this.options.trackResize) {\r\n\t\t\tL.DomEvent[onOff](window, 'resize', this._onResize, this);\r\n\t\t}\r\n\r\n\t\tif (L.Browser.any3d && this.options.transform3DLimit) {\r\n\t\t\tthis[onOff]('moveend', this._onMoveEnd);\r\n\t\t}\r\n\t},\r\n\r\n\t_onResize: function () {\r\n\t\tL.Util.cancelAnimFrame(this._resizeRequest);\r\n\t\tthis._resizeRequest = L.Util.requestAnimFrame(\r\n\t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this);\r\n\t},\r\n\r\n\t_onScroll: function () {\r\n\t\tthis._container.scrollTop  = 0;\r\n\t\tthis._container.scrollLeft = 0;\r\n\t},\r\n\r\n\t_onMoveEnd: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\tif (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\r\n\t\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\r\n\t\t\t// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/\r\n\t\t\tthis._resetView(this.getCenter(), this.getZoom());\r\n\t\t}\r\n\t},\r\n\r\n\t_findEventTargets: function (e, type) {\r\n\t\tvar targets = [],\r\n\t\t    target,\r\n\t\t    isHover = type === 'mouseout' || type === 'mouseover',\r\n\t\t    src = e.target || e.srcElement;\r\n\r\n\t\twhile (src) {\r\n\t\t\ttarget = this._targets[L.stamp(src)];\r\n\t\t\tif (target && target.listens(type, true)) {\r\n\t\t\t\tif (isHover && !L.DomEvent._isExternalTarget(src, e)) { break; }\r\n\t\t\t\ttargets.push(target);\r\n\t\t\t\tif (isHover) { break; }\r\n\t\t\t}\r\n\t\t\tif (src === this._container) { break; }\r\n\t\t\tsrc = src.parentNode;\r\n\t\t}\r\n\t\tif (!targets.length && !isHover && L.DomEvent._isExternalTarget(src, e)) {\r\n\t\t\ttargets = [this];\r\n\t\t}\r\n\t\treturn targets;\r\n\t},\r\n\r\n\t_handleDOMEvent: function (e) {\r\n\t\tif (!this._loaded || L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\t// find the layer the event is propagating from and its parents\r\n\t\tvar type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;\r\n\r\n\t\tif (e.type === 'click') {\r\n\t\t\t// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\r\n\t\t\tvar synth = L.Util.extend({}, e);\r\n\t\t\tsynth.type = 'preclick';\r\n\t\t\tthis._handleDOMEvent(synth);\r\n\t\t}\r\n\r\n\t\tif (type === 'mousedown') {\r\n\t\t\t// prevents outline when clicking on keyboard-focusable element\r\n\t\t\tL.DomUtil.preventOutline(e.target || e.srcElement);\r\n\t\t}\r\n\r\n\t\tthis._fireDOMEvent(e, type);\r\n\t},\r\n\r\n\t_fireDOMEvent: function (e, type, targets) {\r\n\r\n\t\tif (e._stopped) { return; }\r\n\r\n\t\ttargets = (targets || []).concat(this._findEventTargets(e, type));\r\n\r\n\t\tif (!targets.length) { return; }\r\n\r\n\t\tvar target = targets[0];\r\n\t\tif (type === 'contextmenu' && target.listens(type, true)) {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\r\n\t\t// prevents firing click after you just dragged an object\r\n\t\tif ((e.type === 'click' || e.type === 'preclick') && !e._simulated && this._draggableMoved(target)) { return; }\r\n\r\n\t\tvar data = {\r\n\t\t\toriginalEvent: e\r\n\t\t};\r\n\r\n\t\tif (e.type !== 'keypress') {\r\n\t\t\tvar isMarker = target instanceof L.Marker;\r\n\t\t\tdata.containerPoint = isMarker ?\r\n\t\t\t\t\tthis.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\r\n\t\t\tdata.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\r\n\t\t\tdata.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < targets.length; i++) {\r\n\t\t\ttargets[i].fire(type, data, true);\r\n\t\t\tif (data.originalEvent._stopped ||\r\n\t\t\t\t(targets[i].options.nonBubblingEvents && L.Util.indexOf(targets[i].options.nonBubblingEvents, type) !== -1)) { return; }\r\n\t\t}\r\n\t},\r\n\r\n\t_draggableMoved: function (obj) {\r\n\t\tobj = obj.options.draggable ? obj : this;\r\n\t\treturn (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());\r\n\t},\r\n\r\n\t_clearHandlers: function () {\r\n\t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n\t\t\tthis._handlers[i].disable();\r\n\t\t}\r\n\t},\r\n\r\n\twhenReady: function (callback, context) {\r\n\t\tif (this._loaded) {\r\n\t\t\tcallback.call(context || this, {target: this});\r\n\t\t} else {\r\n\t\t\tthis.on('load', callback, context);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\r\n\t// private methods for getting map state\r\n\r\n\t_getMapPanePos: function () {\r\n\t\treturn L.DomUtil.getPosition(this._mapPane) || new L.Point(0, 0);\r\n\t},\r\n\r\n\t_moved: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\treturn pos && !pos.equals([0, 0]);\r\n\t},\r\n\r\n\t_getTopLeftPoint: function (center, zoom) {\r\n\t\tvar pixelOrigin = center && zoom !== undefined ?\r\n\t\t\tthis._getNewPixelOrigin(center, zoom) :\r\n\t\t\tthis.getPixelOrigin();\r\n\t\treturn pixelOrigin.subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\t_getNewPixelOrigin: function (center, zoom) {\r\n\t\tvar viewHalf = this.getSize()._divideBy(2);\r\n\t\treturn this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\r\n\t},\r\n\r\n\t_latLngToNewLayerPoint: function (latlng, zoom, center) {\r\n\t\tvar topLeft = this._getNewPixelOrigin(center, zoom);\r\n\t\treturn this.project(latlng, zoom)._subtract(topLeft);\r\n\t},\r\n\r\n\t// layer point of the current center\r\n\t_getCenterLayerPoint: function () {\r\n\t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n\t},\r\n\r\n\t// offset of the specified place to the current center in pixels\r\n\t_getCenterOffset: function (latlng) {\r\n\t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\t// adjust center for view to get inside bounds\r\n\t_limitCenter: function (center, zoom, bounds) {\r\n\r\n\t\tif (!bounds) { return center; }\r\n\r\n\t\tvar centerPoint = this.project(center, zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n\t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n\t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n\t},\r\n\r\n\t// adjust offset for view to get inside bounds\r\n\t_limitOffset: function (offset, bounds) {\r\n\t\tif (!bounds) { return offset; }\r\n\r\n\t\tvar viewBounds = this.getPixelBounds(),\r\n\t\t    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n\t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n\t},\r\n\r\n\t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n\t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n\t\tvar nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\r\n\t\t    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\r\n\r\n\t\t    dx = this._rebound(nwOffset.x, -seOffset.x),\r\n\t\t    dy = this._rebound(nwOffset.y, -seOffset.y);\r\n\r\n\t\treturn new L.Point(dx, dy);\r\n\t},\r\n\r\n\t_rebound: function (left, right) {\r\n\t\treturn left + right > 0 ?\r\n\t\t\tMath.round(left - right) / 2 :\r\n\t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n\t},\r\n\r\n\t_limitZoom: function (zoom) {\r\n\t\tvar min = this.getMinZoom(),\r\n\t\t    max = this.getMaxZoom();\r\n\t\tif (!L.Browser.any3d) { zoom = Math.round(zoom); }\r\n\r\n\t\treturn Math.max(min, Math.min(max, zoom));\r\n\t}\r\n});\r\n\r\nL.map = function (id, options) {\r\n\treturn new L.Map(id, options);\r\n};\r\n\n\n\n\nL.Layer = L.Evented.extend({\n\n\toptions: {\n\t\tpane: 'overlayPane',\n\t\tnonBubblingEvents: []  // Array of events that should not be bubbled to DOM parents (like the map)\n\t},\n\n\taddTo: function (map) {\n\t\tmap.addLayer(this);\n\t\treturn this;\n\t},\n\n\tremove: function () {\n\t\treturn this.removeFrom(this._map || this._mapToAdd);\n\t},\n\n\tremoveFrom: function (obj) {\n\t\tif (obj) {\n\t\t\tobj.removeLayer(this);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetPane: function (name) {\n\t\treturn this._map.getPane(name ? (this.options[name] || name) : this.options.pane);\n\t},\n\n\taddInteractiveTarget: function (targetEl) {\n\t\tthis._map._targets[L.stamp(targetEl)] = this;\n\t\treturn this;\n\t},\n\n\tremoveInteractiveTarget: function (targetEl) {\n\t\tdelete this._map._targets[L.stamp(targetEl)];\n\t\treturn this;\n\t},\n\n\t_layerAdd: function (e) {\n\t\tvar map = e.target;\n\n\t\t// check in case layer gets added and then removed before the map is ready\n\t\tif (!map.hasLayer(this)) { return; }\n\n\t\tthis._map = map;\n\t\tthis._zoomAnimated = map._zoomAnimated;\n\n\t\tif (this.getEvents) {\n\t\t\tmap.on(this.getEvents(), this);\n\t\t}\n\n\t\tthis.onAdd(map);\n\n\t\tif (this.getAttribution && this._map.attributionControl) {\n\t\t\tthis._map.attributionControl.addAttribution(this.getAttribution());\n\t\t}\n\n\t\tthis.fire('add');\n\t\tmap.fire('layeradd', {layer: this});\n\t}\n});\n\n\nL.Map.include({\n\taddLayer: function (layer) {\n\t\tvar id = L.stamp(layer);\n\t\tif (this._layers[id]) { return layer; }\n\t\tthis._layers[id] = layer;\n\n\t\tlayer._mapToAdd = this;\n\n\t\tif (layer.beforeAdd) {\n\t\t\tlayer.beforeAdd(this);\n\t\t}\n\n\t\tthis.whenReady(layer._layerAdd, layer);\n\n\t\treturn this;\n\t},\n\n\tremoveLayer: function (layer) {\n\t\tvar id = L.stamp(layer);\n\n\t\tif (!this._layers[id]) { return this; }\n\n\t\tif (this._loaded) {\n\t\t\tlayer.onRemove(this);\n\t\t}\n\n\t\tif (layer.getAttribution && this.attributionControl) {\n\t\t\tthis.attributionControl.removeAttribution(layer.getAttribution());\n\t\t}\n\n\t\tif (layer.getEvents) {\n\t\t\tthis.off(layer.getEvents(), layer);\n\t\t}\n\n\t\tdelete this._layers[id];\n\n\t\tif (this._loaded) {\n\t\t\tthis.fire('layerremove', {layer: layer});\n\t\t\tlayer.fire('remove');\n\t\t}\n\n\t\tlayer._map = layer._mapToAdd = null;\n\n\t\treturn this;\n\t},\n\n\thasLayer: function (layer) {\n\t\treturn !!layer && (L.stamp(layer) in this._layers);\n\t},\n\n\teachLayer: function (method, context) {\n\t\tfor (var i in this._layers) {\n\t\t\tmethod.call(context, this._layers[i]);\n\t\t}\n\t\treturn this;\n\t},\n\n\t_addLayers: function (layers) {\n\t\tlayers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];\n\n\t\tfor (var i = 0, len = layers.length; i < len; i++) {\n\t\t\tthis.addLayer(layers[i]);\n\t\t}\n\t},\n\n\t_addZoomLimit: function (layer) {\n\t\tif (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n\t\t\tthis._zoomBoundLayers[L.stamp(layer)] = layer;\n\t\t\tthis._updateZoomLevels();\n\t\t}\n\t},\n\n\t_removeZoomLimit: function (layer) {\n\t\tvar id = L.stamp(layer);\n\n\t\tif (this._zoomBoundLayers[id]) {\n\t\t\tdelete this._zoomBoundLayers[id];\n\t\t\tthis._updateZoomLevels();\n\t\t}\n\t},\n\n\t_updateZoomLevels: function () {\n\t\tvar minZoom = Infinity,\n\t\t    maxZoom = -Infinity,\n\t\t    oldZoomSpan = this._getZoomSpan();\n\n\t\tfor (var i in this._zoomBoundLayers) {\n\t\t\tvar options = this._zoomBoundLayers[i].options;\n\n\t\t\tminZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n\t\t\tmaxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n\t\t}\n\n\t\tthis._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n\t\tthis._layersMinZoom = minZoom === Infinity ? undefined : minZoom;\n\n\t\tif (oldZoomSpan !== this._getZoomSpan()) {\n\t\t\tthis.fire('zoomlevelschange');\n\t\t}\n\t}\n});\n\n\n\n/*\r\n * Mercator projection that takes into account that the Earth is not a perfect sphere.\r\n * Less popular than spherical mercator; used by projections like EPSG:3395.\r\n */\r\n\r\nL.Projection.Mercator = {\r\n\tR: 6378137,\r\n\tR_MINOR: 6356752.314245179,\r\n\r\n\tbounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\r\n\r\n\tproject: function (latlng) {\r\n\t\tvar d = Math.PI / 180,\r\n\t\t    r = this.R,\r\n\t\t    y = latlng.lat * d,\r\n\t\t    tmp = this.R_MINOR / r,\r\n\t\t    e = Math.sqrt(1 - tmp * tmp),\r\n\t\t    con = e * Math.sin(y);\r\n\r\n\t\tvar ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\r\n\t\ty = -r * Math.log(Math.max(ts, 1E-10));\r\n\r\n\t\treturn new L.Point(latlng.lng * d * r, y);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\tvar d = 180 / Math.PI,\r\n\t\t    r = this.R,\r\n\t\t    tmp = this.R_MINOR / r,\r\n\t\t    e = Math.sqrt(1 - tmp * tmp),\r\n\t\t    ts = Math.exp(-point.y / r),\r\n\t\t    phi = Math.PI / 2 - 2 * Math.atan(ts);\r\n\r\n\t\tfor (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\r\n\t\t\tcon = e * Math.sin(phi);\r\n\t\t\tcon = Math.pow((1 - con) / (1 + con), e / 2);\r\n\t\t\tdphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\r\n\t\t\tphi += dphi;\r\n\t\t}\r\n\r\n\t\treturn new L.LatLng(phi * d, point.x * d / r);\r\n\t}\r\n};\r\n\n\n\n/*\r\n * L.CRS.EPSG3857 (World Mercator) CRS implementation.\r\n */\r\n\r\nL.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {\r\n\tcode: 'EPSG:3395',\r\n\tprojection: L.Projection.Mercator,\r\n\r\n\ttransformation: (function () {\r\n\t\tvar scale = 0.5 / (Math.PI * L.Projection.Mercator.R);\r\n\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\r\n\t}())\r\n});\r\n\n\n\n/*\n * L.GridLayer is used as base class for grid-like layers like TileLayer.\n */\n\nL.GridLayer = L.Layer.extend({\n\n\toptions: {\n\t\tpane: 'tilePane',\n\n\t\ttileSize: 256,\n\t\topacity: 1,\n\t\tzIndex: 1,\n\n\t\tupdateWhenIdle: L.Browser.mobile,\n\t\tupdateInterval: 200,\n\n\t\tattribution: null,\n\t\tbounds: null,\n\n\t\tminZoom: 0\n\t\t// maxZoom: <Number>\n\t\t// noWrap: false\n\t},\n\n\tinitialize: function (options) {\n\t\toptions = L.setOptions(this, options);\n\t},\n\n\tonAdd: function () {\n\t\tthis._initContainer();\n\n\t\tthis._levels = {};\n\t\tthis._tiles = {};\n\n\t\tthis._resetView();\n\t\tthis._update();\n\t},\n\n\tbeforeAdd: function (map) {\n\t\tmap._addZoomLimit(this);\n\t},\n\n\tonRemove: function (map) {\n\t\tL.DomUtil.remove(this._container);\n\t\tmap._removeZoomLimit(this);\n\t\tthis._container = null;\n\t\tthis._tileZoom = null;\n\t},\n\n\tbringToFront: function () {\n\t\tif (this._map) {\n\t\t\tL.DomUtil.toFront(this._container);\n\t\t\tthis._setAutoZIndex(Math.max);\n\t\t}\n\t\treturn this;\n\t},\n\n\tbringToBack: function () {\n\t\tif (this._map) {\n\t\t\tL.DomUtil.toBack(this._container);\n\t\t\tthis._setAutoZIndex(Math.min);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetAttribution: function () {\n\t\treturn this.options.attribution;\n\t},\n\n\tgetContainer: function () {\n\t\treturn this._container;\n\t},\n\n\tsetOpacity: function (opacity) {\n\t\tthis.options.opacity = opacity;\n\t\tthis._updateOpacity();\n\t\treturn this;\n\t},\n\n\tsetZIndex: function (zIndex) {\n\t\tthis.options.zIndex = zIndex;\n\t\tthis._updateZIndex();\n\n\t\treturn this;\n\t},\n\n\tisLoading: function () {\n\t\treturn this._loading;\n\t},\n\n\tredraw: function () {\n\t\tif (this._map) {\n\t\t\tthis._removeAllTiles();\n\t\t\tthis._update();\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetEvents: function () {\n\t\tvar events = {\n\t\t\tviewreset: this._resetAll,\n\t\t\tzoom: this._resetView,\n\t\t\tmoveend: this._onMoveEnd\n\t\t};\n\n\t\tif (!this.options.updateWhenIdle) {\n\t\t\t// update tiles on move, but not more often than once per given interval\n\t\t\tif (!this._onMove) {\n\t\t\t\tthis._onMove = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);\n\t\t\t}\n\n\t\t\tevents.move = this._onMove;\n\t\t}\n\n\t\tif (this._zoomAnimated) {\n\t\t\tevents.zoomanim = this._animateZoom;\n\t\t}\n\n\t\treturn events;\n\t},\n\n\tcreateTile: function () {\n\t\treturn document.createElement('div');\n\t},\n\n\tgetTileSize: function () {\n\t\tvar s = this.options.tileSize;\n\t\treturn s instanceof L.Point ? s : new L.Point(s, s);\n\t},\n\n\t_updateZIndex: function () {\n\t\tif (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n\t\t\tthis._container.style.zIndex = this.options.zIndex;\n\t\t}\n\t},\n\n\t_setAutoZIndex: function (compare) {\n\t\t// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n\n\t\tvar layers = this.getPane().children,\n\t\t    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n\t\tfor (var i = 0, len = layers.length, zIndex; i < len; i++) {\n\n\t\t\tzIndex = layers[i].style.zIndex;\n\n\t\t\tif (layers[i] !== this._container && zIndex) {\n\t\t\t\tedgeZIndex = compare(edgeZIndex, +zIndex);\n\t\t\t}\n\t\t}\n\n\t\tif (isFinite(edgeZIndex)) {\n\t\t\tthis.options.zIndex = edgeZIndex + compare(-1, 1);\n\t\t\tthis._updateZIndex();\n\t\t}\n\t},\n\n\t_updateOpacity: function () {\n\t\tif (!this._map) { return; }\n\n\t\t// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n\t\tif (L.Browser.ielt9 || !this._map._fadeAnimated) {\n\t\t\treturn;\n\t\t}\n\n\t\tL.DomUtil.setOpacity(this._container, this.options.opacity);\n\n\t\tvar now = +new Date(),\n\t\t    nextFrame = false,\n\t\t    willPrune = false;\n\n\t\tfor (var key in this._tiles) {\n\t\t\tvar tile = this._tiles[key];\n\t\t\tif (!tile.current || !tile.loaded) { continue; }\n\n\t\t\tvar fade = Math.min(1, (now - tile.loaded) / 200);\n\n\t\t\tL.DomUtil.setOpacity(tile.el, fade);\n\t\t\tif (fade < 1) {\n\t\t\t\tnextFrame = true;\n\t\t\t} else {\n\t\t\t\tif (tile.active) { willPrune = true; }\n\t\t\t\ttile.active = true;\n\t\t\t}\n\t\t}\n\n\t\tif (willPrune && !this._noPrune) { this._pruneTiles(); }\n\n\t\tif (nextFrame) {\n\t\t\tL.Util.cancelAnimFrame(this._fadeFrame);\n\t\t\tthis._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);\n\t\t}\n\t},\n\n\t_initContainer: function () {\n\t\tif (this._container) { return; }\n\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-layer');\n\t\tthis._updateZIndex();\n\n\t\tif (this.options.opacity < 1) {\n\t\t\tthis._updateOpacity();\n\t\t}\n\n\t\tthis.getPane().appendChild(this._container);\n\t},\n\n\t_updateLevels: function () {\n\n\t\tvar zoom = this._tileZoom,\n\t\t    maxZoom = this.options.maxZoom;\n\n\t\tfor (var z in this._levels) {\n\t\t\tif (this._levels[z].el.children.length || z === zoom) {\n\t\t\t\tthis._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n\t\t\t} else {\n\t\t\t\tL.DomUtil.remove(this._levels[z].el);\n\t\t\t\tdelete this._levels[z];\n\t\t\t}\n\t\t}\n\n\t\tvar level = this._levels[zoom],\n\t\t    map = this._map;\n\n\t\tif (!level) {\n\t\t\tlevel = this._levels[zoom] = {};\n\n\t\t\tlevel.el = L.DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n\t\t\tlevel.el.style.zIndex = maxZoom;\n\n\t\t\tlevel.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n\t\t\tlevel.zoom = zoom;\n\n\t\t\tthis._setZoomTransform(level, map.getCenter(), map.getZoom());\n\n\t\t\t// force the browser to consider the newly added element for transition\n\t\t\tL.Util.falseFn(level.el.offsetWidth);\n\t\t}\n\n\t\tthis._level = level;\n\n\t\treturn level;\n\t},\n\n\t_pruneTiles: function () {\n\t\tvar key, tile;\n\n\t\tvar zoom = this._map.getZoom();\n\t\tif (zoom > this.options.maxZoom ||\n\t\t\tzoom < this.options.minZoom) { return this._removeAllTiles(); }\n\n\t\tfor (key in this._tiles) {\n\t\t\ttile = this._tiles[key];\n\t\t\ttile.retain = tile.current;\n\t\t}\n\n\t\tfor (key in this._tiles) {\n\t\t\ttile = this._tiles[key];\n\t\t\tif (tile.current && !tile.active) {\n\t\t\t\tvar coords = tile.coords;\n\t\t\t\tif (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n\t\t\t\t\tthis._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (key in this._tiles) {\n\t\t\tif (!this._tiles[key].retain) {\n\t\t\t\tthis._removeTile(key);\n\t\t\t}\n\t\t}\n\t},\n\n\t_removeAllTiles: function () {\n\t\tfor (var key in this._tiles) {\n\t\t\tthis._removeTile(key);\n\t\t}\n\t},\n\n\t_resetAll: function () {\n\t\tfor (var z in this._levels) {\n\t\t\tL.DomUtil.remove(this._levels[z].el);\n\t\t\tdelete this._levels[z];\n\t\t}\n\t\tthis._removeAllTiles();\n\n\t\tthis._tileZoom = null;\n\t\tthis._resetView();\n\t},\n\n\t_retainParent: function (x, y, z, minZoom) {\n\t\tvar x2 = Math.floor(x / 2),\n\t\t    y2 = Math.floor(y / 2),\n\t\t    z2 = z - 1;\n\n\t\tvar key = x2 + ':' + y2 + ':' + z2,\n\t\t    tile = this._tiles[key];\n\n\t\tif (tile && tile.active) {\n\t\t\ttile.retain = true;\n\t\t\treturn true;\n\n\t\t} else if (tile && tile.loaded) {\n\t\t\ttile.retain = true;\n\t\t}\n\n\t\tif (z2 > minZoom) {\n\t\t\treturn this._retainParent(x2, y2, z2, minZoom);\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_retainChildren: function (x, y, z, maxZoom) {\n\n\t\tfor (var i = 2 * x; i < 2 * x + 2; i++) {\n\t\t\tfor (var j = 2 * y; j < 2 * y + 2; j++) {\n\n\t\t\t\tvar key = i + ':' + j + ':' + (z + 1),\n\t\t\t\t    tile = this._tiles[key];\n\n\t\t\t\tif (tile && tile.active) {\n\t\t\t\t\ttile.retain = true;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} else if (tile && tile.loaded) {\n\t\t\t\t\ttile.retain = true;\n\t\t\t\t}\n\n\t\t\t\tif (z + 1 < maxZoom) {\n\t\t\t\t\tthis._retainChildren(i, j, z + 1, maxZoom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_resetView: function (e) {\n\t\tvar animating = e && (e.pinch || e.flyTo);\n\t\tthis._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n\t},\n\n\t_animateZoom: function (e) {\n\t\tthis._setView(e.center, e.zoom, true, e.noUpdate);\n\t},\n\n\t_setView: function (center, zoom, noPrune, noUpdate) {\n\t\tvar tileZoom = Math.round(zoom);\n\t\tif ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||\n\t\t    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {\n\t\t\ttileZoom = undefined;\n\t\t}\n\n\t\tvar tileZoomChanged = (tileZoom !== this._tileZoom);\n\n\t\tif (!noUpdate || tileZoomChanged) {\n\n\t\t\tthis._tileZoom = tileZoom;\n\n\t\t\tif (this._abortLoading) {\n\t\t\t\tthis._abortLoading();\n\t\t\t}\n\n\t\t\tthis._updateLevels();\n\t\t\tthis._resetGrid();\n\n\t\t\tif (tileZoom !== undefined) {\n\t\t\t\tthis._update(center);\n\t\t\t}\n\n\t\t\tif (!noPrune) {\n\t\t\t\tthis._pruneTiles();\n\t\t\t}\n\n\t\t\t// Flag to prevent _updateOpacity from pruning tiles during\n\t\t\t// a zoom anim or a pinch gesture\n\t\t\tthis._noPrune = !!noPrune;\n\t\t}\n\n\t\tthis._setZoomTransforms(center, zoom);\n\t},\n\n\t_setZoomTransforms: function (center, zoom) {\n\t\tfor (var i in this._levels) {\n\t\t\tthis._setZoomTransform(this._levels[i], center, zoom);\n\t\t}\n\t},\n\n\t_setZoomTransform: function (level, center, zoom) {\n\t\tvar scale = this._map.getZoomScale(zoom, level.zoom),\n\t\t    translate = level.origin.multiplyBy(scale)\n\t\t        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n\n\t\tif (L.Browser.any3d) {\n\t\t\tL.DomUtil.setTransform(level.el, translate, scale);\n\t\t} else {\n\t\t\tL.DomUtil.setPosition(level.el, translate);\n\t\t}\n\t},\n\n\t_resetGrid: function () {\n\t\tvar map = this._map,\n\t\t    crs = map.options.crs,\n\t\t    tileSize = this._tileSize = this.getTileSize(),\n\t\t    tileZoom = this._tileZoom;\n\n\t\tvar bounds = this._map.getPixelWorldBounds(this._tileZoom);\n\t\tif (bounds) {\n\t\t\tthis._globalTileRange = this._pxBoundsToTileRange(bounds);\n\t\t}\n\n\t\tthis._wrapX = crs.wrapLng && !this.options.noWrap && [\n\t\t\tMath.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),\n\t\t\tMath.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)\n\t\t];\n\t\tthis._wrapY = crs.wrapLat && !this.options.noWrap && [\n\t\t\tMath.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),\n\t\t\tMath.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)\n\t\t];\n\t},\n\n\t_onMoveEnd: function () {\n\t\tif (!this._map || this._map._animatingZoom) { return; }\n\n\t\tthis._resetView();\n\t},\n\n\t_getTiledPixelBounds: function (center, zoom, tileZoom) {\n\t\tvar map = this._map,\n\t\t    scale = map.getZoomScale(zoom, tileZoom),\n\t\t    pixelCenter = map.project(center, tileZoom).floor(),\n\t\t    halfSize = map.getSize().divideBy(scale * 2);\n\n\t\treturn new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n\t},\n\n\t// Private method to load tiles in the grid's active zoom level according to map bounds\n\t_update: function (center) {\n\t\tvar map = this._map;\n\t\tif (!map) { return; }\n\t\tvar zoom = map.getZoom();\n\n\t\tif (center === undefined) { center = map.getCenter(); }\n\t\tif (this._tileZoom === undefined) { return; }\t// if out of minzoom/maxzoom\n\n\t\tvar pixelBounds = this._getTiledPixelBounds(center, zoom, this._tileZoom),\n\t\t    tileRange = this._pxBoundsToTileRange(pixelBounds),\n\t\t    tileCenter = tileRange.getCenter(),\n\t\t    queue = [];\n\n\t\tfor (var key in this._tiles) {\n\t\t\tthis._tiles[key].current = false;\n\t\t}\n\n\t\t// _update just loads more tiles. If the tile zoom level differs too much\n\t\t// from the map's, let _setView reset levels and prune old tiles.\n\t\tif (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }\n\n\t\t// create a queue of coordinates to load tiles from\n\t\tfor (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n\t\t\tfor (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n\t\t\t\tvar coords = new L.Point(i, j);\n\t\t\t\tcoords.z = this._tileZoom;\n\n\t\t\t\tif (!this._isValidTile(coords)) { continue; }\n\n\t\t\t\tvar tile = this._tiles[this._tileCoordsToKey(coords)];\n\t\t\t\tif (tile) {\n\t\t\t\t\ttile.current = true;\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push(coords);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// sort tile queue to load tiles in order of their distance to center\n\t\tqueue.sort(function (a, b) {\n\t\t\treturn a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n\t\t});\n\n\t\tif (queue.length !== 0) {\n\t\t\t// if its the first batch of tiles to load\n\t\t\tif (!this._loading) {\n\t\t\t\tthis._loading = true;\n\t\t\t\tthis.fire('loading');\n\t\t\t}\n\n\t\t\t// create DOM fragment to append tiles in one batch\n\t\t\tvar fragment = document.createDocumentFragment();\n\n\t\t\tfor (i = 0; i < queue.length; i++) {\n\t\t\t\tthis._addTile(queue[i], fragment);\n\t\t\t}\n\n\t\t\tthis._level.el.appendChild(fragment);\n\t\t}\n\t},\n\n\t_isValidTile: function (coords) {\n\t\tvar crs = this._map.options.crs;\n\n\t\tif (!crs.infinite) {\n\t\t\t// don't load tile if it's out of bounds and not wrapped\n\t\t\tvar bounds = this._globalTileRange;\n\t\t\tif ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||\n\t\t\t    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }\n\t\t}\n\n\t\tif (!this.options.bounds) { return true; }\n\n\t\t// don't load tile if it doesn't intersect the bounds in options\n\t\tvar tileBounds = this._tileCoordsToBounds(coords);\n\t\treturn L.latLngBounds(this.options.bounds).overlaps(tileBounds);\n\t},\n\n\t_keyToBounds: function (key) {\n\t\treturn this._tileCoordsToBounds(this._keyToTileCoords(key));\n\t},\n\n\t// converts tile coordinates to its geographical bounds\n\t_tileCoordsToBounds: function (coords) {\n\n\t\tvar map = this._map,\n\t\t    tileSize = this.getTileSize(),\n\n\t\t    nwPoint = coords.scaleBy(tileSize),\n\t\t    sePoint = nwPoint.add(tileSize),\n\n\t\t    nw = map.wrapLatLng(map.unproject(nwPoint, coords.z)),\n\t\t    se = map.wrapLatLng(map.unproject(sePoint, coords.z));\n\n\t\treturn new L.LatLngBounds(nw, se);\n\t},\n\n\t// converts tile coordinates to key for the tile cache\n\t_tileCoordsToKey: function (coords) {\n\t\treturn coords.x + ':' + coords.y + ':' + coords.z;\n\t},\n\n\t// converts tile cache key to coordinates\n\t_keyToTileCoords: function (key) {\n\t\tvar k = key.split(':'),\n\t\t    coords = new L.Point(+k[0], +k[1]);\n\t\tcoords.z = +k[2];\n\t\treturn coords;\n\t},\n\n\t_removeTile: function (key) {\n\t\tvar tile = this._tiles[key];\n\t\tif (!tile) { return; }\n\n\t\tL.DomUtil.remove(tile.el);\n\n\t\tdelete this._tiles[key];\n\n\t\tthis.fire('tileunload', {\n\t\t\ttile: tile.el,\n\t\t\tcoords: this._keyToTileCoords(key)\n\t\t});\n\t},\n\n\t_initTile: function (tile) {\n\t\tL.DomUtil.addClass(tile, 'leaflet-tile');\n\n\t\tvar tileSize = this.getTileSize();\n\t\ttile.style.width = tileSize.x + 'px';\n\t\ttile.style.height = tileSize.y + 'px';\n\n\t\ttile.onselectstart = L.Util.falseFn;\n\t\ttile.onmousemove = L.Util.falseFn;\n\n\t\t// update opacity on tiles in IE7-8 because of filter inheritance problems\n\t\tif (L.Browser.ielt9 && this.options.opacity < 1) {\n\t\t\tL.DomUtil.setOpacity(tile, this.options.opacity);\n\t\t}\n\n\t\t// without this hack, tiles disappear after zoom on Chrome for Android\n\t\t// https://github.com/Leaflet/Leaflet/issues/2078\n\t\tif (L.Browser.android && !L.Browser.android23) {\n\t\t\ttile.style.WebkitBackfaceVisibility = 'hidden';\n\t\t}\n\t},\n\n\t_addTile: function (coords, container) {\n\t\tvar tilePos = this._getTilePos(coords),\n\t\t    key = this._tileCoordsToKey(coords);\n\n\t\tvar tile = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords));\n\n\t\tthis._initTile(tile);\n\n\t\t// if createTile is defined with a second argument (\"done\" callback),\n\t\t// we know that tile is async and will be ready later; otherwise\n\t\tif (this.createTile.length < 2) {\n\t\t\t// mark tile as ready, but delay one frame for opacity animation to happen\n\t\t\tL.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));\n\t\t}\n\n\t\tL.DomUtil.setPosition(tile, tilePos);\n\n\t\t// save tile in cache\n\t\tthis._tiles[key] = {\n\t\t\tel: tile,\n\t\t\tcoords: coords,\n\t\t\tcurrent: true\n\t\t};\n\n\t\tcontainer.appendChild(tile);\n\t\tthis.fire('tileloadstart', {\n\t\t\ttile: tile,\n\t\t\tcoords: coords\n\t\t});\n\t},\n\n\t_tileReady: function (coords, err, tile) {\n\t\tif (!this._map) { return; }\n\n\t\tif (err) {\n\t\t\tthis.fire('tileerror', {\n\t\t\t\terror: err,\n\t\t\t\ttile: tile,\n\t\t\t\tcoords: coords\n\t\t\t});\n\t\t}\n\n\t\tvar key = this._tileCoordsToKey(coords);\n\n\t\ttile = this._tiles[key];\n\t\tif (!tile) { return; }\n\n\t\ttile.loaded = +new Date();\n\t\tif (this._map._fadeAnimated) {\n\t\t\tL.DomUtil.setOpacity(tile.el, 0);\n\t\t\tL.Util.cancelAnimFrame(this._fadeFrame);\n\t\t\tthis._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);\n\t\t} else {\n\t\t\ttile.active = true;\n\t\t\tthis._pruneTiles();\n\t\t}\n\n\t\tL.DomUtil.addClass(tile.el, 'leaflet-tile-loaded');\n\n\t\tthis.fire('tileload', {\n\t\t\ttile: tile.el,\n\t\t\tcoords: coords\n\t\t});\n\n\t\tif (this._noTilesToLoad()) {\n\t\t\tthis._loading = false;\n\t\t\tthis.fire('load');\n\t\t}\n\t},\n\n\t_getTilePos: function (coords) {\n\t\treturn coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n\t},\n\n\t_wrapCoords: function (coords) {\n\t\tvar newCoords = new L.Point(\n\t\t\tthis._wrapX ? L.Util.wrapNum(coords.x, this._wrapX) : coords.x,\n\t\t\tthis._wrapY ? L.Util.wrapNum(coords.y, this._wrapY) : coords.y);\n\t\tnewCoords.z = coords.z;\n\t\treturn newCoords;\n\t},\n\n\t_pxBoundsToTileRange: function (bounds) {\n\t\tvar tileSize = this.getTileSize();\n\t\treturn new L.Bounds(\n\t\t\tbounds.min.unscaleBy(tileSize).floor(),\n\t\t\tbounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n\t},\n\n\t_noTilesToLoad: function () {\n\t\tfor (var key in this._tiles) {\n\t\t\tif (!this._tiles[key].loaded) { return false; }\n\t\t}\n\t\treturn true;\n\t}\n});\n\nL.gridLayer = function (options) {\n\treturn new L.GridLayer(options);\n};\n\n\n\n/*\r\n * L.TileLayer is used for standard xyz-numbered tile layers.\r\n */\r\n\r\nL.TileLayer = L.GridLayer.extend({\r\n\r\n\toptions: {\r\n\t\tmaxZoom: 18,\r\n\r\n\t\tsubdomains: 'abc',\r\n\t\terrorTileUrl: '',\r\n\t\tzoomOffset: 0,\r\n\r\n\t\tmaxNativeZoom: null, // Number\r\n\t\ttms: false,\r\n\t\tzoomReverse: false,\r\n\t\tdetectRetina: false,\r\n\t\tcrossOrigin: false\r\n\t},\r\n\r\n\tinitialize: function (url, options) {\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n\t\tif (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\r\n\r\n\t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\t\t\toptions.zoomOffset++;\r\n\r\n\t\t\toptions.minZoom = Math.max(0, options.minZoom);\r\n\t\t\toptions.maxZoom--;\r\n\t\t}\r\n\r\n\t\tif (typeof options.subdomains === 'string') {\r\n\t\t\toptions.subdomains = options.subdomains.split('');\r\n\t\t}\r\n\r\n\t\t// for https://github.com/Leaflet/Leaflet/issues/137\r\n\t\tif (!L.Browser.android) {\r\n\t\t\tthis.on('tileunload', this._onTileRemove);\r\n\t\t}\r\n\t},\r\n\r\n\tsetUrl: function (url, noRedraw) {\r\n\t\tthis._url = url;\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tcreateTile: function (coords, done) {\r\n\t\tvar tile = document.createElement('img');\r\n\r\n\t\tL.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile));\r\n\t\tL.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile));\r\n\r\n\t\tif (this.options.crossOrigin) {\r\n\t\t\ttile.crossOrigin = '';\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\r\n\t\t http://www.w3.org/TR/WCAG20-TECHS/H67\r\n\t\t*/\r\n\t\ttile.alt = '';\r\n\r\n\t\ttile.src = this.getTileUrl(coords);\r\n\r\n\t\treturn tile;\r\n\t},\r\n\r\n\tgetTileUrl: function (coords) {\r\n\t\treturn L.Util.template(this._url, L.extend({\r\n\t\t\tr: this.options.detectRetina && L.Browser.retina && this.options.maxZoom > 0 ? '@2x' : '',\r\n\t\t\ts: this._getSubdomain(coords),\r\n\t\t\tx: coords.x,\r\n\t\t\ty: this.options.tms ? this._globalTileRange.max.y - coords.y : coords.y,\r\n\t\t\tz: this._getZoomForUrl()\r\n\t\t}, this.options));\r\n\t},\r\n\r\n\t_tileOnLoad: function (done, tile) {\r\n\t\t// For https://github.com/Leaflet/Leaflet/issues/3332\r\n\t\tif (L.Browser.ielt9) {\r\n\t\t\tsetTimeout(L.bind(done, this, null, tile), 0);\r\n\t\t} else {\r\n\t\t\tdone(null, tile);\r\n\t\t}\r\n\t},\r\n\r\n\t_tileOnError: function (done, tile, e) {\r\n\t\tvar errorUrl = this.options.errorTileUrl;\r\n\t\tif (errorUrl) {\r\n\t\t\ttile.src = errorUrl;\r\n\t\t}\r\n\t\tdone(e, tile);\r\n\t},\r\n\r\n\tgetTileSize: function () {\r\n\t\tvar map = this._map,\r\n\t\t    tileSize = L.GridLayer.prototype.getTileSize.call(this),\r\n\t\t    zoom = this._tileZoom + this.options.zoomOffset,\r\n\t\t    zoomN = this.options.maxNativeZoom;\r\n\r\n\t\t// increase tile size when overscaling\r\n\t\treturn zoomN !== null && zoom > zoomN ?\r\n\t\t\t\ttileSize.divideBy(map.getZoomScale(zoomN, zoom)).round() :\r\n\t\t\t\ttileSize;\r\n\t},\r\n\r\n\t_onTileRemove: function (e) {\r\n\t\te.tile.onload = null;\r\n\t},\r\n\r\n\t_getZoomForUrl: function () {\r\n\r\n\t\tvar options = this.options,\r\n\t\t    zoom = this._tileZoom;\r\n\r\n\t\tif (options.zoomReverse) {\r\n\t\t\tzoom = options.maxZoom - zoom;\r\n\t\t}\r\n\r\n\t\tzoom += options.zoomOffset;\r\n\r\n\t\treturn options.maxNativeZoom !== null ? Math.min(zoom, options.maxNativeZoom) : zoom;\r\n\t},\r\n\r\n\t_getSubdomain: function (tilePoint) {\r\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n\t\treturn this.options.subdomains[index];\r\n\t},\r\n\r\n\t// stops loading all tiles in the background layer\r\n\t_abortLoading: function () {\r\n\t\tvar i, tile;\r\n\t\tfor (i in this._tiles) {\r\n\t\t\tif (this._tiles[i].coords.z !== this._tileZoom) {\r\n\t\t\t\ttile = this._tiles[i].el;\r\n\r\n\t\t\t\ttile.onload = L.Util.falseFn;\r\n\t\t\t\ttile.onerror = L.Util.falseFn;\r\n\r\n\t\t\t\tif (!tile.complete) {\r\n\t\t\t\t\ttile.src = L.Util.emptyImageUrl;\r\n\t\t\t\t\tL.DomUtil.remove(tile);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.tileLayer = function (url, options) {\r\n\treturn new L.TileLayer(url, options);\r\n};\r\n\n\n\n/*\r\n * L.TileLayer.WMS is used for WMS tile layers.\r\n */\r\n\r\nL.TileLayer.WMS = L.TileLayer.extend({\r\n\r\n\tdefaultWmsParams: {\r\n\t\tservice: 'WMS',\r\n\t\trequest: 'GetMap',\r\n\t\tversion: '1.1.1',\r\n\t\tlayers: '',\r\n\t\tstyles: '',\r\n\t\tformat: 'image/jpeg',\r\n\t\ttransparent: false\r\n\t},\r\n\r\n\toptions: {\r\n\t\tcrs: null,\r\n\t\tuppercase: false\r\n\t},\r\n\r\n\tinitialize: function (url, options) {\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar wmsParams = L.extend({}, this.defaultWmsParams);\r\n\r\n\t\t// all keys that are not TileLayer options go to WMS params\r\n\t\tfor (var i in options) {\r\n\t\t\tif (!(i in this.options)) {\r\n\t\t\t\twmsParams[i] = options[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\twmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);\r\n\r\n\t\tthis.wmsParams = wmsParams;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\r\n\t\tthis._crs = this.options.crs || map.options.crs;\r\n\t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n\t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n\t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\r\n\t\tL.TileLayer.prototype.onAdd.call(this, map);\r\n\t},\r\n\r\n\tgetTileUrl: function (coords) {\r\n\r\n\t\tvar tileBounds = this._tileCoordsToBounds(coords),\r\n\t\t    nw = this._crs.project(tileBounds.getNorthWest()),\r\n\t\t    se = this._crs.project(tileBounds.getSouthEast()),\r\n\r\n\t\t    bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?\r\n\t\t\t    [se.y, nw.x, nw.y, se.x] :\r\n\t\t\t    [nw.x, se.y, se.x, nw.y]).join(','),\r\n\r\n\t\t    url = L.TileLayer.prototype.getTileUrl.call(this, coords);\r\n\r\n\t\treturn url +\r\n\t\t\tL.Util.getParamString(this.wmsParams, url, this.options.uppercase) +\r\n\t\t\t(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\r\n\t},\r\n\r\n\tsetParams: function (params, noRedraw) {\r\n\r\n\t\tL.extend(this.wmsParams, params);\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.tileLayer.wms = function (url, options) {\r\n\treturn new L.TileLayer.WMS(url, options);\r\n};\r\n\n\n\n/*\r\n * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\r\n */\r\n\r\nL.ImageOverlay = L.Layer.extend({\r\n\r\n\toptions: {\r\n\t\topacity: 1,\r\n\t\talt: '',\r\n\t\tinteractive: false\r\n\r\n\t\t/*\r\n\t\tcrossOrigin: <Boolean>,\r\n\t\t*/\r\n\t},\r\n\r\n\tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n\t\tthis._url = url;\r\n\t\tthis._bounds = L.latLngBounds(bounds);\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function () {\r\n\t\tif (!this._image) {\r\n\t\t\tthis._initImage();\r\n\r\n\t\t\tif (this.options.opacity < 1) {\r\n\t\t\t\tthis._updateOpacity();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.options.interactive) {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-interactive');\r\n\t\t\tthis.addInteractiveTarget(this._image);\r\n\t\t}\r\n\r\n\t\tthis.getPane().appendChild(this._image);\r\n\t\tthis._reset();\r\n\t},\r\n\r\n\tonRemove: function () {\r\n\t\tL.DomUtil.remove(this._image);\r\n\t\tif (this.options.interactive) {\r\n\t\t\tthis.removeInteractiveTarget(this._image);\r\n\t\t}\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\r\n\t\tif (this._image) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (styleOpts) {\r\n\t\tif (styleOpts.opacity) {\r\n\t\t\tthis.setOpacity(styleOpts.opacity);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tif (this._map) {\r\n\t\t\tL.DomUtil.toFront(this._image);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tif (this._map) {\r\n\t\t\tL.DomUtil.toBack(this._image);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url) {\r\n\t\tthis._url = url;\r\n\r\n\t\tif (this._image) {\r\n\t\t\tthis._image.src = url;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetBounds: function (bounds) {\r\n\t\tthis._bounds = bounds;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\tgetEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tzoom: this._reset,\r\n\t\t\tviewreset: this._reset\r\n\t\t};\r\n\r\n\t\tif (this._zoomAnimated) {\r\n\t\t\tevents.zoomanim = this._animateZoom;\r\n\t\t}\r\n\r\n\t\treturn events;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\treturn this._bounds;\r\n\t},\r\n\r\n\tgetElement: function () {\r\n\t\treturn this._image;\r\n\t},\r\n\r\n\t_initImage: function () {\r\n\t\tvar img = this._image = L.DomUtil.create('img',\r\n\t\t\t\t'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));\r\n\r\n\t\timg.onselectstart = L.Util.falseFn;\r\n\t\timg.onmousemove = L.Util.falseFn;\r\n\r\n\t\timg.onload = L.bind(this.fire, this, 'load');\r\n\r\n\t\tif (this.options.crossOrigin) {\r\n\t\t\timg.crossOrigin = '';\r\n\t\t}\r\n\r\n\t\timg.src = this._url;\r\n\t\timg.alt = this.options.alt;\r\n\t},\r\n\r\n\t_animateZoom: function (e) {\r\n\t\tvar scale = this._map.getZoomScale(e.zoom),\r\n\t\t    offset = this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), e.zoom, e.center);\r\n\r\n\t\tL.DomUtil.setTransform(this._image, offset, scale);\r\n\t},\r\n\r\n\t_reset: function () {\r\n\t\tvar image = this._image,\r\n\t\t    bounds = new L.Bounds(\r\n\t\t        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n\t\t        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\r\n\t\t    size = bounds.getSize();\r\n\r\n\t\tL.DomUtil.setPosition(image, bounds.min);\r\n\r\n\t\timage.style.width  = size.x + 'px';\r\n\t\timage.style.height = size.y + 'px';\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._image, this.options.opacity);\r\n\t}\r\n});\r\n\r\nL.imageOverlay = function (url, bounds, options) {\r\n\treturn new L.ImageOverlay(url, bounds, options);\r\n};\r\n\n\n\n/*\r\n * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\r\n */\r\n\r\nL.Icon = L.Class.extend({\r\n\t/*\r\n\toptions: {\r\n\t\ticonUrl: (String) (required)\r\n\t\ticonRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\ticonSize: (Point) (can be set through CSS)\r\n\t\ticonAnchor: (Point) (centered by default, can be set in CSS with negative margins)\r\n\t\tpopupAnchor: (Point) (if not specified, popup opens in the anchor point)\r\n\t\tshadowUrl: (String) (no shadow by default)\r\n\t\tshadowRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\tshadowSize: (Point)\r\n\t\tshadowAnchor: (Point)\r\n\t\tclassName: (String)\r\n\t},\r\n\t*/\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tcreateIcon: function (oldIcon) {\r\n\t\treturn this._createIcon('icon', oldIcon);\r\n\t},\r\n\r\n\tcreateShadow: function (oldIcon) {\r\n\t\treturn this._createIcon('shadow', oldIcon);\r\n\t},\r\n\r\n\t_createIcon: function (name, oldIcon) {\r\n\t\tvar src = this._getIconUrl(name);\r\n\r\n\t\tif (!src) {\r\n\t\t\tif (name === 'icon') {\r\n\t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\r\n\t\tthis._setIconStyles(img, name);\r\n\r\n\t\treturn img;\r\n\t},\r\n\r\n\t_setIconStyles: function (img, name) {\r\n\t\tvar options = this.options,\r\n\t\t    size = L.point(options[name + 'Size']),\r\n\t\t    anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||\r\n\t\t            size && size.divideBy(2, true));\r\n\r\n\t\timg.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\r\n\r\n\t\tif (anchor) {\r\n\t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n\t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n\t\t}\r\n\r\n\t\tif (size) {\r\n\t\t\timg.style.width  = size.x + 'px';\r\n\t\t\timg.style.height = size.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\t_createImg: function (src, el) {\r\n\t\tel = el || document.createElement('img');\r\n\t\tel.src = src;\r\n\t\treturn el;\r\n\t},\r\n\r\n\t_getIconUrl: function (name) {\r\n\t\treturn L.Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\r\n\t}\r\n});\r\n\r\nL.icon = function (options) {\r\n\treturn new L.Icon(options);\r\n};\r\n\n\n\n/*\n * L.Icon.Default is the blue marker icon used by default in Leaflet.\n */\n\nL.Icon.Default = L.Icon.extend({\n\n\toptions: {\n\t\ticonSize:    [25, 41],\n\t\ticonAnchor:  [12, 41],\n\t\tpopupAnchor: [1, -34],\n\t\tshadowSize:  [41, 41]\n\t},\n\n\t_getIconUrl: function (name) {\n\t\tvar key = name + 'Url';\n\n\t\tif (this.options[key]) {\n\t\t\treturn this.options[key];\n\t\t}\n\n\t\tvar path = L.Icon.Default.imagePath;\n\n\t\tif (!path) {\n\t\t\tthrow new Error('Couldn\\'t autodetect L.Icon.Default.imagePath, set it manually.');\n\t\t}\n\n\t\treturn path + '/marker-' + name + (L.Browser.retina && name === 'icon' ? '-2x' : '') + '.png';\n\t}\n});\n\nL.Icon.Default.imagePath = (function () {\n\tvar scripts = document.getElementsByTagName('script'),\n\t    leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n\tvar i, len, src, path;\n\n\tfor (i = 0, len = scripts.length; i < len; i++) {\n\t\tsrc = scripts[i].src || '';\n\n\t\tif (src.match(leafletRe)) {\n\t\t\tpath = src.split(leafletRe)[0];\n\t\t\treturn (path ? path + '/' : '') + 'images';\n\t\t}\n\t}\n}());\n\n\n\n/*\r\n * L.Marker is used to display clickable/draggable icons on the map.\r\n */\r\n\r\nL.Marker = L.Layer.extend({\r\n\r\n\toptions: {\r\n\t\tpane: 'markerPane',\r\n\t\tnonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\r\n\r\n\t\ticon: new L.Icon.Default(),\r\n\t\t// title: '',\r\n\t\t// alt: '',\r\n\t\tinteractive: true,\r\n\t\t// draggable: false,\r\n\t\tkeyboard: true,\r\n\t\tzIndexOffset: 0,\r\n\t\topacity: 1,\r\n\t\t// riseOnHover: false,\r\n\t\triseOffset: 250\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.setOptions(this, options);\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\r\n\r\n\t\tthis._initIcon();\r\n\t\tthis.update();\r\n\t},\r\n\r\n\tonRemove: function () {\r\n\t\tif (this.dragging && this.dragging.enabled()) {\r\n\t\t\tthis.options.draggable = true;\r\n\t\t\tthis.dragging.removeHooks();\r\n\t\t}\r\n\r\n\t\tthis._removeIcon();\r\n\t\tthis._removeShadow();\r\n\t},\r\n\r\n\tgetEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tzoom: this.update,\r\n\t\t\tviewreset: this.update\r\n\t\t};\r\n\r\n\t\tif (this._zoomAnimated) {\r\n\t\t\tevents.zoomanim = this._animateZoom;\r\n\t\t}\r\n\r\n\t\treturn events;\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tvar oldLatLng = this._latlng;\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tthis.update();\r\n\t\treturn this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});\r\n\t},\r\n\r\n\tsetZIndexOffset: function (offset) {\r\n\t\tthis.options.zIndexOffset = offset;\r\n\t\treturn this.update();\r\n\t},\r\n\r\n\tsetIcon: function (icon) {\r\n\r\n\t\tthis.options.icon = icon;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._initIcon();\r\n\t\t\tthis.update();\r\n\t\t}\r\n\r\n\t\tif (this._popup) {\r\n\t\t\tthis.bindPopup(this._popup, this._popup.options);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetElement: function () {\r\n\t\treturn this._icon;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\r\n\t\tif (this._icon) {\r\n\t\t\tvar pos = this._map.latLngToLayerPoint(this._latlng).round();\r\n\t\t\tthis._setPos(pos);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initIcon: function () {\r\n\t\tvar options = this.options,\r\n\t\t    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\r\n\r\n\t\tvar icon = options.icon.createIcon(this._icon),\r\n\t\t    addIcon = false;\r\n\r\n\t\t// if we're not reusing the icon, remove the old one and init new one\r\n\t\tif (icon !== this._icon) {\r\n\t\t\tif (this._icon) {\r\n\t\t\t\tthis._removeIcon();\r\n\t\t\t}\r\n\t\t\taddIcon = true;\r\n\r\n\t\t\tif (options.title) {\r\n\t\t\t\ticon.title = options.title;\r\n\t\t\t}\r\n\t\t\tif (options.alt) {\r\n\t\t\t\ticon.alt = options.alt;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tL.DomUtil.addClass(icon, classToAdd);\r\n\r\n\t\tif (options.keyboard) {\r\n\t\t\ticon.tabIndex = '0';\r\n\t\t}\r\n\r\n\t\tthis._icon = icon;\r\n\r\n\t\tif (options.riseOnHover) {\r\n\t\t\tthis.on({\r\n\t\t\t\tmouseover: this._bringToFront,\r\n\t\t\t\tmouseout: this._resetZIndex\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n\t\t    addShadow = false;\r\n\r\n\t\tif (newShadow !== this._shadow) {\r\n\t\t\tthis._removeShadow();\r\n\t\t\taddShadow = true;\r\n\t\t}\r\n\r\n\t\tif (newShadow) {\r\n\t\t\tL.DomUtil.addClass(newShadow, classToAdd);\r\n\t\t}\r\n\t\tthis._shadow = newShadow;\r\n\r\n\r\n\t\tif (options.opacity < 1) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\r\n\t\tif (addIcon) {\r\n\t\t\tthis.getPane().appendChild(this._icon);\r\n\t\t\tthis._initInteraction();\r\n\t\t}\r\n\t\tif (newShadow && addShadow) {\r\n\t\t\tthis.getPane('shadowPane').appendChild(this._shadow);\r\n\t\t}\r\n\t},\r\n\r\n\t_removeIcon: function () {\r\n\t\tif (this.options.riseOnHover) {\r\n\t\t\tthis.off({\r\n\t\t\t\tmouseover: this._bringToFront,\r\n\t\t\t\tmouseout: this._resetZIndex\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tL.DomUtil.remove(this._icon);\r\n\t\tthis.removeInteractiveTarget(this._icon);\r\n\r\n\t\tthis._icon = null;\r\n\t},\r\n\r\n\t_removeShadow: function () {\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.remove(this._shadow);\r\n\t\t}\r\n\t\tthis._shadow = null;\r\n\t},\r\n\r\n\t_setPos: function (pos) {\r\n\t\tL.DomUtil.setPosition(this._icon, pos);\r\n\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setPosition(this._shadow, pos);\r\n\t\t}\r\n\r\n\t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n\t\tthis._resetZIndex();\r\n\t},\r\n\r\n\t_updateZIndex: function (offset) {\r\n\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n\t},\r\n\r\n\t_animateZoom: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n\t\tthis._setPos(pos);\r\n\t},\r\n\r\n\t_initInteraction: function () {\r\n\r\n\t\tif (!this.options.interactive) { return; }\r\n\r\n\t\tL.DomUtil.addClass(this._icon, 'leaflet-interactive');\r\n\r\n\t\tthis.addInteractiveTarget(this._icon);\r\n\r\n\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\tvar draggable = this.options.draggable;\r\n\t\t\tif (this.dragging) {\r\n\t\t\t\tdraggable = this.dragging.enabled();\r\n\t\t\t\tthis.dragging.disable();\r\n\t\t\t}\r\n\r\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n\t\t\tif (draggable) {\r\n\t\t\t\tthis.dragging.enable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tvar opacity = this.options.opacity;\r\n\r\n\t\tL.DomUtil.setOpacity(this._icon, opacity);\r\n\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setOpacity(this._shadow, opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_bringToFront: function () {\r\n\t\tthis._updateZIndex(this.options.riseOffset);\r\n\t},\r\n\r\n\t_resetZIndex: function () {\r\n\t\tthis._updateZIndex(0);\r\n\t}\r\n});\r\n\r\nL.marker = function (latlng, options) {\r\n\treturn new L.Marker(latlng, options);\r\n};\r\n\n\n\n/*\n * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n * to use with L.Marker.\n */\n\nL.DivIcon = L.Icon.extend({\n\toptions: {\n\t\ticonSize: [12, 12], // also can be set through CSS\n\t\t/*\n\t\ticonAnchor: (Point)\n\t\tpopupAnchor: (Point)\n\t\thtml: (String)\n\t\tbgPos: (Point)\n\t\t*/\n\t\tclassName: 'leaflet-div-icon',\n\t\thtml: false\n\t},\n\n\tcreateIcon: function (oldIcon) {\n\t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n\t\t    options = this.options;\n\n\t\tdiv.innerHTML = options.html !== false ? options.html : '';\n\n\t\tif (options.bgPos) {\n\t\t\tdiv.style.backgroundPosition = (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n\t\t}\n\t\tthis._setIconStyles(div, 'icon');\n\n\t\treturn div;\n\t},\n\n\tcreateShadow: function () {\n\t\treturn null;\n\t}\n});\n\nL.divIcon = function (options) {\n\treturn new L.DivIcon(options);\n};\n\n\n\n/*\r\n * L.Popup is used for displaying popups on the map.\r\n */\r\n\r\nL.Map.mergeOptions({\r\n\tclosePopupOnClick: true\r\n});\r\n\r\nL.Popup = L.Layer.extend({\r\n\r\n\toptions: {\r\n\t\tpane: 'popupPane',\r\n\r\n\t\tminWidth: 50,\r\n\t\tmaxWidth: 300,\r\n\t\t// maxHeight: <Number>,\r\n\t\toffset: [0, 7],\r\n\r\n\t\tautoPan: true,\r\n\t\tautoPanPadding: [5, 5],\r\n\t\t// autoPanPaddingTopLeft: <Point>,\r\n\t\t// autoPanPaddingBottomRight: <Point>,\r\n\r\n\t\tcloseButton: true,\r\n\t\tautoClose: true,\r\n\t\t// keepInView: false,\r\n\t\t// className: '',\r\n\t\tzoomAnimation: true\r\n\t},\r\n\r\n\tinitialize: function (options, source) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._source = source;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._zoomAnimated = this._zoomAnimated && this.options.zoomAnimation;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initLayout();\r\n\t\t}\r\n\r\n\t\tif (map._fadeAnimated) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\r\n\t\tclearTimeout(this._removeTimeout);\r\n\t\tthis.getPane().appendChild(this._container);\r\n\t\tthis.update();\r\n\r\n\t\tif (map._fadeAnimated) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 1);\r\n\t\t}\r\n\r\n\t\tmap.fire('popupopen', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupopen', {popup: this}, true);\r\n\t\t}\r\n\t},\r\n\r\n\topenOn: function (map) {\r\n\t\tmap.openPopup(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tif (map._fadeAnimated) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t\tthis._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.remove(this._container);\r\n\t\t}\r\n\r\n\t\tmap.fire('popupclose', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupclose', {popup: this}, true);\r\n\t\t}\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tif (this._map) {\r\n\t\t\tthis._updatePosition();\r\n\t\t\tthis._adjustPan();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContent: function () {\r\n\t\treturn this._content;\r\n\t},\r\n\r\n\tsetContent: function (content) {\r\n\t\tthis._content = content;\r\n\t\tthis.update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetElement: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._container.style.visibility = 'hidden';\r\n\r\n\t\tthis._updateContent();\r\n\t\tthis._updateLayout();\r\n\t\tthis._updatePosition();\r\n\r\n\t\tthis._container.style.visibility = '';\r\n\r\n\t\tthis._adjustPan();\r\n\t},\r\n\r\n\tgetEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tzoom: this._updatePosition,\r\n\t\t\tviewreset: this._updatePosition\r\n\t\t};\r\n\r\n\t\tif (this._zoomAnimated) {\r\n\t\t\tevents.zoomanim = this._animateZoom;\r\n\t\t}\r\n\t\tif ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n\t\t\tevents.preclick = this._close;\r\n\t\t}\r\n\t\tif (this.options.keepInView) {\r\n\t\t\tevents.moveend = this._adjustPan;\r\n\t\t}\r\n\t\treturn events;\r\n\t},\r\n\r\n\tisOpen: function () {\r\n\t\treturn !!this._map && this._map.hasLayer(this);\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tif (this._map) {\r\n\t\t\tL.DomUtil.toFront(this._container);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tif (this._map) {\r\n\t\t\tL.DomUtil.toBack(this._container);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_close: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.closePopup(this);\r\n\t\t}\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar prefix = 'leaflet-popup',\r\n\t\t    container = this._container = L.DomUtil.create('div',\r\n\t\t\tprefix + ' ' + (this.options.className || '') +\r\n\t\t\t' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide'));\r\n\r\n\t\tif (this.options.closeButton) {\r\n\t\t\tvar closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);\r\n\t\t\tcloseButton.href = '#close';\r\n\t\t\tcloseButton.innerHTML = '&#215;';\r\n\r\n\t\t\tL.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\r\n\t\t}\r\n\r\n\t\tvar wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);\r\n\t\tthis._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\r\n\r\n\t\tL.DomEvent\r\n\t\t\t.disableClickPropagation(wrapper)\r\n\t\t\t.disableScrollPropagation(this._contentNode)\r\n\t\t\t.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\r\n\r\n\t\tthis._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\r\n\t\tthis._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\r\n\t},\r\n\r\n\t_updateContent: function () {\r\n\t\tif (!this._content) { return; }\r\n\r\n\t\tvar node = this._contentNode;\r\n\t\tvar content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;\r\n\r\n\t\tif (typeof content === 'string') {\r\n\t\t\tnode.innerHTML = content;\r\n\t\t} else {\r\n\t\t\twhile (node.hasChildNodes()) {\r\n\t\t\t\tnode.removeChild(node.firstChild);\r\n\t\t\t}\r\n\t\t\tnode.appendChild(content);\r\n\t\t}\r\n\t\tthis.fire('contentupdate');\r\n\t},\r\n\r\n\t_updateLayout: function () {\r\n\t\tvar container = this._contentNode,\r\n\t\t    style = container.style;\r\n\r\n\t\tstyle.width = '';\r\n\t\tstyle.whiteSpace = 'nowrap';\r\n\r\n\t\tvar width = container.offsetWidth;\r\n\t\twidth = Math.min(width, this.options.maxWidth);\r\n\t\twidth = Math.max(width, this.options.minWidth);\r\n\r\n\t\tstyle.width = (width + 1) + 'px';\r\n\t\tstyle.whiteSpace = '';\r\n\r\n\t\tstyle.height = '';\r\n\r\n\t\tvar height = container.offsetHeight,\r\n\t\t    maxHeight = this.options.maxHeight,\r\n\t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n\t\tif (maxHeight && height > maxHeight) {\r\n\t\t\tstyle.height = maxHeight + 'px';\r\n\t\t\tL.DomUtil.addClass(container, scrolledClass);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.removeClass(container, scrolledClass);\r\n\t\t}\r\n\r\n\t\tthis._containerWidth = this._container.offsetWidth;\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n\t\t    offset = L.point(this.options.offset);\r\n\r\n\t\tif (this._zoomAnimated) {\r\n\t\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t\t} else {\r\n\t\t\toffset = offset.add(pos);\r\n\t\t}\r\n\r\n\t\tvar bottom = this._containerBottom = -offset.y,\r\n\t\t    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;\r\n\r\n\t\t// bottom position the popup in case the height of the popup changes (images loading etc)\r\n\t\tthis._container.style.bottom = bottom + 'px';\r\n\t\tthis._container.style.left = left + 'px';\r\n\t},\r\n\r\n\t_animateZoom: function (e) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\r\n\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t},\r\n\r\n\t_adjustPan: function () {\r\n\t\tif (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerHeight = this._container.offsetHeight,\r\n\t\t    containerWidth = this._containerWidth,\r\n\t\t    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n\t\tif (this._zoomAnimated) {\r\n\t\t\tlayerPos._add(L.DomUtil.getPosition(this._container));\r\n\t\t}\r\n\r\n\t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n\t\t    padding = L.point(this.options.autoPanPadding),\r\n\t\t    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\r\n\t\t    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\r\n\t\t    size = map.getSize(),\r\n\t\t    dx = 0,\r\n\t\t    dy = 0;\r\n\r\n\t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n\t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n\t\t}\r\n\t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n\t\t\tdx = containerPos.x - paddingTL.x;\r\n\t\t}\r\n\t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n\t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n\t\t}\r\n\t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n\t\t\tdy = containerPos.y - paddingTL.y;\r\n\t\t}\r\n\r\n\t\tif (dx || dy) {\r\n\t\t\tmap\r\n\t\t\t    .fire('autopanstart')\r\n\t\t\t    .panBy([dx, dy]);\r\n\t\t}\r\n\t},\r\n\r\n\t_onCloseButtonClick: function (e) {\r\n\t\tthis._close();\r\n\t\tL.DomEvent.stop(e);\r\n\t}\r\n});\r\n\r\nL.popup = function (options, source) {\r\n\treturn new L.Popup(options, source);\r\n};\r\n\r\n\r\nL.Map.include({\r\n\topenPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])\r\n\t\tif (!(popup instanceof L.Popup)) {\r\n\t\t\tpopup = new L.Popup(options).setContent(popup);\r\n\t\t}\r\n\r\n\t\tif (latlng) {\r\n\t\t\tpopup.setLatLng(latlng);\r\n\t\t}\r\n\r\n\t\tif (this.hasLayer(popup)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (this._popup && this._popup.options.autoClose) {\r\n\t\t\tthis.closePopup();\r\n\t\t}\r\n\r\n\t\tthis._popup = popup;\r\n\t\treturn this.addLayer(popup);\r\n\t},\r\n\r\n\tclosePopup: function (popup) {\r\n\t\tif (!popup || popup === this._popup) {\r\n\t\t\tpopup = this._popup;\r\n\t\t\tthis._popup = null;\r\n\t\t}\r\n\t\tif (popup) {\r\n\t\t\tthis.removeLayer(popup);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n\n/*\n * Adds popup-related methods to all layers.\n */\n\nL.Layer.include({\n\n\tbindPopup: function (content, options) {\n\n\t\tif (content instanceof L.Popup) {\n\t\t\tL.setOptions(content, options);\n\t\t\tthis._popup = content;\n\t\t\tcontent._source = this;\n\t\t} else {\n\t\t\tif (!this._popup || options) {\n\t\t\t\tthis._popup = new L.Popup(options, this);\n\t\t\t}\n\t\t\tthis._popup.setContent(content);\n\t\t}\n\n\t\tif (!this._popupHandlersAdded) {\n\t\t\tthis.on({\n\t\t\t\tclick: this._openPopup,\n\t\t\t\tremove: this.closePopup,\n\t\t\t\tmove: this._movePopup\n\t\t\t});\n\t\t\tthis._popupHandlersAdded = true;\n\t\t}\n\n\t\t// save the originally passed offset\n\t\tthis._originalPopupOffset = this._popup.options.offset;\n\n\t\treturn this;\n\t},\n\n\tunbindPopup: function () {\n\t\tif (this._popup) {\n\t\t\tthis.off({\n\t\t\t\tclick: this._openPopup,\n\t\t\t\tremove: this.closePopup,\n\t\t\t\tmove: this._movePopup\n\t\t\t});\n\t\t\tthis._popupHandlersAdded = false;\n\t\t\tthis._popup = null;\n\t\t}\n\t\treturn this;\n\t},\n\n\topenPopup: function (layer, latlng) {\n\t\tif (!(layer instanceof L.Layer)) {\n\t\t\tlatlng = layer;\n\t\t\tlayer = this;\n\t\t}\n\n\t\tif (layer instanceof L.FeatureGroup) {\n\t\t\tfor (var id in this._layers) {\n\t\t\t\tlayer = this._layers[id];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!latlng) {\n\t\t\tlatlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();\n\t\t}\n\n\t\tif (this._popup && this._map) {\n\t\t\t// set the popup offset for this layer\n\t\t\tthis._popup.options.offset = this._popupAnchor(layer);\n\n\t\t\t// set popup source to this layer\n\t\t\tthis._popup._source = layer;\n\n\t\t\t// update the popup (content, layout, ect...)\n\t\t\tthis._popup.update();\n\n\t\t\t// open the popup on the map\n\t\t\tthis._map.openPopup(this._popup, latlng);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclosePopup: function () {\n\t\tif (this._popup) {\n\t\t\tthis._popup._close();\n\t\t}\n\t\treturn this;\n\t},\n\n\ttogglePopup: function (target) {\n\t\tif (this._popup) {\n\t\t\tif (this._popup._map) {\n\t\t\t\tthis.closePopup();\n\t\t\t} else {\n\t\t\t\tthis.openPopup(target);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\tisPopupOpen: function () {\n\t\treturn this._popup.isOpen();\n\t},\n\n\tsetPopupContent: function (content) {\n\t\tif (this._popup) {\n\t\t\tthis._popup.setContent(content);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetPopup: function () {\n\t\treturn this._popup;\n\t},\n\n\t_openPopup: function (e) {\n\t\tvar layer = e.layer || e.target;\n\n\t\tif (!this._popup) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._map) {\n\t\t\treturn;\n\t\t}\n\n\t\t// if this inherits from Path its a vector and we can just\n\t\t// open the popup at the new location\n\t\tif (layer instanceof L.Path) {\n\t\t\tthis.openPopup(e.layer || e.target, e.latlng);\n\t\t\treturn;\n\t\t}\n\n\t\t// otherwise treat it like a marker and figure out\n\t\t// if we should toggle it open/closed\n\t\tif (this._map.hasLayer(this._popup) && this._popup._source === layer) {\n\t\t\tthis.closePopup();\n\t\t} else {\n\t\t\tthis.openPopup(layer, e.latlng);\n\t\t}\n\t},\n\n\t_popupAnchor: function (layer) {\n\t\t// where shold we anchor the popup on this layer?\n\t\tvar anchor = layer._getPopupAnchor ? layer._getPopupAnchor() : [0, 0];\n\n\t\t// add the users passed offset to that\n\t\tvar offsetToAdd = this._originalPopupOffset || L.Popup.prototype.options.offset;\n\n\t\t// return the final point to anchor the popup\n\t\treturn L.point(anchor).add(offsetToAdd);\n\t},\n\n\t_movePopup: function (e) {\n\t\tthis._popup.setLatLng(e.latlng);\n\t}\n});\n\n\n\n/*\r\n * Popup extension to L.Marker, adding popup-related methods.\r\n */\r\n\r\nL.Marker.include({\r\n\t_getPopupAnchor: function () {\r\n\t\treturn this.options.icon.options.popupAnchor || [0, 0];\r\n\t}\r\n});\r\n\n\n\n/*\r\n * L.LayerGroup is a class to combine several layers into one so that\r\n * you can manipulate the group (e.g. add/remove it) as one layer.\r\n */\r\n\r\nL.LayerGroup = L.Layer.extend({\r\n\r\n\tinitialize: function (layers) {\r\n\t\tthis._layers = {};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (layers) {\r\n\t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\t\t\t\tthis.addLayer(layers[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tvar id = this.getLayerId(layer);\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.addLayer(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n\t\tif (this._map && this._layers[id]) {\r\n\t\t\tthis._map.removeLayer(this._layers[id]);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\treturn !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);\r\n\t},\r\n\r\n\tclearLayers: function () {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tthis.removeLayer(this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvoke: function (methodName) {\r\n\t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, layer;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tlayer = this._layers[i];\r\n\r\n\t\t\tif (layer[methodName]) {\r\n\t\t\t\tlayer[methodName].apply(layer, args);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmap.addLayer(this._layers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmap.removeLayer(this._layers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetLayer: function (id) {\r\n\t\treturn this._layers[id];\r\n\t},\r\n\r\n\tgetLayers: function () {\r\n\t\tvar layers = [];\r\n\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tlayers.push(this._layers[i]);\r\n\t\t}\r\n\t\treturn layers;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\treturn this.invoke('setZIndex', zIndex);\r\n\t},\r\n\r\n\tgetLayerId: function (layer) {\r\n\t\treturn L.stamp(layer);\r\n\t}\r\n});\r\n\r\nL.layerGroup = function (layers) {\r\n\treturn new L.LayerGroup(layers);\r\n};\r\n\n\n\n/*\r\n * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\r\n * shared between a group of interactive layers (like vectors or markers).\r\n */\r\n\r\nL.FeatureGroup = L.LayerGroup.extend({\r\n\r\n\taddLayer: function (layer) {\r\n\t\tif (this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tlayer.addEventParent(this);\r\n\r\n\t\tL.LayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n\t\treturn this.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tif (!this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif (layer in this._layers) {\r\n\t\t\tlayer = this._layers[layer];\r\n\t\t}\r\n\r\n\t\tlayer.removeEventParent(this);\r\n\r\n\t\tL.LayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n\t\treturn this.fire('layerremove', {layer: layer});\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\treturn this.invoke('setStyle', style);\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\treturn this.invoke('bringToFront');\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\treturn this.invoke('bringToBack');\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = new L.LatLngBounds();\r\n\r\n\t\tfor (var id in this._layers) {\r\n\t\t\tvar layer = this._layers[id];\r\n\t\t\tbounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\r\n\t\t}\r\n\t\treturn bounds;\r\n\t}\r\n});\r\n\r\nL.featureGroup = function (layers) {\r\n\treturn new L.FeatureGroup(layers);\r\n};\r\n\n\n\n/*\n * L.Renderer is a base class for renderer implementations (SVG, Canvas);\n * handles renderer container, bounds and zoom animation.\n */\n\nL.Renderer = L.Layer.extend({\n\n\toptions: {\n\t\t// how much to extend the clip area around the map view (relative to its size)\n\t\t// e.g. 0.1 would be 10% of map view in each direction; defaults to clip with the map view\n\t\tpadding: 0.1\n\t},\n\n\tinitialize: function (options) {\n\t\tL.setOptions(this, options);\n\t\tL.stamp(this);\n\t},\n\n\tonAdd: function () {\n\t\tif (!this._container) {\n\t\t\tthis._initContainer(); // defined by renderer implementations\n\n\t\t\tif (this._zoomAnimated) {\n\t\t\t\tL.DomUtil.addClass(this._container, 'leaflet-zoom-animated');\n\t\t\t}\n\t\t}\n\n\t\tthis.getPane().appendChild(this._container);\n\t\tthis._update();\n\t},\n\n\tonRemove: function () {\n\t\tL.DomUtil.remove(this._container);\n\t},\n\n\tgetEvents: function () {\n\t\tvar events = {\n\t\t\tviewreset: this._reset,\n\t\t\tzoomstart: this._onZoomStart,\n\t\t\tzoom: this._onZoom,\n\t\t\tmoveend: this._update\n\t\t};\n\t\tif (this._zoomAnimated) {\n\t\t\tevents.zoomanim = this._onAnimZoom;\n\t\t}\n\t\treturn events;\n\t},\n\n\t_onAnimZoom: function (ev) {\n\t\tthis._updateTransform(ev.center, ev.zoom);\n\t},\n\n\t_onZoom: function () {\n\t\tthis._updateTransform(this._map.getCenter(), this._map.getZoom());\n\t},\n\n\t_onZoomStart: function () {\n\t\t// Drag-then-pinch interactions might mess up the center and zoom.\n\t\t// In this case, the easiest way to prevent this is re-do the renderer\n\t\t//   bounds and padding when the zooming starts.\n\t\tthis._update();\n\t},\n\n\t_updateTransform: function (center, zoom) {\n\t\tvar scale = this._map.getZoomScale(zoom, this._zoom),\n\t\t    position = L.DomUtil.getPosition(this._container),\n\t\t    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n\t\t    currentCenterPoint = this._map.project(this._center, zoom),\n\t\t    destCenterPoint = this._map.project(center, zoom),\n\t\t    centerOffset = destCenterPoint.subtract(currentCenterPoint),\n\n\t\t    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);\n\n\t\tL.DomUtil.setTransform(this._container, topLeftOffset, scale);\n\t},\n\n\t_reset: function () {\n\t\tthis._update();\n\t\tthis._updateTransform(this._center, this._zoom);\n\t},\n\n\t_update: function () {\n\t\t// update pixel bounds of renderer container (for positioning/sizing/clipping later)\n\t\tvar p = this.options.padding,\n\t\t    size = this._map.getSize(),\n\t\t    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n\t\tthis._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n\n\t\tthis._center = this._map.getCenter();\n\t\tthis._zoom = this._map.getZoom();\n\t}\n});\n\n\nL.Map.include({\n\t// used by each vector layer to decide which renderer to use\n\tgetRenderer: function (layer) {\n\t\tvar renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n\n\t\tif (!renderer) {\n\t\t\trenderer = this._renderer = (this.options.preferCanvas && L.canvas()) || L.svg();\n\t\t}\n\n\t\tif (!this.hasLayer(renderer)) {\n\t\t\tthis.addLayer(renderer);\n\t\t}\n\t\treturn renderer;\n\t},\n\n\t_getPaneRenderer: function (name) {\n\t\tif (name === 'overlayPane' || name === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar renderer = this._paneRenderers[name];\n\t\tif (renderer === undefined) {\n\t\t\trenderer = (L.SVG && L.svg({pane: name})) || (L.Canvas && L.canvas({pane: name}));\n\t\t\tthis._paneRenderers[name] = renderer;\n\t\t}\n\t\treturn renderer;\n\t}\n});\n\n\n\n/*\n * L.Path is the base class for all Leaflet vector layers like polygons and circles.\n */\n\nL.Path = L.Layer.extend({\n\n\toptions: {\n\t\tstroke: true,\n\t\tcolor: '#3388ff',\n\t\tweight: 3,\n\t\topacity: 1,\n\t\tlineCap: 'round',\n\t\tlineJoin: 'round',\n\t\t// dashArray: null\n\t\t// dashOffset: null\n\n\t\t// fill: false\n\t\t// fillColor: same as color by default\n\t\tfillOpacity: 0.2,\n\t\tfillRule: 'evenodd',\n\n\t\t// className: ''\n\t\tinteractive: true\n\t},\n\n\tbeforeAdd: function (map) {\n\t\t// Renderer is set here because we need to call renderer.getEvents\n\t\t// before this.getEvents.\n\t\tthis._renderer = map.getRenderer(this);\n\t},\n\n\tonAdd: function () {\n\t\tthis._renderer._initPath(this);\n\t\tthis._reset();\n\t\tthis._renderer._addPath(this);\n\t},\n\n\tonRemove: function () {\n\t\tthis._renderer._removePath(this);\n\t},\n\n\tgetEvents: function () {\n\t\treturn {\n\t\t\tzoomend: this._project,\n\t\t\tmoveend: this._update,\n\t\t\tviewreset: this._reset\n\t\t};\n\t},\n\n\tredraw: function () {\n\t\tif (this._map) {\n\t\t\tthis._renderer._updatePath(this);\n\t\t}\n\t\treturn this;\n\t},\n\n\tsetStyle: function (style) {\n\t\tL.setOptions(this, style);\n\t\tif (this._renderer) {\n\t\t\tthis._renderer._updateStyle(this);\n\t\t}\n\t\treturn this;\n\t},\n\n\tbringToFront: function () {\n\t\tif (this._renderer) {\n\t\t\tthis._renderer._bringToFront(this);\n\t\t}\n\t\treturn this;\n\t},\n\n\tbringToBack: function () {\n\t\tif (this._renderer) {\n\t\t\tthis._renderer._bringToBack(this);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetElement: function () {\n\t\treturn this._path;\n\t},\n\n\t_reset: function () {\n\t\t// defined in children classes\n\t\tthis._project();\n\t\tthis._update();\n\t},\n\n\t_clickTolerance: function () {\n\t\t// used when doing hit detection for Canvas layers\n\t\treturn (this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0);\n\t}\n});\n\n\n\n/*\r\n * L.LineUtil contains different utility functions for line segments\r\n * and polylines (clipping, simplification, distances, etc.)\r\n */\r\n\r\nL.LineUtil = {\r\n\r\n\t// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n\t// Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n\tsimplify: function (points, tolerance) {\r\n\t\tif (!tolerance || !points.length) {\r\n\t\t\treturn points.slice();\r\n\t\t}\r\n\r\n\t\tvar sqTolerance = tolerance * tolerance;\r\n\r\n\t\t// stage 1: vertex reduction\r\n\t\tpoints = this._reducePoints(points, sqTolerance);\r\n\r\n\t\t// stage 2: Douglas-Peucker simplification\r\n\t\tpoints = this._simplifyDP(points, sqTolerance);\r\n\r\n\t\treturn points;\r\n\t},\r\n\r\n\t// distance from a point to a segment between two points\r\n\tpointToSegmentDistance:  function (p, p1, p2) {\r\n\t\treturn Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\r\n\t},\r\n\r\n\tclosestPointOnSegment: function (p, p1, p2) {\r\n\t\treturn this._sqClosestPointOnSegment(p, p1, p2);\r\n\t},\r\n\r\n\t// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\n\t_simplifyDP: function (points, sqTolerance) {\r\n\r\n\t\tvar len = points.length,\r\n\t\t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n\t\t    markers = new ArrayConstructor(len);\r\n\r\n\t\tmarkers[0] = markers[len - 1] = 1;\r\n\r\n\t\tthis._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n\t\tvar i,\r\n\t\t    newPoints = [];\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (markers[i]) {\r\n\t\t\t\tnewPoints.push(points[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newPoints;\r\n\t},\r\n\r\n\t_simplifyDPStep: function (points, markers, sqTolerance, first, last) {\r\n\r\n\t\tvar maxSqDist = 0,\r\n\t\t    index, i, sqDist;\r\n\r\n\t\tfor (i = first + 1; i <= last - 1; i++) {\r\n\t\t\tsqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n\t\t\tif (sqDist > maxSqDist) {\r\n\t\t\t\tindex = i;\r\n\t\t\t\tmaxSqDist = sqDist;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (maxSqDist > sqTolerance) {\r\n\t\t\tmarkers[index] = 1;\r\n\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, first, index);\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, index, last);\r\n\t\t}\r\n\t},\r\n\r\n\t// reduce points that are too close to each other to a single point\r\n\t_reducePoints: function (points, sqTolerance) {\r\n\t\tvar reducedPoints = [points[0]];\r\n\r\n\t\tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n\t\t\tif (this._sqDist(points[i], points[prev]) > sqTolerance) {\r\n\t\t\t\treducedPoints.push(points[i]);\r\n\t\t\t\tprev = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (prev < len - 1) {\r\n\t\t\treducedPoints.push(points[len - 1]);\r\n\t\t}\r\n\t\treturn reducedPoints;\r\n\t},\r\n\r\n\t// Cohen-Sutherland line clipping algorithm.\r\n\t// Used to avoid rendering parts of a polyline that are not currently visible.\r\n\r\n\tclipSegment: function (a, b, bounds, useLastCode, round) {\r\n\t\tvar codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\r\n\t\t    codeB = this._getBitCode(b, bounds),\r\n\r\n\t\t    codeOut, p, newCode;\r\n\r\n\t\t// save 2nd code to avoid calculating it on the next segment\r\n\t\tthis._lastCode = codeB;\r\n\r\n\t\twhile (true) {\r\n\t\t\t// if a,b is inside the clip window (trivial accept)\r\n\t\t\tif (!(codeA | codeB)) { return [a, b]; }\r\n\r\n\t\t\t// if a,b is outside the clip window (trivial reject)\r\n\t\t\tif (codeA & codeB) { return false; }\r\n\r\n\t\t\t// other cases\r\n\t\t\tcodeOut = codeA || codeB;\r\n\t\t\tp = this._getEdgeIntersection(a, b, codeOut, bounds, round);\r\n\t\t\tnewCode = this._getBitCode(p, bounds);\r\n\r\n\t\t\tif (codeOut === codeA) {\r\n\t\t\t\ta = p;\r\n\t\t\t\tcodeA = newCode;\r\n\t\t\t} else {\r\n\t\t\t\tb = p;\r\n\t\t\t\tcodeB = newCode;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getEdgeIntersection: function (a, b, code, bounds, round) {\r\n\t\tvar dx = b.x - a.x,\r\n\t\t    dy = b.y - a.y,\r\n\t\t    min = bounds.min,\r\n\t\t    max = bounds.max,\r\n\t\t    x, y;\r\n\r\n\t\tif (code & 8) { // top\r\n\t\t\tx = a.x + dx * (max.y - a.y) / dy;\r\n\t\t\ty = max.y;\r\n\r\n\t\t} else if (code & 4) { // bottom\r\n\t\t\tx = a.x + dx * (min.y - a.y) / dy;\r\n\t\t\ty = min.y;\r\n\r\n\t\t} else if (code & 2) { // right\r\n\t\t\tx = max.x;\r\n\t\t\ty = a.y + dy * (max.x - a.x) / dx;\r\n\r\n\t\t} else if (code & 1) { // left\r\n\t\t\tx = min.x;\r\n\t\t\ty = a.y + dy * (min.x - a.x) / dx;\r\n\t\t}\r\n\r\n\t\treturn new L.Point(x, y, round);\r\n\t},\r\n\r\n\t_getBitCode: function (p, bounds) {\r\n\t\tvar code = 0;\r\n\r\n\t\tif (p.x < bounds.min.x) { // left\r\n\t\t\tcode |= 1;\r\n\t\t} else if (p.x > bounds.max.x) { // right\r\n\t\t\tcode |= 2;\r\n\t\t}\r\n\r\n\t\tif (p.y < bounds.min.y) { // bottom\r\n\t\t\tcode |= 4;\r\n\t\t} else if (p.y > bounds.max.y) { // top\r\n\t\t\tcode |= 8;\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\t},\r\n\r\n\t// square distance (to avoid unnecessary Math.sqrt calls)\r\n\t_sqDist: function (p1, p2) {\r\n\t\tvar dx = p2.x - p1.x,\r\n\t\t    dy = p2.y - p1.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\t},\r\n\r\n\t// return closest point on segment or distance to that point\r\n\t_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\r\n\t\tvar x = p1.x,\r\n\t\t    y = p1.y,\r\n\t\t    dx = p2.x - x,\r\n\t\t    dy = p2.y - y,\r\n\t\t    dot = dx * dx + dy * dy,\r\n\t\t    t;\r\n\r\n\t\tif (dot > 0) {\r\n\t\t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n\t\t\tif (t > 1) {\r\n\t\t\t\tx = p2.x;\r\n\t\t\t\ty = p2.y;\r\n\t\t\t} else if (t > 0) {\r\n\t\t\t\tx += dx * t;\r\n\t\t\t\ty += dy * t;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdx = p.x - x;\r\n\t\tdy = p.y - y;\r\n\r\n\t\treturn sqDist ? dx * dx + dy * dy : new L.Point(x, y);\r\n\t}\r\n};\r\n\n\n\n/*\n * L.Polyline implements polyline vector layer (a set of points connected with lines)\n */\n\nL.Polyline = L.Path.extend({\n\n\toptions: {\n\t\t// how much to simplify the polyline on each zoom level\n\t\t// more = better performance and smoother look, less = more accurate\n\t\tsmoothFactor: 1.0\n\t\t// noClip: false\n\t},\n\n\tinitialize: function (latlngs, options) {\n\t\tL.setOptions(this, options);\n\t\tthis._setLatLngs(latlngs);\n\t},\n\n\tgetLatLngs: function () {\n\t\treturn this._latlngs;\n\t},\n\n\tsetLatLngs: function (latlngs) {\n\t\tthis._setLatLngs(latlngs);\n\t\treturn this.redraw();\n\t},\n\n\tisEmpty: function () {\n\t\treturn !this._latlngs.length;\n\t},\n\n\tclosestLayerPoint: function (p) {\n\t\tvar minDistance = Infinity,\n\t\t    minPoint = null,\n\t\t    closest = L.LineUtil._sqClosestPointOnSegment,\n\t\t    p1, p2;\n\n\t\tfor (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n\t\t\tvar points = this._parts[j];\n\n\t\t\tfor (var i = 1, len = points.length; i < len; i++) {\n\t\t\t\tp1 = points[i - 1];\n\t\t\t\tp2 = points[i];\n\n\t\t\t\tvar sqDist = closest(p, p1, p2, true);\n\n\t\t\t\tif (sqDist < minDistance) {\n\t\t\t\t\tminDistance = sqDist;\n\t\t\t\t\tminPoint = closest(p, p1, p2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (minPoint) {\n\t\t\tminPoint.distance = Math.sqrt(minDistance);\n\t\t}\n\t\treturn minPoint;\n\t},\n\n\tgetCenter: function () {\n\t\tvar i, halfDist, segDist, dist, p1, p2, ratio,\n\t\t    points = this._rings[0],\n\t\t    len = points.length;\n\n\t\tif (!len) { return null; }\n\n\t\t// polyline centroid algorithm; only uses the first ring if there are multiple\n\n\t\tfor (i = 0, halfDist = 0; i < len - 1; i++) {\n\t\t\thalfDist += points[i].distanceTo(points[i + 1]) / 2;\n\t\t}\n\n\t\t// The line is so small in the current view that all points are on the same pixel.\n\t\tif (halfDist === 0) {\n\t\t\treturn this._map.layerPointToLatLng(points[0]);\n\t\t}\n\n\t\tfor (i = 0, dist = 0; i < len - 1; i++) {\n\t\t\tp1 = points[i];\n\t\t\tp2 = points[i + 1];\n\t\t\tsegDist = p1.distanceTo(p2);\n\t\t\tdist += segDist;\n\n\t\t\tif (dist > halfDist) {\n\t\t\t\tratio = (dist - halfDist) / segDist;\n\t\t\t\treturn this._map.layerPointToLatLng([\n\t\t\t\t\tp2.x - ratio * (p2.x - p1.x),\n\t\t\t\t\tp2.y - ratio * (p2.y - p1.y)\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetBounds: function () {\n\t\treturn this._bounds;\n\t},\n\n\taddLatLng: function (latlng, latlngs) {\n\t\tlatlngs = latlngs || this._defaultShape();\n\t\tlatlng = L.latLng(latlng);\n\t\tlatlngs.push(latlng);\n\t\tthis._bounds.extend(latlng);\n\t\treturn this.redraw();\n\t},\n\n\t_setLatLngs: function (latlngs) {\n\t\tthis._bounds = new L.LatLngBounds();\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\n\t},\n\n\t_defaultShape: function () {\n\t\treturn L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];\n\t},\n\n\t// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n\t_convertLatLngs: function (latlngs) {\n\t\tvar result = [],\n\t\t    flat = L.Polyline._flat(latlngs);\n\n\t\tfor (var i = 0, len = latlngs.length; i < len; i++) {\n\t\t\tif (flat) {\n\t\t\t\tresult[i] = L.latLng(latlngs[i]);\n\t\t\t\tthis._bounds.extend(result[i]);\n\t\t\t} else {\n\t\t\t\tresult[i] = this._convertLatLngs(latlngs[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t_project: function () {\n\t\tthis._rings = [];\n\t\tthis._projectLatlngs(this._latlngs, this._rings);\n\n\t\t// project bounds as well to use later for Canvas hit detection/etc.\n\t\tvar w = this._clickTolerance(),\n\t\t    p = new L.Point(w, -w);\n\n\t\tif (this._bounds.isValid()) {\n\t\t\tthis._pxBounds = new L.Bounds(\n\t\t\t\tthis._map.latLngToLayerPoint(this._bounds.getSouthWest())._subtract(p),\n\t\t\t\tthis._map.latLngToLayerPoint(this._bounds.getNorthEast())._add(p));\n\t\t}\n\t},\n\n\t// recursively turns latlngs into a set of rings with projected coordinates\n\t_projectLatlngs: function (latlngs, result) {\n\n\t\tvar flat = latlngs[0] instanceof L.LatLng,\n\t\t    len = latlngs.length,\n\t\t    i, ring;\n\n\t\tif (flat) {\n\t\t\tring = [];\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n\t\t\t}\n\t\t\tresult.push(ring);\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tthis._projectLatlngs(latlngs[i], result);\n\t\t\t}\n\t\t}\n\t},\n\n\t// clip polyline by renderer bounds so that we have less to render for performance\n\t_clipPoints: function () {\n\t\tvar bounds = this._renderer._bounds;\n\n\t\tthis._parts = [];\n\t\tif (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.options.noClip) {\n\t\t\tthis._parts = this._rings;\n\t\t\treturn;\n\t\t}\n\n\t\tvar parts = this._parts,\n\t\t    i, j, k, len, len2, segment, points;\n\n\t\tfor (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n\t\t\tpoints = this._rings[i];\n\n\t\t\tfor (j = 0, len2 = points.length; j < len2 - 1; j++) {\n\t\t\t\tsegment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);\n\n\t\t\t\tif (!segment) { continue; }\n\n\t\t\t\tparts[k] = parts[k] || [];\n\t\t\t\tparts[k].push(segment[0]);\n\n\t\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\n\t\t\t\tif ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {\n\t\t\t\t\tparts[k].push(segment[1]);\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// simplify each clipped part of the polyline for performance\n\t_simplifyPoints: function () {\n\t\tvar parts = this._parts,\n\t\t    tolerance = this.options.smoothFactor;\n\n\t\tfor (var i = 0, len = parts.length; i < len; i++) {\n\t\t\tparts[i] = L.LineUtil.simplify(parts[i], tolerance);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tif (!this._map) { return; }\n\n\t\tthis._clipPoints();\n\t\tthis._simplifyPoints();\n\t\tthis._updatePath();\n\t},\n\n\t_updatePath: function () {\n\t\tthis._renderer._updatePoly(this);\n\t}\n});\n\nL.polyline = function (latlngs, options) {\n\treturn new L.Polyline(latlngs, options);\n};\n\nL.Polyline._flat = function (latlngs) {\n\t// true if it's a flat array of latlngs; false if nested\n\treturn !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\n};\n\n\n\n/*\r\n * L.PolyUtil contains utility functions for polygons (clipping, etc.).\r\n */\r\n\r\nL.PolyUtil = {};\r\n\r\n/*\r\n * Sutherland-Hodgeman polygon clipping algorithm.\r\n * Used to avoid rendering parts of a polygon that are not currently visible.\r\n */\r\nL.PolyUtil.clipPolygon = function (points, bounds, round) {\r\n\tvar clippedPoints,\r\n\t    edges = [1, 4, 2, 8],\r\n\t    i, j, k,\r\n\t    a, b,\r\n\t    len, edge, p,\r\n\t    lu = L.LineUtil;\r\n\r\n\tfor (i = 0, len = points.length; i < len; i++) {\r\n\t\tpoints[i]._code = lu._getBitCode(points[i], bounds);\r\n\t}\r\n\r\n\t// for each edge (left, bottom, right, top)\r\n\tfor (k = 0; k < 4; k++) {\r\n\t\tedge = edges[k];\r\n\t\tclippedPoints = [];\r\n\r\n\t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n\t\t\ta = points[i];\r\n\t\t\tb = points[j];\r\n\r\n\t\t\t// if a is inside the clip window\r\n\t\t\tif (!(a._code & edge)) {\r\n\t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n\t\t\t\tif (b._code & edge) {\r\n\t\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds, round);\r\n\t\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\t\tclippedPoints.push(p);\r\n\t\t\t\t}\r\n\t\t\t\tclippedPoints.push(a);\r\n\r\n\t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n\t\t\t} else if (!(b._code & edge)) {\r\n\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds, round);\r\n\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\tclippedPoints.push(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpoints = clippedPoints;\r\n\t}\r\n\r\n\treturn points;\r\n};\r\n\n\n\n/*\n * L.Polygon implements polygon vector layer (closed polyline with a fill inside).\n */\n\nL.Polygon = L.Polyline.extend({\n\n\toptions: {\n\t\tfill: true\n\t},\n\n\tisEmpty: function () {\n\t\treturn !this._latlngs.length || !this._latlngs[0].length;\n\t},\n\n\tgetCenter: function () {\n\t\tvar i, j, p1, p2, f, area, x, y, center,\n\t\t    points = this._rings[0],\n\t\t    len = points.length;\n\n\t\tif (!len) { return null; }\n\n\t\t// polygon centroid algorithm; only uses the first ring if there are multiple\n\n\t\tarea = x = y = 0;\n\n\t\tfor (i = 0, j = len - 1; i < len; j = i++) {\n\t\t\tp1 = points[i];\n\t\t\tp2 = points[j];\n\n\t\t\tf = p1.y * p2.x - p2.y * p1.x;\n\t\t\tx += (p1.x + p2.x) * f;\n\t\t\ty += (p1.y + p2.y) * f;\n\t\t\tarea += f * 3;\n\t\t}\n\n\t\tif (area === 0) {\n\t\t\t// Polygon is so small that all points are on same pixel.\n\t\t\tcenter = points[0];\n\t\t} else {\n\t\t\tcenter = [x / area, y / area];\n\t\t}\n\t\treturn this._map.layerPointToLatLng(center);\n\t},\n\n\t_convertLatLngs: function (latlngs) {\n\t\tvar result = L.Polyline.prototype._convertLatLngs.call(this, latlngs),\n\t\t    len = result.length;\n\n\t\t// remove last point if it equals first one\n\t\tif (len >= 2 && result[0] instanceof L.LatLng && result[0].equals(result[len - 1])) {\n\t\t\tresult.pop();\n\t\t}\n\t\treturn result;\n\t},\n\n\t_setLatLngs: function (latlngs) {\n\t\tL.Polyline.prototype._setLatLngs.call(this, latlngs);\n\t\tif (L.Polyline._flat(this._latlngs)) {\n\t\t\tthis._latlngs = [this._latlngs];\n\t\t}\n\t},\n\n\t_defaultShape: function () {\n\t\treturn L.Polyline._flat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n\t},\n\n\t_clipPoints: function () {\n\t\t// polygons need a different clipping algorithm so we redefine that\n\n\t\tvar bounds = this._renderer._bounds,\n\t\t    w = this.options.weight,\n\t\t    p = new L.Point(w, w);\n\n\t\t// increase clip padding by stroke width to avoid stroke on clip edges\n\t\tbounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));\n\n\t\tthis._parts = [];\n\t\tif (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.options.noClip) {\n\t\t\tthis._parts = this._rings;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n\t\t\tclipped = L.PolyUtil.clipPolygon(this._rings[i], bounds, true);\n\t\t\tif (clipped.length) {\n\t\t\t\tthis._parts.push(clipped);\n\t\t\t}\n\t\t}\n\t},\n\n\t_updatePath: function () {\n\t\tthis._renderer._updatePoly(this, true);\n\t}\n});\n\nL.polygon = function (latlngs, options) {\n\treturn new L.Polygon(latlngs, options);\n};\n\n\n\n/*\n * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n */\n\nL.Rectangle = L.Polygon.extend({\n\tinitialize: function (latLngBounds, options) {\n\t\tL.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n\t},\n\n\tsetBounds: function (latLngBounds) {\n\t\treturn this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n\t},\n\n\t_boundsToLatLngs: function (latLngBounds) {\n\t\tlatLngBounds = L.latLngBounds(latLngBounds);\n\t\treturn [\n\t\t\tlatLngBounds.getSouthWest(),\n\t\t\tlatLngBounds.getNorthWest(),\n\t\t\tlatLngBounds.getNorthEast(),\n\t\t\tlatLngBounds.getSouthEast()\n\t\t];\n\t}\n});\n\nL.rectangle = function (latLngBounds, options) {\n\treturn new L.Rectangle(latLngBounds, options);\n};\n\n\n\n/*\n * L.CircleMarker is a circle overlay with a permanent pixel radius.\n */\n\nL.CircleMarker = L.Path.extend({\n\n\toptions: {\n\t\tfill: true,\n\t\tradius: 10\n\t},\n\n\tinitialize: function (latlng, options) {\n\t\tL.setOptions(this, options);\n\t\tthis._latlng = L.latLng(latlng);\n\t\tthis._radius = this.options.radius;\n\t},\n\n\tsetLatLng: function (latlng) {\n\t\tthis._latlng = L.latLng(latlng);\n\t\tthis.redraw();\n\t\treturn this.fire('move', {latlng: this._latlng});\n\t},\n\n\tgetLatLng: function () {\n\t\treturn this._latlng;\n\t},\n\n\tsetRadius: function (radius) {\n\t\tthis.options.radius = this._radius = radius;\n\t\treturn this.redraw();\n\t},\n\n\tgetRadius: function () {\n\t\treturn this._radius;\n\t},\n\n\tsetStyle : function (options) {\n\t\tvar radius = options && options.radius || this._radius;\n\t\tL.Path.prototype.setStyle.call(this, options);\n\t\tthis.setRadius(radius);\n\t\treturn this;\n\t},\n\n\t_project: function () {\n\t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\n\t\tthis._updateBounds();\n\t},\n\n\t_updateBounds: function () {\n\t\tvar r = this._radius,\n\t\t    r2 = this._radiusY || r,\n\t\t    w = this._clickTolerance(),\n\t\t    p = [r + w, r2 + w];\n\t\tthis._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));\n\t},\n\n\t_update: function () {\n\t\tif (this._map) {\n\t\t\tthis._updatePath();\n\t\t}\n\t},\n\n\t_updatePath: function () {\n\t\tthis._renderer._updateCircle(this);\n\t},\n\n\t_empty: function () {\n\t\treturn this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n\t}\n});\n\nL.circleMarker = function (latlng, options) {\n\treturn new L.CircleMarker(latlng, options);\n};\n\n\n\n/*\n * L.Circle is a circle overlay (with a certain radius in meters).\n * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion)\n */\n\nL.Circle = L.CircleMarker.extend({\n\n\tinitialize: function (latlng, options) {\n\t\tL.setOptions(this, options);\n\t\tthis._latlng = L.latLng(latlng);\n\t\tthis._mRadius = this.options.radius;\n\t},\n\n\tsetRadius: function (radius) {\n\t\tthis._mRadius = radius;\n\t\treturn this.redraw();\n\t},\n\n\tgetRadius: function () {\n\t\treturn this._mRadius;\n\t},\n\n\tgetBounds: function () {\n\t\tvar half = [this._radius, this._radiusY || this._radius];\n\n\t\treturn new L.LatLngBounds(\n\t\t\tthis._map.layerPointToLatLng(this._point.subtract(half)),\n\t\t\tthis._map.layerPointToLatLng(this._point.add(half)));\n\t},\n\n\tsetStyle: L.Path.prototype.setStyle,\n\n\t_project: function () {\n\n\t\tvar lng = this._latlng.lng,\n\t\t    lat = this._latlng.lat,\n\t\t    map = this._map,\n\t\t    crs = map.options.crs;\n\n\t\tif (crs.distance === L.CRS.Earth.distance) {\n\t\t\tvar d = Math.PI / 180,\n\t\t\t    latR = (this._mRadius / L.CRS.Earth.R) / d,\n\t\t\t    top = map.project([lat + latR, lng]),\n\t\t\t    bottom = map.project([lat - latR, lng]),\n\t\t\t    p = top.add(bottom).divideBy(2),\n\t\t\t    lat2 = map.unproject(p).lat,\n\t\t\t    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /\n\t\t\t            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n\n\t\t\tthis._point = p.subtract(map.getPixelOrigin());\n\t\t\tthis._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);\n\t\t\tthis._radiusY = Math.max(Math.round(p.y - top.y), 1);\n\n\t\t} else {\n\t\t\tvar latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n\n\t\t\tthis._point = map.latLngToLayerPoint(this._latlng);\n\t\t\tthis._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n\t\t}\n\n\t\tthis._updateBounds();\n\t}\n});\n\nL.circle = function (latlng, options, legacyOptions) {\n\tif (typeof options === 'number') {\n\t\t// Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n\t\toptions = L.extend({}, legacyOptions, {radius: options});\n\t}\n\treturn new L.Circle(latlng, options);\n};\n\n\n\n/*\n * L.SVG renders vector layers with SVG. All SVG-specific code goes here.\n */\n\nL.SVG = L.Renderer.extend({\n\n\t_initContainer: function () {\n\t\tthis._container = L.SVG.create('svg');\n\n\t\t// makes it possible to click through svg root; we'll reset it back in individual paths\n\t\tthis._container.setAttribute('pointer-events', 'none');\n\n\t\tthis._rootGroup = L.SVG.create('g');\n\t\tthis._container.appendChild(this._rootGroup);\n\t},\n\n\t_update: function () {\n\t\tif (this._map._animatingZoom && this._bounds) { return; }\n\n\t\tL.Renderer.prototype._update.call(this);\n\n\t\tvar b = this._bounds,\n\t\t    size = b.getSize(),\n\t\t    container = this._container;\n\n\t\t// set size of svg-container if changed\n\t\tif (!this._svgSize || !this._svgSize.equals(size)) {\n\t\t\tthis._svgSize = size;\n\t\t\tcontainer.setAttribute('width', size.x);\n\t\t\tcontainer.setAttribute('height', size.y);\n\t\t}\n\n\t\t// movement: update container viewBox so that we don't have to change coordinates of individual layers\n\t\tL.DomUtil.setPosition(container, b.min);\n\t\tcontainer.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n\t},\n\n\t// methods below are called by vector layers implementations\n\n\t_initPath: function (layer) {\n\t\tvar path = layer._path = L.SVG.create('path');\n\n\t\tif (layer.options.className) {\n\t\t\tL.DomUtil.addClass(path, layer.options.className);\n\t\t}\n\n\t\tif (layer.options.interactive) {\n\t\t\tL.DomUtil.addClass(path, 'leaflet-interactive');\n\t\t}\n\n\t\tthis._updateStyle(layer);\n\t},\n\n\t_addPath: function (layer) {\n\t\tthis._rootGroup.appendChild(layer._path);\n\t\tlayer.addInteractiveTarget(layer._path);\n\t},\n\n\t_removePath: function (layer) {\n\t\tL.DomUtil.remove(layer._path);\n\t\tlayer.removeInteractiveTarget(layer._path);\n\t},\n\n\t_updatePath: function (layer) {\n\t\tlayer._project();\n\t\tlayer._update();\n\t},\n\n\t_updateStyle: function (layer) {\n\t\tvar path = layer._path,\n\t\t    options = layer.options;\n\n\t\tif (!path) { return; }\n\n\t\tif (options.stroke) {\n\t\t\tpath.setAttribute('stroke', options.color);\n\t\t\tpath.setAttribute('stroke-opacity', options.opacity);\n\t\t\tpath.setAttribute('stroke-width', options.weight);\n\t\t\tpath.setAttribute('stroke-linecap', options.lineCap);\n\t\t\tpath.setAttribute('stroke-linejoin', options.lineJoin);\n\n\t\t\tif (options.dashArray) {\n\t\t\t\tpath.setAttribute('stroke-dasharray', options.dashArray);\n\t\t\t} else {\n\t\t\t\tpath.removeAttribute('stroke-dasharray');\n\t\t\t}\n\n\t\t\tif (options.dashOffset) {\n\t\t\t\tpath.setAttribute('stroke-dashoffset', options.dashOffset);\n\t\t\t} else {\n\t\t\t\tpath.removeAttribute('stroke-dashoffset');\n\t\t\t}\n\t\t} else {\n\t\t\tpath.setAttribute('stroke', 'none');\n\t\t}\n\n\t\tif (options.fill) {\n\t\t\tpath.setAttribute('fill', options.fillColor || options.color);\n\t\t\tpath.setAttribute('fill-opacity', options.fillOpacity);\n\t\t\tpath.setAttribute('fill-rule', options.fillRule || 'evenodd');\n\t\t} else {\n\t\t\tpath.setAttribute('fill', 'none');\n\t\t}\n\n\t\tpath.setAttribute('pointer-events', options.pointerEvents || (options.interactive ? 'visiblePainted' : 'none'));\n\t},\n\n\t_updatePoly: function (layer, closed) {\n\t\tthis._setPath(layer, L.SVG.pointsToPath(layer._parts, closed));\n\t},\n\n\t_updateCircle: function (layer) {\n\t\tvar p = layer._point,\n\t\t    r = layer._radius,\n\t\t    r2 = layer._radiusY || r,\n\t\t    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';\n\n\t\t// drawing a circle with two half-arcs\n\t\tvar d = layer._empty() ? 'M0 0' :\n\t\t\t\t'M' + (p.x - r) + ',' + p.y +\n\t\t\t\tarc + (r * 2) + ',0 ' +\n\t\t\t\tarc + (-r * 2) + ',0 ';\n\n\t\tthis._setPath(layer, d);\n\t},\n\n\t_setPath: function (layer, path) {\n\t\tlayer._path.setAttribute('d', path);\n\t},\n\n\t// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n\t_bringToFront: function (layer) {\n\t\tL.DomUtil.toFront(layer._path);\n\t},\n\n\t_bringToBack: function (layer) {\n\t\tL.DomUtil.toBack(layer._path);\n\t}\n});\n\n\nL.extend(L.SVG, {\n\tcreate: function (name) {\n\t\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n\t},\n\n\t// generates SVG path string for multiple rings, with each ring turning into \"M..L..L..\" instructions\n\tpointsToPath: function (rings, closed) {\n\t\tvar str = '',\n\t\t    i, j, len, len2, points, p;\n\n\t\tfor (i = 0, len = rings.length; i < len; i++) {\n\t\t\tpoints = rings[i];\n\n\t\t\tfor (j = 0, len2 = points.length; j < len2; j++) {\n\t\t\t\tp = points[j];\n\t\t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n\t\t\t}\n\n\t\t\t// closes the ring for polygons; \"x\" is VML syntax\n\t\t\tstr += closed ? (L.Browser.svg ? 'z' : 'x') : '';\n\t\t}\n\n\t\t// SVG complains about empty path strings\n\t\treturn str || 'M0 0';\n\t}\n});\n\nL.Browser.svg = !!(document.createElementNS && L.SVG.create('svg').createSVGRect);\n\nL.svg = function (options) {\n\treturn L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null;\n};\n\n\n\n/*\n * Vector rendering for IE7-8 through VML.\n * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n */\n\nL.Browser.vml = !L.Browser.svg && (function () {\n\ttry {\n\t\tvar div = document.createElement('div');\n\t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\n\n\t\tvar shape = div.firstChild;\n\t\tshape.style.behavior = 'url(#default#VML)';\n\n\t\treturn shape && (typeof shape.adj === 'object');\n\n\t} catch (e) {\n\t\treturn false;\n\t}\n}());\n\n// redefine some SVG methods to handle VML syntax which is similar but with some differences\nL.SVG.include(!L.Browser.vml ? {} : {\n\n\t_initContainer: function () {\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-vml-container');\n\t},\n\n\t_update: function () {\n\t\tif (this._map._animatingZoom) { return; }\n\t\tL.Renderer.prototype._update.call(this);\n\t},\n\n\t_initPath: function (layer) {\n\t\tvar container = layer._container = L.SVG.create('shape');\n\n\t\tL.DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n\n\t\tcontainer.coordsize = '1 1';\n\n\t\tlayer._path = L.SVG.create('path');\n\t\tcontainer.appendChild(layer._path);\n\n\t\tthis._updateStyle(layer);\n\t},\n\n\t_addPath: function (layer) {\n\t\tvar container = layer._container;\n\t\tthis._container.appendChild(container);\n\n\t\tif (layer.options.interactive) {\n\t\t\tlayer.addInteractiveTarget(container);\n\t\t}\n\t},\n\n\t_removePath: function (layer) {\n\t\tvar container = layer._container;\n\t\tL.DomUtil.remove(container);\n\t\tlayer.removeInteractiveTarget(container);\n\t},\n\n\t_updateStyle: function (layer) {\n\t\tvar stroke = layer._stroke,\n\t\t    fill = layer._fill,\n\t\t    options = layer.options,\n\t\t    container = layer._container;\n\n\t\tcontainer.stroked = !!options.stroke;\n\t\tcontainer.filled = !!options.fill;\n\n\t\tif (options.stroke) {\n\t\t\tif (!stroke) {\n\t\t\t\tstroke = layer._stroke = L.SVG.create('stroke');\n\t\t\t}\n\t\t\tcontainer.appendChild(stroke);\n\t\t\tstroke.weight = options.weight + 'px';\n\t\t\tstroke.color = options.color;\n\t\t\tstroke.opacity = options.opacity;\n\n\t\t\tif (options.dashArray) {\n\t\t\t\tstroke.dashStyle = L.Util.isArray(options.dashArray) ?\n\t\t\t\t    options.dashArray.join(' ') :\n\t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\n\t\t\t} else {\n\t\t\t\tstroke.dashStyle = '';\n\t\t\t}\n\t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\n\t\t\tstroke.joinstyle = options.lineJoin;\n\n\t\t} else if (stroke) {\n\t\t\tcontainer.removeChild(stroke);\n\t\t\tlayer._stroke = null;\n\t\t}\n\n\t\tif (options.fill) {\n\t\t\tif (!fill) {\n\t\t\t\tfill = layer._fill = L.SVG.create('fill');\n\t\t\t}\n\t\t\tcontainer.appendChild(fill);\n\t\t\tfill.color = options.fillColor || options.color;\n\t\t\tfill.opacity = options.fillOpacity;\n\n\t\t} else if (fill) {\n\t\t\tcontainer.removeChild(fill);\n\t\t\tlayer._fill = null;\n\t\t}\n\t},\n\n\t_updateCircle: function (layer) {\n\t\tvar p = layer._point.round(),\n\t\t    r = Math.round(layer._radius),\n\t\t    r2 = Math.round(layer._radiusY || r);\n\n\t\tthis._setPath(layer, layer._empty() ? 'M0 0' :\n\t\t\t\t'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));\n\t},\n\n\t_setPath: function (layer, path) {\n\t\tlayer._path.v = path;\n\t},\n\n\t_bringToFront: function (layer) {\n\t\tL.DomUtil.toFront(layer._container);\n\t},\n\n\t_bringToBack: function (layer) {\n\t\tL.DomUtil.toBack(layer._container);\n\t}\n});\n\nif (L.Browser.vml) {\n\tL.SVG.create = (function () {\n\t\ttry {\n\t\t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n\t\t\treturn function (name) {\n\t\t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\n\t\t\t};\n\t\t} catch (e) {\n\t\t\treturn function (name) {\n\t\t\t\treturn document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n\t\t\t};\n\t\t}\n\t})();\n}\n\n\n\n/*\n * L.Canvas handles Canvas vector layers rendering and mouse events handling. All Canvas-specific code goes here.\n */\n\nL.Canvas = L.Renderer.extend({\n\n\tonAdd: function () {\n\t\tL.Renderer.prototype.onAdd.call(this);\n\n\t\tthis._layers = this._layers || {};\n\n\t\t// Redraw vectors since canvas is cleared upon removal,\n\t\t// in case of removing the renderer itself from the map.\n\t\tthis._draw();\n\t},\n\n\t_initContainer: function () {\n\t\tvar container = this._container = document.createElement('canvas');\n\n\t\tL.DomEvent\n\t\t\t.on(container, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this)\n\t\t\t.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this)\n\t\t\t.on(container, 'mouseout', this._handleMouseOut, this);\n\n\t\tthis._ctx = container.getContext('2d');\n\t},\n\n\t_update: function () {\n\t\tif (this._map._animatingZoom && this._bounds) { return; }\n\n\t\tthis._drawnLayers = {};\n\n\t\tL.Renderer.prototype._update.call(this);\n\n\t\tvar b = this._bounds,\n\t\t    container = this._container,\n\t\t    size = b.getSize(),\n\t\t    m = L.Browser.retina ? 2 : 1;\n\n\t\tL.DomUtil.setPosition(container, b.min);\n\n\t\t// set canvas size (also clearing it); use double size on retina\n\t\tcontainer.width = m * size.x;\n\t\tcontainer.height = m * size.y;\n\t\tcontainer.style.width = size.x + 'px';\n\t\tcontainer.style.height = size.y + 'px';\n\n\t\tif (L.Browser.retina) {\n\t\t\tthis._ctx.scale(2, 2);\n\t\t}\n\n\t\t// translate so we use the same path coordinates after canvas element moves\n\t\tthis._ctx.translate(-b.min.x, -b.min.y);\n\t},\n\n\t_initPath: function (layer) {\n\t\tthis._layers[L.stamp(layer)] = layer;\n\t},\n\n\t_addPath: L.Util.falseFn,\n\n\t_removePath: function (layer) {\n\t\tlayer._removed = true;\n\t\tthis._requestRedraw(layer);\n\t},\n\n\t_updatePath: function (layer) {\n\t\tthis._redrawBounds = layer._pxBounds;\n\t\tthis._draw(true);\n\t\tlayer._project();\n\t\tlayer._update();\n\t\tthis._draw();\n\t\tthis._redrawBounds = null;\n\t},\n\n\t_updateStyle: function (layer) {\n\t\tthis._requestRedraw(layer);\n\t},\n\n\t_requestRedraw: function (layer) {\n\t\tif (!this._map) { return; }\n\n\t\tvar padding = (layer.options.weight || 0) + 1;\n\t\tthis._redrawBounds = this._redrawBounds || new L.Bounds();\n\t\tthis._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n\t\tthis._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n\n\t\tthis._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this);\n\t},\n\n\t_redraw: function () {\n\t\tthis._redrawRequest = null;\n\n\t\tthis._draw(true); // clear layers in redraw bounds\n\t\tthis._draw(); // draw layers\n\n\t\tthis._redrawBounds = null;\n\t},\n\n\t_draw: function (clear) {\n\t\tthis._clear = clear;\n\t\tvar layer, bounds = this._redrawBounds;\n\t\tthis._ctx.save();\n\t\tif (bounds) {\n\t\t\tthis._ctx.beginPath();\n\t\t\tthis._ctx.rect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\n\t\t\tthis._ctx.clip();\n\t\t}\n\n\t\tfor (var id in this._layers) {\n\t\t\tlayer = this._layers[id];\n\t\t\tif (!bounds || layer._pxBounds.intersects(bounds)) {\n\t\t\t\tlayer._updatePath();\n\t\t\t}\n\t\t\tif (clear && layer._removed) {\n\t\t\t\tdelete layer._removed;\n\t\t\t\tdelete this._layers[id];\n\t\t\t}\n\t\t}\n\t\tthis._ctx.restore();  // Restore state before clipping.\n\t},\n\n\t_updatePoly: function (layer, closed) {\n\n\t\tvar i, j, len2, p,\n\t\t    parts = layer._parts,\n\t\t    len = parts.length,\n\t\t    ctx = this._ctx;\n\n\t\tif (!len) { return; }\n\n\t\tthis._drawnLayers[layer._leaflet_id] = layer;\n\n\t\tctx.beginPath();\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tfor (j = 0, len2 = parts[i].length; j < len2; j++) {\n\t\t\t\tp = parts[i][j];\n\t\t\t\tctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n\t\t\t}\n\t\t\tif (closed) {\n\t\t\t\tctx.closePath();\n\t\t\t}\n\t\t}\n\n\t\tthis._fillStroke(ctx, layer);\n\n\t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n\t},\n\n\t_updateCircle: function (layer) {\n\n\t\tif (layer._empty()) { return; }\n\n\t\tvar p = layer._point,\n\t\t    ctx = this._ctx,\n\t\t    r = layer._radius,\n\t\t    s = (layer._radiusY || r) / r;\n\n\t\tif (s !== 1) {\n\t\t\tctx.save();\n\t\t\tctx.scale(1, s);\n\t\t}\n\n\t\tctx.beginPath();\n\t\tctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n\n\t\tif (s !== 1) {\n\t\t\tctx.restore();\n\t\t}\n\n\t\tthis._fillStroke(ctx, layer);\n\t},\n\n\t_fillStroke: function (ctx, layer) {\n\t\tvar clear = this._clear,\n\t\t    options = layer.options;\n\n\t\tctx.globalCompositeOperation = clear ? 'destination-out' : 'source-over';\n\n\t\tif (options.fill) {\n\t\t\tctx.globalAlpha = clear ? 1 : options.fillOpacity;\n\t\t\tctx.fillStyle = options.fillColor || options.color;\n\t\t\tctx.fill(options.fillRule || 'evenodd');\n\t\t}\n\n\t\tif (options.stroke && options.weight !== 0) {\n\t\t\tctx.globalAlpha = clear ? 1 : options.opacity;\n\n\t\t\t// if clearing shape, do it with the previously drawn line width\n\t\t\tlayer._prevWeight = ctx.lineWidth = clear ? layer._prevWeight + 1 : options.weight;\n\n\t\t\tctx.strokeStyle = options.color;\n\t\t\tctx.lineCap = options.lineCap;\n\t\t\tctx.lineJoin = options.lineJoin;\n\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t// Canvas obviously doesn't have mouse events for individual drawn objects,\n\t// so we emulate that by calculating what's under the mouse on mousemove/click manually\n\n\t_onClick: function (e) {\n\t\tvar point = this._map.mouseEventToLayerPoint(e), layers = [];\n\n\t\tfor (var id in this._layers) {\n\t\t\tif (this._layers[id]._containsPoint(point)) {\n\t\t\t\tL.DomEvent._fakeStop(e);\n\t\t\t\tlayers.push(this._layers[id]);\n\t\t\t}\n\t\t}\n\t\tif (layers.length)  {\n\t\t\tthis._fireEvent(layers, e);\n\t\t}\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._map || this._map.dragging._draggable._moving || this._map._animatingZoom) { return; }\n\n\t\tvar point = this._map.mouseEventToLayerPoint(e);\n\t\tthis._handleMouseOut(e, point);\n\t\tthis._handleMouseHover(e, point);\n\t},\n\n\n\t_handleMouseOut: function (e, point) {\n\t\tvar layer = this._hoveredLayer;\n\t\tif (layer && (e.type === 'mouseout' || !layer._containsPoint(point))) {\n\t\t\t// if we're leaving the layer, fire mouseout\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-interactive');\n\t\t\tthis._fireEvent([layer], e, 'mouseout');\n\t\t\tthis._hoveredLayer = null;\n\t\t}\n\t},\n\n\t_handleMouseHover: function (e, point) {\n\t\tvar id, layer;\n\t\tif (!this._hoveredLayer) {\n\t\t\tfor (id in this._drawnLayers) {\n\t\t\t\tlayer = this._drawnLayers[id];\n\t\t\t\tif (layer.options.interactive && layer._containsPoint(point)) {\n\t\t\t\t\tL.DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor\n\t\t\t\t\tthis._fireEvent([layer], e, 'mouseover');\n\t\t\t\t\tthis._hoveredLayer = layer;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this._hoveredLayer) {\n\t\t\tthis._fireEvent([this._hoveredLayer], e);\n\t\t}\n\t},\n\n\t_fireEvent: function (layers, e, type) {\n\t\tthis._map._fireDOMEvent(e, type || e.type, layers);\n\t},\n\n\t// TODO _bringToFront & _bringToBack, pretty tricky\n\n\t_bringToFront: L.Util.falseFn,\n\t_bringToBack: L.Util.falseFn\n});\n\nL.Browser.canvas = (function () {\n\treturn !!document.createElement('canvas').getContext;\n}());\n\nL.canvas = function (options) {\n\treturn L.Browser.canvas ? new L.Canvas(options) : null;\n};\n\nL.Polyline.prototype._containsPoint = function (p, closed) {\n\tvar i, j, k, len, len2, part,\n\t    w = this._clickTolerance();\n\n\tif (!this._pxBounds.contains(p)) { return false; }\n\n\t// hit detection for polylines\n\tfor (i = 0, len = this._parts.length; i < len; i++) {\n\t\tpart = this._parts[i];\n\n\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n\t\t\tif (!closed && (j === 0)) { continue; }\n\n\t\t\tif (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n};\n\nL.Polygon.prototype._containsPoint = function (p) {\n\tvar inside = false,\n\t    part, p1, p2, i, j, k, len, len2;\n\n\tif (!this._pxBounds.contains(p)) { return false; }\n\n\t// ray casting algorithm for detecting if point is in polygon\n\tfor (i = 0, len = this._parts.length; i < len; i++) {\n\t\tpart = this._parts[i];\n\n\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n\t\t\tp1 = part[j];\n\t\t\tp2 = part[k];\n\n\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\n\t\t\t\tinside = !inside;\n\t\t\t}\n\t\t}\n\t}\n\n\t// also check if it's on polygon stroke\n\treturn inside || L.Polyline.prototype._containsPoint.call(this, p, true);\n};\n\nL.CircleMarker.prototype._containsPoint = function (p) {\n\treturn p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n};\n\n\n\n/*\r\n * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\r\n */\r\n\r\nL.GeoJSON = L.FeatureGroup.extend({\r\n\r\n\tinitialize: function (geojson, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\r\n\t\tif (geojson) {\r\n\t\t\tthis.addData(geojson);\r\n\t\t}\r\n\t},\r\n\r\n\taddData: function (geojson) {\r\n\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\r\n\t\t    i, len, feature;\r\n\r\n\t\tif (features) {\r\n\t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n\t\t\t\t// only add this if geometry or geometries are set and not null\r\n\t\t\t\tfeature = features[i];\r\n\t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n\t\t\t\t\tthis.addData(feature);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.filter && !options.filter(geojson)) { return this; }\r\n\r\n\t\tvar layer = L.GeoJSON.geometryToLayer(geojson, options);\r\n\t\tif (!layer) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\r\n\r\n\t\tlayer.defaultOptions = layer.options;\r\n\t\tthis.resetStyle(layer);\r\n\r\n\t\tif (options.onEachFeature) {\r\n\t\t\toptions.onEachFeature(geojson, layer);\r\n\t\t}\r\n\r\n\t\treturn this.addLayer(layer);\r\n\t},\r\n\r\n\tresetStyle: function (layer) {\r\n\t\t// reset any custom styles\r\n\t\tlayer.options = layer.defaultOptions;\r\n\t\tthis._setLayerStyle(layer, this.options.style);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\treturn this.eachLayer(function (layer) {\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}, this);\r\n\t},\r\n\r\n\t_setLayerStyle: function (layer, style) {\r\n\t\tif (typeof style === 'function') {\r\n\t\t\tstyle = style(layer.feature);\r\n\t\t}\r\n\t\tif (layer.setStyle) {\r\n\t\t\tlayer.setStyle(style);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.extend(L.GeoJSON, {\r\n\tgeometryToLayer: function (geojson, options) {\r\n\r\n\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n\t\t    coords = geometry ? geometry.coordinates : null,\r\n\t\t    layers = [],\r\n\t\t    pointToLayer = options && options.pointToLayer,\r\n\t\t    coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,\r\n\t\t    latlng, latlngs, i, len;\r\n\r\n\t\tif (!coords && !geometry) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tswitch (geometry.type) {\r\n\t\tcase 'Point':\r\n\t\t\tlatlng = coordsToLatLng(coords);\r\n\t\t\treturn pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\r\n\r\n\t\tcase 'MultiPoint':\r\n\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\t\tlatlng = coordsToLatLng(coords[i]);\r\n\t\t\t\tlayers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tcase 'LineString':\r\n\t\tcase 'MultiLineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, coordsToLatLng);\r\n\t\t\treturn new L.Polyline(latlngs, options);\r\n\r\n\t\tcase 'Polygon':\r\n\t\tcase 'MultiPolygon':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);\r\n\t\t\treturn new L.Polygon(latlngs, options);\r\n\r\n\t\tcase 'GeometryCollection':\r\n\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n\t\t\t\tvar layer = this.geometryToLayer({\r\n\t\t\t\t\tgeometry: geometry.geometries[i],\r\n\t\t\t\t\ttype: 'Feature',\r\n\t\t\t\t\tproperties: geojson.properties\r\n\t\t\t\t}, options);\r\n\r\n\t\t\t\tif (layer) {\r\n\t\t\t\t\tlayers.push(layer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t}\r\n\t},\r\n\r\n\tcoordsToLatLng: function (coords) {\r\n\t\treturn new L.LatLng(coords[1], coords[0], coords[2]);\r\n\t},\r\n\r\n\tcoordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {\r\n\t\tvar latlngs = [];\r\n\r\n\t\tfor (var i = 0, len = coords.length, latlng; i < len; i++) {\r\n\t\t\tlatlng = levelsDeep ?\r\n\t\t\t        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :\r\n\t\t\t        (coordsToLatLng || this.coordsToLatLng)(coords[i]);\r\n\r\n\t\t\tlatlngs.push(latlng);\r\n\t\t}\r\n\r\n\t\treturn latlngs;\r\n\t},\r\n\r\n\tlatLngToCoords: function (latlng) {\r\n\t\treturn latlng.alt !== undefined ?\r\n\t\t\t\t[latlng.lng, latlng.lat, latlng.alt] :\r\n\t\t\t\t[latlng.lng, latlng.lat];\r\n\t},\r\n\r\n\tlatLngsToCoords: function (latlngs, levelsDeep, closed) {\r\n\t\tvar coords = [];\r\n\r\n\t\tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n\t\t\tcoords.push(levelsDeep ?\r\n\t\t\t\tL.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) :\r\n\t\t\t\tL.GeoJSON.latLngToCoords(latlngs[i]));\r\n\t\t}\r\n\r\n\t\tif (!levelsDeep && closed) {\r\n\t\t\tcoords.push(coords[0]);\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tgetFeature: function (layer, newGeometry) {\r\n\t\treturn layer.feature ?\r\n\t\t\t\tL.extend({}, layer.feature, {geometry: newGeometry}) :\r\n\t\t\t\tL.GeoJSON.asFeature(newGeometry);\r\n\t},\r\n\r\n\tasFeature: function (geoJSON) {\r\n\t\tif (geoJSON.type === 'Feature') {\r\n\t\t\treturn geoJSON;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: 'Feature',\r\n\t\t\tproperties: {},\r\n\t\t\tgeometry: geoJSON\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar PointToGeoJSON = {\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Point',\r\n\t\t\tcoordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\r\n\t\t});\r\n\t}\r\n};\r\n\r\nL.Marker.include(PointToGeoJSON);\r\nL.Circle.include(PointToGeoJSON);\r\nL.CircleMarker.include(PointToGeoJSON);\r\n\r\nL.Polyline.prototype.toGeoJSON = function () {\r\n\tvar multi = !L.Polyline._flat(this._latlngs);\r\n\r\n\tvar coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);\r\n\r\n\treturn L.GeoJSON.getFeature(this, {\r\n\t\ttype: (multi ? 'Multi' : '') + 'LineString',\r\n\t\tcoordinates: coords\r\n\t});\r\n};\r\n\r\nL.Polygon.prototype.toGeoJSON = function () {\r\n\tvar holes = !L.Polyline._flat(this._latlngs),\r\n\t    multi = holes && !L.Polyline._flat(this._latlngs[0]);\r\n\r\n\tvar coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);\r\n\r\n\tif (!holes) {\r\n\t\tcoords = [coords];\r\n\t}\r\n\r\n\treturn L.GeoJSON.getFeature(this, {\r\n\t\ttype: (multi ? 'Multi' : '') + 'Polygon',\r\n\t\tcoordinates: coords\r\n\t});\r\n};\r\n\r\n\r\nL.LayerGroup.include({\r\n\ttoMultiPoint: function () {\r\n\t\tvar coords = [];\r\n\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tcoords.push(layer.toGeoJSON().geometry.coordinates);\r\n\t\t});\r\n\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'MultiPoint',\r\n\t\t\tcoordinates: coords\r\n\t\t});\r\n\t},\r\n\r\n\ttoGeoJSON: function () {\r\n\r\n\t\tvar type = this.feature && this.feature.geometry && this.feature.geometry.type;\r\n\r\n\t\tif (type === 'MultiPoint') {\r\n\t\t\treturn this.toMultiPoint();\r\n\t\t}\r\n\r\n\t\tvar isGeometryCollection = type === 'GeometryCollection',\r\n\t\t    jsons = [];\r\n\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tif (layer.toGeoJSON) {\r\n\t\t\t\tvar json = layer.toGeoJSON();\r\n\t\t\t\tjsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif (isGeometryCollection) {\r\n\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\tgeometries: jsons,\r\n\t\t\t\ttype: 'GeometryCollection'\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: 'FeatureCollection',\r\n\t\t\tfeatures: jsons\r\n\t\t};\r\n\t}\r\n});\r\n\r\nL.geoJson = function (geojson, options) {\r\n\treturn new L.GeoJSON(geojson, options);\r\n};\r\n\n\n\n/*\r\n * L.DomEvent contains functions for working with DOM events.\r\n * Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\r\n */\r\n\r\nvar eventsKey = '_leaflet_events';\r\n\r\nL.DomEvent = {\r\n\r\n\ton: function (obj, types, fn, context) {\r\n\r\n\t\tif (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\tthis._on(obj, type, types[type], fn);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\tthis._on(obj, types[i], fn, context);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\toff: function (obj, types, fn, context) {\r\n\r\n\t\tif (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\tthis._off(obj, type, types[type], fn);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\tthis._off(obj, types[i], fn, context);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_on: function (obj, type, fn, context) {\r\n\t\tvar id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : '');\r\n\r\n\t\tif (obj[eventsKey] && obj[eventsKey][id]) { return this; }\r\n\r\n\t\tvar handler = function (e) {\r\n\t\t\treturn fn.call(context || obj, e || window.event);\r\n\t\t};\r\n\r\n\t\tvar originalHandler = handler;\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\tthis.addPointerListener(obj, type, handler, id);\r\n\r\n\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {\r\n\t\t\tthis.addDoubleTapListener(obj, handler, id);\r\n\r\n\t\t} else if ('addEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.addEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\te = e || window.event;\r\n\t\t\t\t\tif (L.DomEvent._isExternalTarget(obj, e)) {\r\n\t\t\t\t\t\toriginalHandler(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tobj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tif (type === 'click' && L.Browser.android) {\r\n\t\t\t\t\thandler = function (e) {\r\n\t\t\t\t\t\treturn L.DomEvent._filterClick(e, originalHandler);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t}\r\n\r\n\t\t} else if ('attachEvent' in obj) {\r\n\t\t\tobj.attachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[eventsKey] = obj[eventsKey] || {};\r\n\t\tobj[eventsKey][id] = handler;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_off: function (obj, type, fn, context) {\r\n\r\n\t\tvar id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : ''),\r\n\t\t    handler = obj[eventsKey] && obj[eventsKey][id];\r\n\r\n\t\tif (!handler) { return this; }\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\tthis.removePointerListener(obj, type, id);\r\n\r\n\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {\r\n\t\t\tthis.removeDoubleTapListener(obj, id);\r\n\r\n\t\t} else if ('removeEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.removeEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tobj.removeEventListener(\r\n\t\t\t\t\ttype === 'mouseenter' ? 'mouseover' :\r\n\t\t\t\t\ttype === 'mouseleave' ? 'mouseout' : type, handler, false);\r\n\t\t\t}\r\n\r\n\t\t} else if ('detachEvent' in obj) {\r\n\t\t\tobj.detachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[eventsKey][id] = null;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopPropagation: function (e) {\r\n\r\n\t\tif (e.stopPropagation) {\r\n\t\t\te.stopPropagation();\r\n\t\t} else if (e.originalEvent) {  // In case of Leaflet event.\r\n\t\t\te.originalEvent._stopped = true;\r\n\t\t} else {\r\n\t\t\te.cancelBubble = true;\r\n\t\t}\r\n\t\tL.DomEvent._skipped(e);\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdisableScrollPropagation: function (el) {\r\n\t\treturn L.DomEvent.on(el, 'mousewheel MozMousePixelScroll', L.DomEvent.stopPropagation);\r\n\t},\r\n\r\n\tdisableClickPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tL.DomEvent.on(el, L.Draggable.START.join(' '), stop);\r\n\r\n\t\treturn L.DomEvent.on(el, {\r\n\t\t\tclick: L.DomEvent._fakeStop,\r\n\t\t\tdblclick: stop\r\n\t\t});\r\n\t},\r\n\r\n\tpreventDefault: function (e) {\r\n\r\n\t\tif (e.preventDefault) {\r\n\t\t\te.preventDefault();\r\n\t\t} else {\r\n\t\t\te.returnValue = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstop: function (e) {\r\n\t\treturn L.DomEvent\r\n\t\t\t.preventDefault(e)\r\n\t\t\t.stopPropagation(e);\r\n\t},\r\n\r\n\tgetMousePosition: function (e, container) {\r\n\t\tif (!container) {\r\n\t\t\treturn new L.Point(e.clientX, e.clientY);\r\n\t\t}\r\n\r\n\t\tvar rect = container.getBoundingClientRect();\r\n\r\n\t\treturn new L.Point(\r\n\t\t\te.clientX - rect.left - container.clientLeft,\r\n\t\t\te.clientY - rect.top - container.clientTop);\r\n\t},\r\n\r\n\tgetWheelDelta: function (e) {\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif (e.wheelDelta) {\r\n\t\t\tdelta = e.wheelDelta / 120;\r\n\t\t}\r\n\t\tif (e.detail) {\r\n\t\t\tdelta = -e.detail / 3;\r\n\t\t}\r\n\t\treturn delta;\r\n\t},\r\n\r\n\t_skipEvents: {},\r\n\r\n\t_fakeStop: function (e) {\r\n\t\t// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\r\n\t\tL.DomEvent._skipEvents[e.type] = true;\r\n\t},\r\n\r\n\t_skipped: function (e) {\r\n\t\tvar skipped = this._skipEvents[e.type];\r\n\t\t// reset when checking, as it's only used in map container and propagates outside of the map\r\n\t\tthis._skipEvents[e.type] = false;\r\n\t\treturn skipped;\r\n\t},\r\n\r\n\t// check if element really left/entered the event target (for mouseenter/mouseleave)\r\n\t_isExternalTarget: function (el, e) {\r\n\r\n\t\tvar related = e.relatedTarget;\r\n\r\n\t\tif (!related) { return true; }\r\n\r\n\t\ttry {\r\n\t\t\twhile (related && (related !== el)) {\r\n\t\t\t\trelated = related.parentNode;\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn (related !== el);\r\n\t},\r\n\r\n\t// this is a horrible workaround for a bug in Android where a single touch triggers two click events\r\n\t_filterClick: function (e, handler) {\r\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t    elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t// on the same event should be triggered far faster;\r\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\r\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tL.DomEvent._lastClick = timeStamp;\r\n\r\n\t\thandler(e);\r\n\t}\r\n};\r\n\r\nL.DomEvent.addListener = L.DomEvent.on;\r\nL.DomEvent.removeListener = L.DomEvent.off;\r\n\n\n\n/*\r\n * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\r\n */\r\n\r\nL.Draggable = L.Evented.extend({\r\n\r\n\tstatics: {\r\n\t\tSTART: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\r\n\t\tEND: {\r\n\t\t\tmousedown: 'mouseup',\r\n\t\t\ttouchstart: 'touchend',\r\n\t\t\tpointerdown: 'touchend',\r\n\t\t\tMSPointerDown: 'touchend'\r\n\t\t},\r\n\t\tMOVE: {\r\n\t\t\tmousedown: 'mousemove',\r\n\t\t\ttouchstart: 'touchmove',\r\n\t\t\tpointerdown: 'touchmove',\r\n\t\t\tMSPointerDown: 'touchmove'\r\n\t\t}\r\n\t},\r\n\r\n\tinitialize: function (element, dragStartTarget, preventOutline) {\r\n\t\tthis._element = element;\r\n\t\tthis._dragStartTarget = dragStartTarget || element;\r\n\t\tthis._preventOutline = preventOutline;\r\n\t},\r\n\r\n\tenable: function () {\r\n\t\tif (this._enabled) { return; }\r\n\r\n\t\tL.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);\r\n\r\n\t\tthis._enabled = true;\r\n\t},\r\n\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) { return; }\r\n\r\n\t\tL.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);\r\n\r\n\t\tthis._enabled = false;\r\n\t\tthis._moved = false;\r\n\t},\r\n\r\n\t_onDown: function (e) {\r\n\t\tthis._moved = false;\r\n\r\n\t\tif (L.DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) { return; }\r\n\r\n\t\tif (L.Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches) || !this._enabled) { return; }\r\n\t\tL.Draggable._dragging = true;  // Prevent dragging multiple objects at once.\r\n\r\n\t\tif (this._preventOutline) {\r\n\t\t\tL.DomUtil.preventOutline(this._element);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.disableImageDrag();\r\n\t\tL.DomUtil.disableTextSelection();\r\n\r\n\t\tif (this._moving) { return; }\r\n\r\n\t\tthis.fire('down');\r\n\r\n\t\tvar first = e.touches ? e.touches[0] : e;\r\n\r\n\t\tthis._startPoint = new L.Point(first.clientX, first.clientY);\r\n\t\tthis._startPos = this._newPos = L.DomUtil.getPosition(this._element);\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)\r\n\t\t    .on(document, L.Draggable.END[e.type], this._onUp, this);\r\n\t},\r\n\r\n\t_onMove: function (e) {\r\n\t\tif (e.touches && e.touches.length > 1) {\r\n\t\t\tthis._moved = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n\t\t    newPoint = new L.Point(first.clientX, first.clientY),\r\n\t\t    offset = newPoint.subtract(this._startPoint);\r\n\r\n\t\tif (!offset.x && !offset.y) { return; }\r\n\t\tif (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }\r\n\r\n\t\tL.DomEvent.preventDefault(e);\r\n\r\n\t\tif (!this._moved) {\r\n\t\t\tthis.fire('dragstart');\r\n\r\n\t\t\tthis._moved = true;\r\n\t\t\tthis._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\r\n\r\n\t\t\tL.DomUtil.addClass(document.body, 'leaflet-dragging');\r\n\r\n\t\t\tthis._lastTarget = e.target || e.srcElement;\r\n\t\t\tL.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t}\r\n\r\n\t\tthis._newPos = this._startPos.add(offset);\r\n\t\tthis._moving = true;\r\n\r\n\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\t\tthis._lastEvent = e;\r\n\t\tthis._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true);\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tvar e = {originalEvent: this._lastEvent};\r\n\t\tthis.fire('predrag', e);\r\n\t\tL.DomUtil.setPosition(this._element, this._newPos);\r\n\t\tthis.fire('drag', e);\r\n\t},\r\n\r\n\t_onUp: function () {\r\n\t\tL.DomUtil.removeClass(document.body, 'leaflet-dragging');\r\n\r\n\t\tif (this._lastTarget) {\r\n\t\t\tL.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t\tthis._lastTarget = null;\r\n\t\t}\r\n\r\n\t\tfor (var i in L.Draggable.MOVE) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(document, L.Draggable.MOVE[i], this._onMove, this)\r\n\t\t\t    .off(document, L.Draggable.END[i], this._onUp, this);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.enableImageDrag();\r\n\t\tL.DomUtil.enableTextSelection();\r\n\r\n\t\tif (this._moved && this._moving) {\r\n\t\t\t// ensure drag is not fired after dragend\r\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\r\n\t\t\tthis.fire('dragend', {\r\n\t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._moving = false;\r\n\t\tL.Draggable._dragging = false;\r\n\t}\r\n});\r\n\n\n\n/*\n\tL.Handler is a base class for handler classes that are used internally to inject\n\tinteraction features like dragging to classes like Map and Marker.\n*/\n\nL.Handler = L.Class.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t},\n\n\tenable: function () {\n\t\tif (this._enabled) { return; }\n\n\t\tthis._enabled = true;\n\t\tthis.addHooks();\n\t},\n\n\tdisable: function () {\n\t\tif (!this._enabled) { return; }\n\n\t\tthis._enabled = false;\n\t\tthis.removeHooks();\n\t},\n\n\tenabled: function () {\n\t\treturn !!this._enabled;\n\t}\n});\n\n\n\n/*\n * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdragging: true,\n\n\tinertia: !L.Browser.android23,\n\tinertiaDeceleration: 3400, // px/s^2\n\tinertiaMaxSpeed: Infinity, // px/s\n\teaseLinearity: 0.2,\n\n\t// TODO refactor, move to CRS\n\tworldCopyJump: false\n});\n\nL.Map.Drag = L.Handler.extend({\n\taddHooks: function () {\n\t\tif (!this._draggable) {\n\t\t\tvar map = this._map;\n\n\t\t\tthis._draggable = new L.Draggable(map._mapPane, map._container);\n\n\t\t\tthis._draggable.on({\n\t\t\t\tdown: this._onDown,\n\t\t\t\tdragstart: this._onDragStart,\n\t\t\t\tdrag: this._onDrag,\n\t\t\t\tdragend: this._onDragEnd\n\t\t\t}, this);\n\n\t\t\tthis._draggable.on('predrag', this._onPreDragLimit, this);\n\t\t\tif (map.options.worldCopyJump) {\n\t\t\t\tthis._draggable.on('predrag', this._onPreDragWrap, this);\n\t\t\t\tmap.on('zoomend', this._onZoomEnd, this);\n\n\t\t\t\tmap.whenReady(this._onZoomEnd, this);\n\t\t\t}\n\t\t}\n\t\tL.DomUtil.addClass(this._map._container, 'leaflet-grab');\n\t\tthis._draggable.enable();\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomUtil.removeClass(this._map._container, 'leaflet-grab');\n\t\tthis._draggable.disable();\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDown: function () {\n\t\tthis._map.stop();\n\t},\n\n\t_onDragStart: function () {\n\t\tvar map = this._map;\n\n\t\tif (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n\t\t\tvar bounds = L.latLngBounds(this._map.options.maxBounds);\n\n\t\t\tthis._offsetLimit = L.bounds(\n\t\t\t\tthis._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),\n\t\t\t\tthis._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)\n\t\t\t\t\t.add(this._map.getSize()));\n\n\t\t\tthis._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n\t\t} else {\n\t\t\tthis._offsetLimit = null;\n\t\t}\n\n\t\tmap\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\n\t\tif (map.options.inertia) {\n\t\t\tthis._positions = [];\n\t\t\tthis._times = [];\n\t\t}\n\t},\n\n\t_onDrag: function (e) {\n\t\tif (this._map.options.inertia) {\n\t\t\tvar time = this._lastTime = +new Date(),\n\t\t\t    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n\n\t\t\tthis._positions.push(pos);\n\t\t\tthis._times.push(time);\n\n\t\t\tif (time - this._times[0] > 50) {\n\t\t\t\tthis._positions.shift();\n\t\t\t\tthis._times.shift();\n\t\t\t}\n\t\t}\n\n\t\tthis._map\n\t\t    .fire('move', e)\n\t\t    .fire('drag', e);\n\t},\n\n\t_onZoomEnd: function () {\n\t\tvar pxCenter = this._map.getSize().divideBy(2),\n\t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n\t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n\t\tthis._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n\t},\n\n\t_viscousLimit: function (value, threshold) {\n\t\treturn value - (value - threshold) * this._viscosity;\n\t},\n\n\t_onPreDragLimit: function () {\n\t\tif (!this._viscosity || !this._offsetLimit) { return; }\n\n\t\tvar offset = this._draggable._newPos.subtract(this._draggable._startPos);\n\n\t\tvar limit = this._offsetLimit;\n\t\tif (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }\n\t\tif (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }\n\t\tif (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }\n\t\tif (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }\n\n\t\tthis._draggable._newPos = this._draggable._startPos.add(offset);\n\t},\n\n\t_onPreDragWrap: function () {\n\t\t// TODO refactor to be able to adjust map pane position after zoom\n\t\tvar worldWidth = this._worldWidth,\n\t\t    halfWidth = Math.round(worldWidth / 2),\n\t\t    dx = this._initialWorldOffset,\n\t\t    x = this._draggable._newPos.x,\n\t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n\t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n\t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n\t\tthis._draggable._absPos = this._draggable._newPos.clone();\n\t\tthis._draggable._newPos.x = newX;\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tvar map = this._map,\n\t\t    options = map.options,\n\n\t\t    noInertia = !options.inertia || this._times.length < 2;\n\n\t\tmap.fire('dragend', e);\n\n\t\tif (noInertia) {\n\t\t\tmap.fire('moveend');\n\n\t\t} else {\n\n\t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n\t\t\t    duration = (this._lastTime - this._times[0]) / 1000,\n\t\t\t    ease = options.easeLinearity,\n\n\t\t\t    speedVector = direction.multiplyBy(ease / duration),\n\t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n\t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n\t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n\t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n\t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n\t\t\tif (!offset.x && !offset.y) {\n\t\t\t\tmap.fire('moveend');\n\n\t\t\t} else {\n\t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n\t\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\t\tmap.panBy(offset, {\n\t\t\t\t\t\tduration: decelerationDuration,\n\t\t\t\t\t\teaseLinearity: ease,\n\t\t\t\t\t\tnoMoveStart: true,\n\t\t\t\t\t\tanimate: true\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\n\n\n/*\n * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdoubleClickZoom: true\n});\n\nL.Map.DoubleClickZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tthis._map.on('dblclick', this._onDoubleClick, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._map.off('dblclick', this._onDoubleClick, this);\n\t},\n\n\t_onDoubleClick: function (e) {\n\t\tvar map = this._map,\n\t\t    oldZoom = map.getZoom(),\n\t\t    zoom = e.originalEvent.shiftKey ? Math.ceil(oldZoom) - 1 : Math.floor(oldZoom) + 1;\n\n\t\tif (map.options.doubleClickZoom === 'center') {\n\t\t\tmap.setZoom(zoom);\n\t\t} else {\n\t\t\tmap.setZoomAround(e.containerPoint, zoom);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\n\n\n/*\n * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n */\n\nL.Map.mergeOptions({\n\tscrollWheelZoom: true,\n\twheelDebounceTime: 40\n});\n\nL.Map.ScrollWheelZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, {\n\t\t\tmousewheel: this._onWheelScroll,\n\t\t\tMozMousePixelScroll: L.DomEvent.preventDefault\n\t\t}, this);\n\n\t\tthis._delta = 0;\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, {\n\t\t\tmousewheel: this._onWheelScroll,\n\t\t\tMozMousePixelScroll: L.DomEvent.preventDefault\n\t\t}, this);\n\t},\n\n\t_onWheelScroll: function (e) {\n\t\tvar delta = L.DomEvent.getWheelDelta(e);\n\t\tvar debounce = this._map.options.wheelDebounceTime;\n\n\t\tthis._delta += delta;\n\t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n\t\tif (!this._startTime) {\n\t\t\tthis._startTime = +new Date();\n\t\t}\n\n\t\tvar left = Math.max(debounce - (+new Date() - this._startTime), 0);\n\n\t\tclearTimeout(this._timer);\n\t\tthis._timer = setTimeout(L.bind(this._performZoom, this), left);\n\n\t\tL.DomEvent.stop(e);\n\t},\n\n\t_performZoom: function () {\n\t\tvar map = this._map,\n\t\t    delta = this._delta,\n\t\t    zoom = map.getZoom();\n\n\t\tmap.stop(); // stop panning and fly animations if any\n\n\t\tdelta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\t\tdelta = Math.max(Math.min(delta, 4), -4);\n\t\tdelta = map._limitZoom(zoom + delta) - zoom;\n\n\t\tthis._delta = 0;\n\t\tthis._startTime = null;\n\n\t\tif (!delta) { return; }\n\n\t\tif (map.options.scrollWheelZoom === 'center') {\n\t\t\tmap.setZoom(zoom + delta);\n\t\t} else {\n\t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\n\n\n/*\r\n * Extends the event handling code with double tap support for mobile browsers.\r\n */\r\n\r\nL.extend(L.DomEvent, {\r\n\r\n\t_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\r\n\t_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\r\n\r\n\t// inspired by Zepto touch code by Thomas Fuchs\r\n\taddDoubleTapListener: function (obj, handler, id) {\r\n\t\tvar last, touch,\r\n\t\t    doubleTap = false,\r\n\t\t    delay = 250;\r\n\r\n\t\tfunction onTouchStart(e) {\r\n\t\t\tvar count;\r\n\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\tcount = L.DomEvent._pointersCount;\r\n\t\t\t} else {\r\n\t\t\t\tcount = e.touches.length;\r\n\t\t\t}\r\n\r\n\t\t\tif (count > 1) { return; }\r\n\r\n\t\t\tvar now = Date.now(),\r\n\t\t\t    delta = now - (last || now);\r\n\r\n\t\t\ttouch = e.touches ? e.touches[0] : e;\r\n\t\t\tdoubleTap = (delta > 0 && delta <= delay);\r\n\t\t\tlast = now;\r\n\t\t}\r\n\r\n\t\tfunction onTouchEnd() {\r\n\t\t\tif (doubleTap && !touch.cancelBubble) {\r\n\t\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\t\t// work around .type being readonly with MSPointer* events\r\n\t\t\t\t\tvar newTouch = {},\r\n\t\t\t\t\t    prop, i;\r\n\r\n\t\t\t\t\tfor (i in touch) {\r\n\t\t\t\t\t\tprop = touch[i];\r\n\t\t\t\t\t\tnewTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttouch = newTouch;\r\n\t\t\t\t}\r\n\t\t\t\ttouch.type = 'dblclick';\r\n\t\t\t\thandler(touch);\r\n\t\t\t\tlast = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar pre = '_leaflet_',\r\n\t\t    touchstart = this._touchstart,\r\n\t\t    touchend = this._touchend;\r\n\r\n\t\tobj[pre + touchstart + id] = onTouchStart;\r\n\t\tobj[pre + touchend + id] = onTouchEnd;\r\n\r\n\t\tobj.addEventListener(touchstart, onTouchStart, false);\r\n\t\tobj.addEventListener(touchend, onTouchEnd, false);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveDoubleTapListener: function (obj, id) {\r\n\t\tvar pre = '_leaflet_',\r\n\t\t    touchend = obj[pre + this._touchend + id];\r\n\r\n\t\tobj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\r\n\t\tobj.removeEventListener(this._touchend, touchend, false);\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n\n/*\n * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n */\n\nL.extend(L.DomEvent, {\n\n\tPOINTER_DOWN:   L.Browser.msPointer ? 'MSPointerDown'   : 'pointerdown',\n\tPOINTER_MOVE:   L.Browser.msPointer ? 'MSPointerMove'   : 'pointermove',\n\tPOINTER_UP:     L.Browser.msPointer ? 'MSPointerUp'     : 'pointerup',\n\tPOINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n\n\t_pointers: {},\n\t_pointersCount: 0,\n\n\t// Provides a touch events wrapper for (ms)pointer events.\n\t// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n\taddPointerListener: function (obj, type, handler, id) {\n\n\t\tif (type === 'touchstart') {\n\t\t\tthis._addPointerStart(obj, handler, id);\n\n\t\t} else if (type === 'touchmove') {\n\t\t\tthis._addPointerMove(obj, handler, id);\n\n\t\t} else if (type === 'touchend') {\n\t\t\tthis._addPointerEnd(obj, handler, id);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremovePointerListener: function (obj, type, id) {\n\t\tvar handler = obj['_leaflet_' + type + id];\n\n\t\tif (type === 'touchstart') {\n\t\t\tobj.removeEventListener(this.POINTER_DOWN, handler, false);\n\n\t\t} else if (type === 'touchmove') {\n\t\t\tobj.removeEventListener(this.POINTER_MOVE, handler, false);\n\n\t\t} else if (type === 'touchend') {\n\t\t\tobj.removeEventListener(this.POINTER_UP, handler, false);\n\t\t\tobj.removeEventListener(this.POINTER_CANCEL, handler, false);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_addPointerStart: function (obj, handler, id) {\n\t\tvar onDown = L.bind(function (e) {\n\t\t\tif (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n\t\t\t\tL.DomEvent.preventDefault(e);\n\t\t\t}\n\n\t\t\tthis._handlePointer(e, handler);\n\t\t}, this);\n\n\t\tobj['_leaflet_touchstart' + id] = onDown;\n\t\tobj.addEventListener(this.POINTER_DOWN, onDown, false);\n\n\t\t// need to keep track of what pointers and how many are active to provide e.touches emulation\n\t\tif (!this._pointerDocListener) {\n\t\t\tvar pointerUp = L.bind(this._globalPointerUp, this);\n\n\t\t\t// we listen documentElement as any drags that end by moving the touch off the screen get fired there\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_DOWN, L.bind(this._globalPointerDown, this), true);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_MOVE, L.bind(this._globalPointerMove, this), true);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_UP, pointerUp, true);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_CANCEL, pointerUp, true);\n\n\t\t\tthis._pointerDocListener = true;\n\t\t}\n\t},\n\n\t_globalPointerDown: function (e) {\n\t\tthis._pointers[e.pointerId] = e;\n\t\tthis._pointersCount++;\n\t},\n\n\t_globalPointerMove: function (e) {\n\t\tif (this._pointers[e.pointerId]) {\n\t\t\tthis._pointers[e.pointerId] = e;\n\t\t}\n\t},\n\n\t_globalPointerUp: function (e) {\n\t\tdelete this._pointers[e.pointerId];\n\t\tthis._pointersCount--;\n\t},\n\n\t_handlePointer: function (e, handler) {\n\t\te.touches = [];\n\t\tfor (var i in this._pointers) {\n\t\t\te.touches.push(this._pointers[i]);\n\t\t}\n\t\te.changedTouches = [e];\n\n\t\thandler(e);\n\t},\n\n\t_addPointerMove: function (obj, handler, id) {\n\t\tvar onMove = L.bind(function (e) {\n\t\t\t// don't fire touch moves when mouse isn't down\n\t\t\tif ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }\n\n\t\t\tthis._handlePointer(e, handler);\n\t\t}, this);\n\n\t\tobj['_leaflet_touchmove' + id] = onMove;\n\t\tobj.addEventListener(this.POINTER_MOVE, onMove, false);\n\t},\n\n\t_addPointerEnd: function (obj, handler, id) {\n\t\tvar onUp = L.bind(function (e) {\n\t\t\tthis._handlePointer(e, handler);\n\t\t}, this);\n\n\t\tobj['_leaflet_touchend' + id] = onUp;\n\t\tobj.addEventListener(this.POINTER_UP, onUp, false);\n\t\tobj.addEventListener(this.POINTER_CANCEL, onUp, false);\n\t}\n});\n\n\n\n/*\n * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n */\n\nL.Map.mergeOptions({\n\ttouchZoom: L.Browser.touch && !L.Browser.android23,\n\tbounceAtZoomLimits: true\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToContainerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToContainerPoint(e.touches[1]);\n\n\t\tthis._centerPoint = map.getSize()._divideBy(2);\n\t\tthis._startLatLng = map.containerPointToLatLng(this._centerPoint);\n\t\tif (map.options.touchZoom !== 'center') {\n\t\t\tthis._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n\t\t}\n\n\t\tthis._startDist = p1.distanceTo(p2);\n\t\tthis._startZoom = map.getZoom();\n\n\t\tthis._moved = false;\n\t\tthis._zooming = true;\n\n\t\tmap.stop();\n\n\t\tL.DomEvent\n\t\t    .on(document, 'touchmove', this._onTouchMove, this)\n\t\t    .on(document, 'touchend', this._onTouchEnd, this);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n\t\tvar map = this._map,\n\t\t    p1 = map.mouseEventToContainerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToContainerPoint(e.touches[1]),\n\t\t    scale = p1.distanceTo(p2) / this._startDist;\n\n\n\t\tthis._zoom = map.getScaleZoom(scale, this._startZoom);\n\n\t\tif (map.options.touchZoom === 'center') {\n\t\t\tthis._center = this._startLatLng;\n\t\t\tif (scale === 1) { return; }\n\t\t} else {\n\t\t\t// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n\t\t\tvar delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n\t\t\tif (scale === 1 && delta.x === 0 && delta.y === 0) { return; }\n\t\t\tthis._center = map.unproject(map.project(this._pinchStartLatLng).subtract(delta));\n\t\t}\n\n\t\tif (!map.options.bounceAtZoomLimits) {\n\t\t\tif ((this._zoom <= map.getMinZoom() && scale < 1) ||\n\t\t        (this._zoom >= map.getMaxZoom() && scale > 1)) { return; }\n\t\t}\n\n\t\tif (!this._moved) {\n\t\t\tmap._moveStart(true);\n\t\t\tthis._moved = true;\n\t\t}\n\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\tvar moveFn = L.bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});\n\t\tthis._animRequest = L.Util.requestAnimFrame(moveFn, this, true);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_onTouchEnd: function () {\n\t\tif (!this._moved || !this._zooming) {\n\t\t\tthis._zooming = false;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._zooming = false;\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\tL.DomEvent\n\t\t    .off(document, 'touchmove', this._onTouchMove)\n\t\t    .off(document, 'touchend', this._onTouchEnd);\n\n\t\tvar zoom = this._zoom;\n\t\tzoom = this._map._limitZoom(zoom - this._startZoom > 0 ? Math.ceil(zoom) : Math.floor(zoom));\n\n\n\t\tthis._map._animateZoom(this._center, zoom, true, true);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\n\n\n/*\n * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n */\n\nL.Map.mergeOptions({\n\ttap: true,\n\ttapTolerance: 15\n});\n\nL.Map.Tap = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\t_onDown: function (e) {\n\t\tif (!e.touches) { return; }\n\n\t\tL.DomEvent.preventDefault(e);\n\n\t\tthis._fireClick = true;\n\n\t\t// don't simulate click or track longpress if more than 1 touch\n\t\tif (e.touches.length > 1) {\n\t\t\tthis._fireClick = false;\n\t\t\tclearTimeout(this._holdTimeout);\n\t\t\treturn;\n\t\t}\n\n\t\tvar first = e.touches[0],\n\t\t    el = first.target;\n\n\t\tthis._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\n\t\t// if touching a link, highlight it\n\t\tif (el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\tL.DomUtil.addClass(el, 'leaflet-active');\n\t\t}\n\n\t\t// simulate long hold but setting a timeout\n\t\tthis._holdTimeout = setTimeout(L.bind(function () {\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._fireClick = false;\n\t\t\t\tthis._onUp();\n\t\t\t\tthis._simulateEvent('contextmenu', first);\n\t\t\t}\n\t\t}, this), 1000);\n\n\t\tthis._simulateEvent('mousedown', first);\n\n\t\tL.DomEvent.on(document, {\n\t\t\ttouchmove: this._onMove,\n\t\t\ttouchend: this._onUp\n\t\t}, this);\n\t},\n\n\t_onUp: function (e) {\n\t\tclearTimeout(this._holdTimeout);\n\n\t\tL.DomEvent.off(document, {\n\t\t\ttouchmove: this._onMove,\n\t\t\ttouchend: this._onUp\n\t\t}, this);\n\n\t\tif (this._fireClick && e && e.changedTouches) {\n\n\t\t\tvar first = e.changedTouches[0],\n\t\t\t    el = first.target;\n\n\t\t\tif (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\t\tL.DomUtil.removeClass(el, 'leaflet-active');\n\t\t\t}\n\n\t\t\tthis._simulateEvent('mouseup', first);\n\n\t\t\t// simulate click if the touch didn't move too much\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._simulateEvent('click', first);\n\t\t\t}\n\t\t}\n\t},\n\n\t_isTapValid: function () {\n\t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n\t},\n\n\t_onMove: function (e) {\n\t\tvar first = e.touches[0];\n\t\tthis._newPos = new L.Point(first.clientX, first.clientY);\n\t\tthis._simulateEvent('mousemove', first);\n\t},\n\n\t_simulateEvent: function (type, e) {\n\t\tvar simulatedEvent = document.createEvent('MouseEvents');\n\n\t\tsimulatedEvent._simulated = true;\n\t\te.target._simulatedClick = true;\n\n\t\tsimulatedEvent.initMouseEvent(\n\t\t        type, true, true, window, 1,\n\t\t        e.screenX, e.screenY,\n\t\t        e.clientX, e.clientY,\n\t\t        false, false, false, false, 0, null);\n\n\t\te.target.dispatchEvent(simulatedEvent);\n\t}\n});\n\nif (L.Browser.touch && !L.Browser.pointer) {\n\tL.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n}\n\n\n\n/*\n * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n  * (zoom to a selected bounding box), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tboxZoom: true\n});\n\nL.Map.BoxZoom = L.Handler.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._pane = map._panes.overlayPane;\n\t},\n\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);\n\t},\n\n\tmoved: function () {\n\t\treturn this._moved;\n\t},\n\n\t_resetState: function () {\n\t\tthis._moved = false;\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n\t\tthis._resetState();\n\n\t\tL.DomUtil.disableTextSelection();\n\t\tL.DomUtil.disableImageDrag();\n\n\t\tthis._startPoint = this._map.mouseEventToContainerPoint(e);\n\n\t\tL.DomEvent.on(document, {\n\t\t\tcontextmenu: L.DomEvent.stop,\n\t\t\tmousemove: this._onMouseMove,\n\t\t\tmouseup: this._onMouseUp,\n\t\t\tkeydown: this._onKeyDown\n\t\t}, this);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._moved) {\n\t\t\tthis._moved = true;\n\n\t\t\tthis._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._container);\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-crosshair');\n\n\t\t\tthis._map.fire('boxzoomstart');\n\t\t}\n\n\t\tthis._point = this._map.mouseEventToContainerPoint(e);\n\n\t\tvar bounds = new L.Bounds(this._point, this._startPoint),\n\t\t    size = bounds.getSize();\n\n\t\tL.DomUtil.setPosition(this._box, bounds.min);\n\n\t\tthis._box.style.width  = size.x + 'px';\n\t\tthis._box.style.height = size.y + 'px';\n\t},\n\n\t_finish: function () {\n\t\tif (this._moved) {\n\t\t\tL.DomUtil.remove(this._box);\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-crosshair');\n\t\t}\n\n\t\tL.DomUtil.enableTextSelection();\n\t\tL.DomUtil.enableImageDrag();\n\n\t\tL.DomEvent.off(document, {\n\t\t\tcontextmenu: L.DomEvent.stop,\n\t\t\tmousemove: this._onMouseMove,\n\t\t\tmouseup: this._onMouseUp,\n\t\t\tkeydown: this._onKeyDown\n\t\t}, this);\n\t},\n\n\t_onMouseUp: function (e) {\n\t\tif ((e.which !== 1) && (e.button !== 1)) { return; }\n\n\t\tthis._finish();\n\n\t\tif (!this._moved) { return; }\n\t\t// Postpone to next JS tick so internal click event handling\n\t\t// still see it as \"moved\".\n\t\tsetTimeout(L.bind(this._resetState, this), 0);\n\n\t\tvar bounds = new L.LatLngBounds(\n\t\t        this._map.containerPointToLatLng(this._startPoint),\n\t\t        this._map.containerPointToLatLng(this._point));\n\n\t\tthis._map\n\t\t\t.fitBounds(bounds)\n\t\t\t.fire('boxzoomend', {boxZoomBounds: bounds});\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tif (e.keyCode === 27) {\n\t\t\tthis._finish();\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\n\n\n/*\n * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tkeyboard: true,\n\tkeyboardPanOffset: 80,\n\tkeyboardZoomOffset: 1\n});\n\nL.Map.Keyboard = L.Handler.extend({\n\n\tkeyCodes: {\n\t\tleft:    [37],\n\t\tright:   [39],\n\t\tdown:    [40],\n\t\tup:      [38],\n\t\tzoomIn:  [187, 107, 61, 171],\n\t\tzoomOut: [189, 109, 54, 173]\n\t},\n\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\n\t\tthis._setPanOffset(map.options.keyboardPanOffset);\n\t\tthis._setZoomOffset(map.options.keyboardZoomOffset);\n\t},\n\n\taddHooks: function () {\n\t\tvar container = this._map._container;\n\n\t\t// make the container focusable by tabbing\n\t\tif (container.tabIndex <= 0) {\n\t\t\tcontainer.tabIndex = '0';\n\t\t}\n\n\t\tL.DomEvent.on(container, {\n\t\t\tfocus: this._onFocus,\n\t\t\tblur: this._onBlur,\n\t\t\tmousedown: this._onMouseDown\n\t\t}, this);\n\n\t\tthis._map.on({\n\t\t\tfocus: this._addHooks,\n\t\t\tblur: this._removeHooks\n\t\t}, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._removeHooks();\n\n\t\tL.DomEvent.off(this._map._container, {\n\t\t\tfocus: this._onFocus,\n\t\t\tblur: this._onBlur,\n\t\t\tmousedown: this._onMouseDown\n\t\t}, this);\n\n\t\tthis._map.off({\n\t\t\tfocus: this._addHooks,\n\t\t\tblur: this._removeHooks\n\t\t}, this);\n\t},\n\n\t_onMouseDown: function () {\n\t\tif (this._focused) { return; }\n\n\t\tvar body = document.body,\n\t\t    docEl = document.documentElement,\n\t\t    top = body.scrollTop || docEl.scrollTop,\n\t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n\t\tthis._map._container.focus();\n\n\t\twindow.scrollTo(left, top);\n\t},\n\n\t_onFocus: function () {\n\t\tthis._focused = true;\n\t\tthis._map.fire('focus');\n\t},\n\n\t_onBlur: function () {\n\t\tthis._focused = false;\n\t\tthis._map.fire('blur');\n\t},\n\n\t_setPanOffset: function (pan) {\n\t\tvar keys = this._panKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n\t\t\tkeys[codes.left[i]] = [-1 * pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n\t\t\tkeys[codes.right[i]] = [pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n\t\t\tkeys[codes.down[i]] = [0, pan];\n\t\t}\n\t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n\t\t\tkeys[codes.up[i]] = [0, -1 * pan];\n\t\t}\n\t},\n\n\t_setZoomOffset: function (zoom) {\n\t\tvar keys = this._zoomKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n\t\t\tkeys[codes.zoomIn[i]] = zoom;\n\t\t}\n\t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n\t\t\tkeys[codes.zoomOut[i]] = -zoom;\n\t\t}\n\t},\n\n\t_addHooks: function () {\n\t\tL.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_removeHooks: function () {\n\t\tL.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tif (e.altKey || e.ctrlKey || e.metaKey) { return; }\n\n\t\tvar key = e.keyCode,\n\t\t    map = this._map,\n\t\t    offset;\n\n\t\tif (key in this._panKeys) {\n\n\t\t\tif (map._panAnim && map._panAnim._inProgress) { return; }\n\n\t\t\toffset = this._panKeys[key];\n\t\t\tif (e.shiftKey) {\n\t\t\t\toffset = L.point(offset).multiplyBy(3);\n\t\t\t}\n\n\t\t\tmap.panBy(offset);\n\n\t\t\tif (map.options.maxBounds) {\n\t\t\t\tmap.panInsideBounds(map.options.maxBounds);\n\t\t\t}\n\n\t\t} else if (key in this._zoomKeys) {\n\t\t\tmap.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n\n\t\t} else if (key === 27) {\n\t\t\tmap.closePopup();\n\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tL.DomEvent.stop(e);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\n\n\n/*\n * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n */\n\nL.Handler.MarkerDrag = L.Handler.extend({\n\tinitialize: function (marker) {\n\t\tthis._marker = marker;\n\t},\n\n\taddHooks: function () {\n\t\tvar icon = this._marker._icon;\n\n\t\tif (!this._draggable) {\n\t\t\tthis._draggable = new L.Draggable(icon, icon, true);\n\t\t}\n\n\t\tthis._draggable.on({\n\t\t\tdragstart: this._onDragStart,\n\t\t\tdrag: this._onDrag,\n\t\t\tdragend: this._onDragEnd\n\t\t}, this).enable();\n\n\t\tL.DomUtil.addClass(icon, 'leaflet-marker-draggable');\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable.off({\n\t\t\tdragstart: this._onDragStart,\n\t\t\tdrag: this._onDrag,\n\t\t\tdragend: this._onDragEnd\n\t\t}, this).disable();\n\n\t\tif (this._marker._icon) {\n\t\t\tL.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n\t\t}\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tthis._marker\n\t\t    .closePopup()\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\t},\n\n\t_onDrag: function (e) {\n\t\tvar marker = this._marker,\n\t\t    shadow = marker._shadow,\n\t\t    iconPos = L.DomUtil.getPosition(marker._icon),\n\t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n\t\t// update shadow position\n\t\tif (shadow) {\n\t\t\tL.DomUtil.setPosition(shadow, iconPos);\n\t\t}\n\n\t\tmarker._latlng = latlng;\n\t\te.latlng = latlng;\n\n\t\tmarker\n\t\t    .fire('move', e)\n\t\t    .fire('drag', e);\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tthis._marker\n\t\t    .fire('moveend')\n\t\t    .fire('dragend', e);\n\t}\n});\n\n\n\n/*\r\n * L.Control is a base class for implementing map controls. Handles positioning.\r\n * All other controls extend from this class.\r\n */\r\n\r\nL.Control = L.Class.extend({\r\n\toptions: {\r\n\t\tposition: 'topright'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\t\treturn this.options.position;\r\n\t},\r\n\r\n\tsetPosition: function (position) {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.removeControl(this);\r\n\t\t}\r\n\r\n\t\tthis.options.position = position;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.addControl(this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tthis.remove();\r\n\t\tthis._map = map;\r\n\r\n\t\tvar container = this._container = this.onAdd(map),\r\n\t\t    pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-control');\r\n\r\n\t\tif (pos.indexOf('bottom') !== -1) {\r\n\t\t\tcorner.insertBefore(container, corner.firstChild);\r\n\t\t} else {\r\n\t\t\tcorner.appendChild(container);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremove: function () {\r\n\t\tif (!this._map) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tL.DomUtil.remove(this._container);\r\n\r\n\t\tif (this.onRemove) {\r\n\t\t\tthis.onRemove(this._map);\r\n\t\t}\r\n\r\n\t\tthis._map = null;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_refocusOnMap: function (e) {\r\n\t\t// if map exists and event is not a keyboard event\r\n\t\tif (this._map && e && e.screenX > 0 && e.screenY > 0) {\r\n\t\t\tthis._map.getContainer().focus();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.control = function (options) {\r\n\treturn new L.Control(options);\r\n};\r\n\r\n\r\n// adds control-related methods to L.Map\r\n\r\nL.Map.include({\r\n\taddControl: function (control) {\r\n\t\tcontrol.addTo(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveControl: function (control) {\r\n\t\tcontrol.remove();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initControlPos: function () {\r\n\t\tvar corners = this._controlCorners = {},\r\n\t\t    l = 'leaflet-',\r\n\t\t    container = this._controlContainer =\r\n\t\t            L.DomUtil.create('div', l + 'control-container', this._container);\r\n\r\n\t\tfunction createCorner(vSide, hSide) {\r\n\t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\r\n\t\t\tcorners[vSide + hSide] = L.DomUtil.create('div', className, container);\r\n\t\t}\r\n\r\n\t\tcreateCorner('top', 'left');\r\n\t\tcreateCorner('top', 'right');\r\n\t\tcreateCorner('bottom', 'left');\r\n\t\tcreateCorner('bottom', 'right');\r\n\t},\r\n\r\n\t_clearControlPos: function () {\r\n\t\tL.DomUtil.remove(this._controlContainer);\r\n\t}\r\n});\r\n\n\n\n/*\r\n * L.Control.Zoom is used for the default zoom buttons on the map.\r\n */\r\n\r\nL.Control.Zoom = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'topleft',\r\n\t\tzoomInText: '+',\r\n\t\tzoomInTitle: 'Zoom in',\r\n\t\tzoomOutText: '-',\r\n\t\tzoomOutTitle: 'Zoom out'\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tvar zoomName = 'leaflet-control-zoom',\r\n\t\t    container = L.DomUtil.create('div', zoomName + ' leaflet-bar'),\r\n\t\t    options = this.options;\r\n\r\n\t\tthis._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,\r\n\t\t        zoomName + '-in',  container, this._zoomIn);\r\n\t\tthis._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,\r\n\t\t        zoomName + '-out', container, this._zoomOut);\r\n\r\n\t\tthis._updateDisabled();\r\n\t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\t},\r\n\r\n\tdisable: function () {\r\n\t\tthis._disabled = true;\r\n\t\tthis._updateDisabled();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tenable: function () {\r\n\t\tthis._disabled = false;\r\n\t\tthis._updateDisabled();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_zoomIn: function (e) {\r\n\t\tif (!this._disabled) {\r\n\t\t\tthis._map.zoomIn(e.shiftKey ? 3 : 1);\r\n\t\t}\r\n\t},\r\n\r\n\t_zoomOut: function (e) {\r\n\t\tif (!this._disabled) {\r\n\t\t\tthis._map.zoomOut(e.shiftKey ? 3 : 1);\r\n\t\t}\r\n\t},\r\n\r\n\t_createButton: function (html, title, className, container, fn) {\r\n\t\tvar link = L.DomUtil.create('a', className, container);\r\n\t\tlink.innerHTML = html;\r\n\t\tlink.href = '#';\r\n\t\tlink.title = title;\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)\r\n\t\t    .on(link, 'click', L.DomEvent.stop)\r\n\t\t    .on(link, 'click', fn, this)\r\n\t\t    .on(link, 'click', this._refocusOnMap, this);\r\n\r\n\t\treturn link;\r\n\t},\r\n\r\n\t_updateDisabled: function () {\r\n\t\tvar map = this._map,\r\n\t\t    className = 'leaflet-disabled';\r\n\r\n\t\tL.DomUtil.removeClass(this._zoomInButton, className);\r\n\t\tL.DomUtil.removeClass(this._zoomOutButton, className);\r\n\r\n\t\tif (this._disabled || map._zoom === map.getMinZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomOutButton, className);\r\n\t\t}\r\n\t\tif (this._disabled || map._zoom === map.getMaxZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomInButton, className);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tzoomControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.zoomControl) {\r\n\t\tthis.zoomControl = new L.Control.Zoom();\r\n\t\tthis.addControl(this.zoomControl);\r\n\t}\r\n});\r\n\r\nL.control.zoom = function (options) {\r\n\treturn new L.Control.Zoom(options);\r\n};\r\n\n\n\n/*\r\n * L.Control.Attribution is used for displaying attribution on the map (added by default).\r\n */\r\n\r\nL.Control.Attribution = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'bottomright',\r\n\t\tprefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._attributions = {};\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-control-attribution');\r\n\t\tif (L.DomEvent) {\r\n\t\t\tL.DomEvent.disableClickPropagation(this._container);\r\n\t\t}\r\n\r\n\t\t// TODO ugly, refactor\r\n\t\tfor (var i in map._layers) {\r\n\t\t\tif (map._layers[i].getAttribution) {\r\n\t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tsetPrefix: function (prefix) {\r\n\t\tthis.options.prefix = prefix;\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddAttribution: function (text) {\r\n\t\tif (!text) { return this; }\r\n\r\n\t\tif (!this._attributions[text]) {\r\n\t\t\tthis._attributions[text] = 0;\r\n\t\t}\r\n\t\tthis._attributions[text]++;\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveAttribution: function (text) {\r\n\t\tif (!text) { return this; }\r\n\r\n\t\tif (this._attributions[text]) {\r\n\t\t\tthis._attributions[text]--;\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar attribs = [];\r\n\r\n\t\tfor (var i in this._attributions) {\r\n\t\t\tif (this._attributions[i]) {\r\n\t\t\t\tattribs.push(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar prefixAndAttribs = [];\r\n\r\n\t\tif (this.options.prefix) {\r\n\t\t\tprefixAndAttribs.push(this.options.prefix);\r\n\t\t}\r\n\t\tif (attribs.length) {\r\n\t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n\t\t}\r\n\r\n\t\tthis._container.innerHTML = prefixAndAttribs.join(' | ');\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tattributionControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.attributionControl) {\r\n\t\tthis.attributionControl = (new L.Control.Attribution()).addTo(this);\r\n\t}\r\n});\r\n\r\nL.control.attribution = function (options) {\r\n\treturn new L.Control.Attribution(options);\r\n};\r\n\n\n\n/*\n * L.Control.Scale is used for displaying metric/imperial scale on the map.\n */\n\nL.Control.Scale = L.Control.extend({\n\toptions: {\n\t\tposition: 'bottomleft',\n\t\tmaxWidth: 100,\n\t\tmetric: true,\n\t\timperial: true\n\t\t// updateWhenIdle: false\n\t},\n\n\tonAdd: function (map) {\n\t\tvar className = 'leaflet-control-scale',\n\t\t    container = L.DomUtil.create('div', className),\n\t\t    options = this.options;\n\n\t\tthis._addScales(options, className + '-line', container);\n\n\t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t\tmap.whenReady(this._update, this);\n\n\t\treturn container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t},\n\n\t_addScales: function (options, className, container) {\n\t\tif (options.metric) {\n\t\t\tthis._mScale = L.DomUtil.create('div', className, container);\n\t\t}\n\t\tif (options.imperial) {\n\t\t\tthis._iScale = L.DomUtil.create('div', className, container);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tvar map = this._map,\n\t\t    y = map.getSize().y / 2;\n\n\t\tvar maxMeters = map.distance(\n\t\t\t\tmap.containerPointToLatLng([0, y]),\n\t\t\t\tmap.containerPointToLatLng([this.options.maxWidth, y]));\n\n\t\tthis._updateScales(maxMeters);\n\t},\n\n\t_updateScales: function (maxMeters) {\n\t\tif (this.options.metric && maxMeters) {\n\t\t\tthis._updateMetric(maxMeters);\n\t\t}\n\t\tif (this.options.imperial && maxMeters) {\n\t\t\tthis._updateImperial(maxMeters);\n\t\t}\n\t},\n\n\t_updateMetric: function (maxMeters) {\n\t\tvar meters = this._getRoundNum(maxMeters),\n\t\t    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\n\t\tthis._updateScale(this._mScale, label, meters / maxMeters);\n\t},\n\n\t_updateImperial: function (maxMeters) {\n\t\tvar maxFeet = maxMeters * 3.2808399,\n\t\t    maxMiles, miles, feet;\n\n\t\tif (maxFeet > 5280) {\n\t\t\tmaxMiles = maxFeet / 5280;\n\t\t\tmiles = this._getRoundNum(maxMiles);\n\t\t\tthis._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n\n\t\t} else {\n\t\t\tfeet = this._getRoundNum(maxFeet);\n\t\t\tthis._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n\t\t}\n\t},\n\n\t_updateScale: function (scale, text, ratio) {\n\t\tscale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n\t\tscale.innerHTML = text;\n\t},\n\n\t_getRoundNum: function (num) {\n\t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n\t\t    d = num / pow10;\n\n\t\td = d >= 10 ? 10 :\n\t\t    d >= 5 ? 5 :\n\t\t    d >= 3 ? 3 :\n\t\t    d >= 2 ? 2 : 1;\n\n\t\treturn pow10 * d;\n\t}\n});\n\nL.control.scale = function (options) {\n\treturn new L.Control.Scale(options);\n};\n\n\n\n/*\r\n * L.Control.Layers is a control to allow users to switch between different layers on the map.\r\n */\r\n\r\nL.Control.Layers = L.Control.extend({\r\n\toptions: {\r\n\t\tcollapsed: true,\r\n\t\tposition: 'topright',\r\n\t\tautoZIndex: true,\r\n\t\thideSingleBase: false\r\n\t},\r\n\r\n\tinitialize: function (baseLayers, overlays, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._lastZIndex = 0;\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tfor (var i in baseLayers) {\r\n\t\t\tthis._addLayer(baseLayers[i], i);\r\n\t\t}\r\n\r\n\t\tfor (i in overlays) {\r\n\t\t\tthis._addLayer(overlays[i], i, true);\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._initLayout();\r\n\t\tthis._update();\r\n\r\n\t\tthis._map = map;\r\n\t\tmap.on('zoomend', this._checkDisabledLayers, this);\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function () {\r\n\t\tthis._map.off('zoomend', this._checkDisabledLayers, this);\r\n\t},\r\n\r\n\taddBaseLayer: function (layer, name) {\r\n\t\tthis._addLayer(layer, name);\r\n\t\treturn this._update();\r\n\t},\r\n\r\n\taddOverlay: function (layer, name) {\r\n\t\tthis._addLayer(layer, name, true);\r\n\t\treturn this._update();\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tlayer.off('add remove', this._onLayerChange, this);\r\n\r\n\t\tdelete this._layers[L.stamp(layer)];\r\n\t\treturn this._update();\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar className = 'leaflet-control-layers',\r\n\t\t    container = this._container = L.DomUtil.create('div', className);\r\n\r\n\t\t// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\r\n\t\tcontainer.setAttribute('aria-haspopup', true);\r\n\r\n\t\tL.DomEvent.disableClickPropagation(container);\r\n\t\tif (!L.Browser.touch) {\r\n\t\t\tL.DomEvent.disableScrollPropagation(container);\r\n\t\t}\r\n\r\n\t\tvar form = this._form = L.DomUtil.create('form', className + '-list');\r\n\r\n\t\tif (this.options.collapsed) {\r\n\t\t\tif (!L.Browser.android) {\r\n\t\t\t\tL.DomEvent.on(container, {\r\n\t\t\t\t\tmouseenter: this._expand,\r\n\t\t\t\t\tmouseleave: this._collapse\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\r\n\t\t\tvar link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\r\n\t\t\tlink.href = '#';\r\n\t\t\tlink.title = 'Layers';\r\n\r\n\t\t\tif (L.Browser.touch) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(link, 'click', L.DomEvent.stop)\r\n\t\t\t\t    .on(link, 'click', this._expand, this);\r\n\t\t\t} else {\r\n\t\t\t\tL.DomEvent.on(link, 'focus', this._expand, this);\r\n\t\t\t}\r\n\r\n\t\t\t// work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033\r\n\t\t\tL.DomEvent.on(form, 'click', function () {\r\n\t\t\t\tsetTimeout(L.bind(this._onInputClick, this), 0);\r\n\t\t\t}, this);\r\n\r\n\t\t\tthis._map.on('click', this._collapse, this);\r\n\t\t\t// TODO keyboard accessibility\r\n\t\t} else {\r\n\t\t\tthis._expand();\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList = L.DomUtil.create('div', className + '-base', form);\r\n\t\tthis._separator = L.DomUtil.create('div', className + '-separator', form);\r\n\t\tthis._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\r\n\r\n\t\tcontainer.appendChild(form);\r\n\t},\r\n\r\n\t_addLayer: function (layer, name, overlay) {\r\n\t\tlayer.on('add remove', this._onLayerChange, this);\r\n\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tthis._layers[id] = {\r\n\t\t\tlayer: layer,\r\n\t\t\tname: name,\r\n\t\t\toverlay: overlay\r\n\t\t};\r\n\r\n\t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n\t\t\tthis._lastZIndex++;\r\n\t\t\tlayer.setZIndex(this._lastZIndex);\r\n\t\t}\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._container) { return this; }\r\n\r\n\t\tL.DomUtil.empty(this._baseLayersList);\r\n\t\tL.DomUtil.empty(this._overlaysList);\r\n\r\n\t\tvar baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tobj = this._layers[i];\r\n\t\t\tthis._addItem(obj);\r\n\t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n\t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n\t\t\tbaseLayersCount += !obj.overlay ? 1 : 0;\r\n\t\t}\r\n\r\n\t\t// Hide base layers section if there's only one layer.\r\n\t\tif (this.options.hideSingleBase) {\r\n\t\t\tbaseLayersPresent = baseLayersPresent && baseLayersCount > 1;\r\n\t\t\tthis._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\r\n\t\t}\r\n\r\n\t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_onLayerChange: function (e) {\r\n\t\tif (!this._handlingClick) {\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tvar obj = this._layers[L.stamp(e.target)];\r\n\r\n\t\tvar type = obj.overlay ?\r\n\t\t\t(e.type === 'add' ? 'overlayadd' : 'overlayremove') :\r\n\t\t\t(e.type === 'add' ? 'baselayerchange' : null);\r\n\r\n\t\tif (type) {\r\n\t\t\tthis._map.fire(type, obj);\r\n\t\t}\r\n\t},\r\n\r\n\t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\r\n\t_createRadioElement: function (name, checked) {\r\n\r\n\t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' +\r\n\t\t\t\tname + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\r\n\r\n\t\tvar radioFragment = document.createElement('div');\r\n\t\tradioFragment.innerHTML = radioHtml;\r\n\r\n\t\treturn radioFragment.firstChild;\r\n\t},\r\n\r\n\t_addItem: function (obj) {\r\n\t\tvar label = document.createElement('label'),\r\n\t\t    checked = this._map.hasLayer(obj.layer),\r\n\t\t    input;\r\n\r\n\t\tif (obj.overlay) {\r\n\t\t\tinput = document.createElement('input');\r\n\t\t\tinput.type = 'checkbox';\r\n\t\t\tinput.className = 'leaflet-control-layers-selector';\r\n\t\t\tinput.defaultChecked = checked;\r\n\t\t} else {\r\n\t\t\tinput = this._createRadioElement('leaflet-base-layers', checked);\r\n\t\t}\r\n\r\n\t\tinput.layerId = L.stamp(obj.layer);\r\n\r\n\t\tL.DomEvent.on(input, 'click', this._onInputClick, this);\r\n\r\n\t\tvar name = document.createElement('span');\r\n\t\tname.innerHTML = ' ' + obj.name;\r\n\r\n\t\t// Helps from preventing layer control flicker when checkboxes are disabled\r\n\t\t// https://github.com/Leaflet/Leaflet/issues/2771\r\n\t\tvar holder = document.createElement('div');\r\n\r\n\t\tlabel.appendChild(holder);\r\n\t\tholder.appendChild(input);\r\n\t\tholder.appendChild(name);\r\n\r\n\t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n\t\tcontainer.appendChild(label);\r\n\r\n\t\tthis._checkDisabledLayers();\r\n\t\treturn label;\r\n\t},\r\n\r\n\t_onInputClick: function () {\r\n\t\tvar inputs = this._form.getElementsByTagName('input'),\r\n\t\t    input, layer, hasLayer;\r\n\t\tvar addedLayers = [],\r\n\t\t    removedLayers = [];\r\n\r\n\t\tthis._handlingClick = true;\r\n\r\n\t\tfor (var i = inputs.length - 1; i >= 0; i--) {\r\n\t\t\tinput = inputs[i];\r\n\t\t\tlayer = this._layers[input.layerId].layer;\r\n\t\t\thasLayer = this._map.hasLayer(layer);\r\n\r\n\t\t\tif (input.checked && !hasLayer) {\r\n\t\t\t\taddedLayers.push(layer);\r\n\r\n\t\t\t} else if (!input.checked && hasLayer) {\r\n\t\t\t\tremovedLayers.push(layer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Bugfix issue 2318: Should remove all old layers before readding new ones\r\n\t\tfor (i = 0; i < removedLayers.length; i++) {\r\n\t\t\tthis._map.removeLayer(removedLayers[i]);\r\n\t\t}\r\n\t\tfor (i = 0; i < addedLayers.length; i++) {\r\n\t\t\tthis._map.addLayer(addedLayers[i]);\r\n\t\t}\r\n\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tthis._refocusOnMap();\r\n\t},\r\n\r\n\t_expand: function () {\r\n\t\tL.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\r\n\t\tthis._form.style.height = null;\r\n\t\tvar acceptableHeight = this._map._size.y - (this._container.offsetTop + 50);\r\n\t\tif (acceptableHeight < this._form.clientHeight) {\r\n\t\t\tL.DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');\r\n\t\t\tthis._form.style.height = acceptableHeight + 'px';\r\n\t\t} else {\r\n\t\t\tL.DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');\r\n\t\t}\r\n\t\tthis._checkDisabledLayers();\r\n\t},\r\n\r\n\t_collapse: function () {\r\n\t\tL.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');\r\n\t},\r\n\r\n\t_checkDisabledLayers: function () {\r\n\t\tvar inputs = this._form.getElementsByTagName('input'),\r\n\t\t    input,\r\n\t\t    layer,\r\n\t\t    zoom = this._map.getZoom();\r\n\r\n\t\tfor (var i = inputs.length - 1; i >= 0; i--) {\r\n\t\t\tinput = inputs[i];\r\n\t\t\tlayer = this._layers[input.layerId].layer;\r\n\t\t\tinput.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||\r\n\t\t\t                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);\r\n\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.control.layers = function (baseLayers, overlays, options) {\r\n\treturn new L.Control.Layers(baseLayers, overlays, options);\r\n};\r\n\n\n\n/*\n * L.PosAnimation powers Leaflet pan animations internally.\n */\n\nL.PosAnimation = L.Evented.extend({\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._duration = duration || 0.25;\n\t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n\t\tthis._startPos = L.DomUtil.getPosition(el);\n\t\tthis._offset = newPos.subtract(this._startPos);\n\t\tthis._startTime = +new Date();\n\n\t\tthis.fire('start');\n\n\t\tthis._animate();\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\tthis._step(true);\n\t\tthis._complete();\n\t},\n\n\t_animate: function () {\n\t\t// animation loop\n\t\tthis._animId = L.Util.requestAnimFrame(this._animate, this);\n\t\tthis._step();\n\t},\n\n\t_step: function (round) {\n\t\tvar elapsed = (+new Date()) - this._startTime,\n\t\t    duration = this._duration * 1000;\n\n\t\tif (elapsed < duration) {\n\t\t\tthis._runFrame(this._easeOut(elapsed / duration), round);\n\t\t} else {\n\t\t\tthis._runFrame(1);\n\t\t\tthis._complete();\n\t\t}\n\t},\n\n\t_runFrame: function (progress, round) {\n\t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n\t\tif (round) {\n\t\t\tpos._round();\n\t\t}\n\t\tL.DomUtil.setPosition(this._el, pos);\n\n\t\tthis.fire('step');\n\t},\n\n\t_complete: function () {\n\t\tL.Util.cancelAnimFrame(this._animId);\n\n\t\tthis._inProgress = false;\n\t\tthis.fire('end');\n\t},\n\n\t_easeOut: function (t) {\n\t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n\t}\n});\n\n\n\n/*\n * Extends L.Map to handle panning animations.\n */\n\nL.Map.include({\n\n\tsetView: function (center, zoom, options) {\n\n\t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n\t\tcenter = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n\t\toptions = options || {};\n\n\t\tthis.stop();\n\n\t\tif (this._loaded && !options.reset && options !== true) {\n\n\t\t\tif (options.animate !== undefined) {\n\t\t\t\toptions.zoom = L.extend({animate: options.animate}, options.zoom);\n\t\t\t\toptions.pan = L.extend({animate: options.animate, duration: options.duration}, options.pan);\n\t\t\t}\n\n\t\t\t// try animating pan or zoom\n\t\t\tvar moved = (this._zoom !== zoom) ?\n\t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\n\t\t\t\tthis._tryAnimatedPan(center, options.pan);\n\n\t\t\tif (moved) {\n\t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\n\t\t\t\tclearTimeout(this._sizeTimer);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// animation didn't start, just reset the map view\n\t\tthis._resetView(center, zoom);\n\n\t\treturn this;\n\t},\n\n\tpanBy: function (offset, options) {\n\t\toffset = L.point(offset).round();\n\t\toptions = options || {};\n\n\t\tif (!offset.x && !offset.y) {\n\t\t\treturn this.fire('moveend');\n\t\t}\n\t\t// If we pan too far, Chrome gets issues with tiles\n\t\t// and makes them disappear or appear in the wrong place (slightly offset) #2602\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) {\n\t\t\tthis._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!this._panAnim) {\n\t\t\tthis._panAnim = new L.PosAnimation();\n\n\t\t\tthis._panAnim.on({\n\t\t\t\t'step': this._onPanTransitionStep,\n\t\t\t\t'end': this._onPanTransitionEnd\n\t\t\t}, this);\n\t\t}\n\n\t\t// don't fire movestart if animating inertia\n\t\tif (!options.noMoveStart) {\n\t\t\tthis.fire('movestart');\n\t\t}\n\n\t\t// animate pan unless animate: false specified\n\t\tif (options.animate !== false) {\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n\n\t\t\tvar newPos = this._getMapPanePos().subtract(offset);\n\t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n\t\t} else {\n\t\t\tthis._rawPanBy(offset);\n\t\t\tthis.fire('move').fire('moveend');\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_onPanTransitionStep: function () {\n\t\tthis.fire('move');\n\t},\n\n\t_onPanTransitionEnd: function () {\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n\t\tthis.fire('moveend');\n\t},\n\n\t_tryAnimatedPan: function (center, options) {\n\t\t// difference between the new and current centers in pixels\n\t\tvar offset = this._getCenterOffset(center)._floor();\n\n\t\t// don't animate too far unless animate: true specified in options\n\t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis.panBy(offset, options);\n\n\t\treturn true;\n\t}\n});\n\n\n\n/*\n * Extends L.Map to handle zoom animations.\n */\n\nL.Map.mergeOptions({\n\tzoomAnimation: true,\n\tzoomAnimationThreshold: 4\n});\n\nvar zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera;\n\nif (zoomAnimated) {\n\n\tL.Map.addInitHook(function () {\n\t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\t\tthis._zoomAnimated = this.options.zoomAnimation;\n\n\t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\n\t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\t\tif (this._zoomAnimated) {\n\n\t\t\tthis._createAnimProxy();\n\n\t\t\tL.DomEvent.on(this._proxy, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n\t\t}\n\t});\n}\n\nL.Map.include(!zoomAnimated ? {} : {\n\n\t_createAnimProxy: function () {\n\n\t\tvar proxy = this._proxy = L.DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');\n\t\tthis._panes.mapPane.appendChild(proxy);\n\n\t\tthis.on('zoomanim', function (e) {\n\t\t\tvar prop = L.DomUtil.TRANSFORM,\n\t\t\t    transform = proxy.style[prop];\n\n\t\t\tL.DomUtil.setTransform(proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\n\n\t\t\t// workaround for case when transform is the same and so transitionend event is not fired\n\t\t\tif (transform === proxy.style[prop] && this._animatingZoom) {\n\t\t\t\tthis._onZoomTransitionEnd();\n\t\t\t}\n\t\t}, this);\n\n\t\tthis.on('load moveend', function () {\n\t\t\tvar c = this.getCenter(),\n\t\t\t    z = this.getZoom();\n\t\t\tL.DomUtil.setTransform(proxy, this.project(c, z), this.getZoomScale(z, 1));\n\t\t}, this);\n\t},\n\n\t_catchTransitionEnd: function (e) {\n\t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n\t\t\tthis._onZoomTransitionEnd();\n\t\t}\n\t},\n\n\t_nothingToAnimate: function () {\n\t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n\t},\n\n\t_tryAnimatedZoom: function (center, zoom, options) {\n\n\t\tif (this._animatingZoom) { return true; }\n\n\t\toptions = options || {};\n\n\t\t// don't animate if disabled, not supported or zoom difference is too large\n\t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\n\t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\n\n\t\t// offset is the pixel coords of the zoom origin relative to the current center\n\t\tvar scale = this.getZoomScale(zoom),\n\t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\n\n\t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis\n\t\t\t    ._moveStart(true)\n\t\t\t    ._animateZoom(center, zoom, true);\n\t\t}, this);\n\n\t\treturn true;\n\t},\n\n\t_animateZoom: function (center, zoom, startAnim, noUpdate) {\n\t\tif (startAnim) {\n\t\t\tthis._animatingZoom = true;\n\n\t\t\t// remember what center/zoom to set after animation\n\t\t\tthis._animateToCenter = center;\n\t\t\tthis._animateToZoom = zoom;\n\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\t\t}\n\n\t\tthis.fire('zoomanim', {\n\t\t\tcenter: center,\n\t\t\tzoom: zoom,\n\t\t\tnoUpdate: noUpdate\n\t\t});\n\n\t\t// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n\t\tsetTimeout(L.bind(this._onZoomTransitionEnd, this), 250);\n\t},\n\n\t_onZoomTransitionEnd: function () {\n\t\tif (!this._animatingZoom) { return; }\n\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\t// This anim frame should prevent an obscure iOS webkit tile loading race condition.\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis._animatingZoom = false;\n\n\t\t\tthis\n\t\t\t\t._move(this._animateToCenter, this._animateToZoom)\n\t\t\t\t._moveEnd(true);\n\t\t}, this);\n\t}\n});\n\n\n\n\nL.Map.include({\n\tflyTo: function (targetCenter, targetZoom, options) {\n\n\t\toptions = options || {};\n\t\tif (options.animate === false || !L.Browser.any3d) {\n\t\t\treturn this.setView(targetCenter, targetZoom, options);\n\t\t}\n\n\t\tthis.stop();\n\n\t\tvar from = this.project(this.getCenter()),\n\t\t    to = this.project(targetCenter),\n\t\t    size = this.getSize(),\n\t\t    startZoom = this._zoom;\n\n\t\ttargetCenter = L.latLng(targetCenter);\n\t\ttargetZoom = targetZoom === undefined ? startZoom : targetZoom;\n\n\t\tvar w0 = Math.max(size.x, size.y),\n\t\t    w1 = w0 * this.getZoomScale(startZoom, targetZoom),\n\t\t    u1 = (to.distanceTo(from)) || 1,\n\t\t    rho = 1.42,\n\t\t    rho2 = rho * rho;\n\n\t\tfunction r(i) {\n\t\t\tvar b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);\n\t\t\treturn Math.log(Math.sqrt(b * b + 1) - b);\n\t\t}\n\n\t\tfunction sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }\n\t\tfunction cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }\n\t\tfunction tanh(n) { return sinh(n) / cosh(n); }\n\n\t\tvar r0 = r(0);\n\n\t\tfunction w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }\n\t\tfunction u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }\n\n\t\tfunction easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }\n\n\t\tvar start = Date.now(),\n\t\t    S = (r(1) - r0) / rho,\n\t\t    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n\n\t\tfunction frame() {\n\t\t\tvar t = (Date.now() - start) / duration,\n\t\t\t    s = easeOut(t) * S;\n\n\t\t\tif (t <= 1) {\n\t\t\t\tthis._flyToFrame = L.Util.requestAnimFrame(frame, this);\n\n\t\t\t\tthis._move(\n\t\t\t\t\tthis.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),\n\t\t\t\t\tthis.getScaleZoom(w0 / w(s), startZoom),\n\t\t\t\t\t{flyTo: true});\n\n\t\t\t} else {\n\t\t\t\tthis\n\t\t\t\t\t._move(targetCenter, targetZoom)\n\t\t\t\t\t._moveEnd(true);\n\t\t\t}\n\t\t}\n\n\t\tthis._moveStart(true);\n\n\t\tframe.call(this);\n\t\treturn this;\n\t},\n\n\tflyToBounds: function (bounds, options) {\n\t\tvar target = this._getBoundsCenterZoom(bounds, options);\n\t\treturn this.flyTo(target.center, target.zoom, options);\n\t}\n});\n\n\n\n/*\r\n * Provides L.Map with convenient shortcuts for using browser geolocation features.\r\n */\r\n\r\nL.Map.include({\r\n\t_defaultLocateOptions: {\r\n\t\ttimeout: 10000,\r\n\t\twatch: false\r\n\t\t// setView: false\r\n\t\t// maxZoom: <Number>\r\n\t\t// maximumAge: 0\r\n\t\t// enableHighAccuracy: false\r\n\t},\r\n\r\n\tlocate: function (options) {\r\n\r\n\t\toptions = this._locateOptions = L.extend({}, this._defaultLocateOptions, options);\r\n\r\n\t\tif (!('geolocation' in navigator)) {\r\n\t\t\tthis._handleGeolocationError({\r\n\t\t\t\tcode: 0,\r\n\t\t\t\tmessage: 'Geolocation not supported.'\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar onResponse = L.bind(this._handleGeolocationResponse, this),\r\n\t\t    onError = L.bind(this._handleGeolocationError, this);\r\n\r\n\t\tif (options.watch) {\r\n\t\t\tthis._locationWatchId =\r\n\t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n\t\t} else {\r\n\t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopLocate: function () {\r\n\t\tif (navigator.geolocation && navigator.geolocation.clearWatch) {\r\n\t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n\t\t}\r\n\t\tif (this._locateOptions) {\r\n\t\t\tthis._locateOptions.setView = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_handleGeolocationError: function (error) {\r\n\t\tvar c = error.code,\r\n\t\t    message = error.message ||\r\n\t\t            (c === 1 ? 'permission denied' :\r\n\t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n\t\tif (this._locateOptions.setView && !this._loaded) {\r\n\t\t\tthis.fitWorld();\r\n\t\t}\r\n\r\n\t\tthis.fire('locationerror', {\r\n\t\t\tcode: c,\r\n\t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n\t\t});\r\n\t},\r\n\r\n\t_handleGeolocationResponse: function (pos) {\r\n\t\tvar lat = pos.coords.latitude,\r\n\t\t    lng = pos.coords.longitude,\r\n\t\t    latlng = new L.LatLng(lat, lng),\r\n\t\t    bounds = latlng.toBounds(pos.coords.accuracy),\r\n\t\t    options = this._locateOptions;\r\n\r\n\t\tif (options.setView) {\r\n\t\t\tvar zoom = this.getBoundsZoom(bounds);\r\n\t\t\tthis.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tbounds: bounds,\r\n\t\t\ttimestamp: pos.timestamp\r\n\t\t};\r\n\r\n\t\tfor (var i in pos.coords) {\r\n\t\t\tif (typeof pos.coords[i] === 'number') {\r\n\t\t\t\tdata[i] = pos.coords[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.fire('locationfound', data);\r\n\t}\r\n});\r\n\n\n}(window, document));\n\n},{}],6:[function(require,module,exports){\n(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n},{}],7:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// Polyfills\nrequire('whatwg-fetch');\n\n// Leaflet, map libraries and Tangram\nvar L = require('leaflet');\nrequire('leaflet-hash');\nrequire('leaflet.locatecontrol')\nrequire('leaflet-geocoder-mapzen');\n// require('drmonty-leaflet-awesome-markers');\n\nvar Tangram = (typeof window !== \"undefined\" ? window['Tangram'] : typeof global !== \"undefined\" ? global['Tangram'] : null); // via browserify-shim\n\nvar SEARCH_API_KEY = 'search-KqgQGdk';\n\n// Set this manually inside a bundle\nL.Icon.Default.imagePath = 'site/images';\n\n// Leaflet\nvar map = L.map('map', {\n  zoomControl: false,\n  worldCopyJump: true\n}).setView([40.7259, -73.9805], 12);\n\n// URL Hash\nvar hash = new L.Hash(map);\n\n// Zoom controls\nL.control.zoom({ position: 'topright' }).addTo(map);\n\n// Locate me control\nvar locator = L.control.locate({\n  position: 'topright',\n  follow: false,\n  showPopup: false,\n  keepCurrentZoomLevel: true\n}).addTo(map)\n\n// Tangram\nvar layer = Tangram.leafletLayer({\n  scene: 'site/outdoor-style.yaml',\n  attribution: '&copy; OSM contributors'\n}).addTo(map);\n\n// Search\nvar geocoder = L.control.geocoder(SEARCH_API_KEY, {\n  expanded: true\n}).addTo(map);\n\n// Reverse\nvar markers = [];\n\nmap.on('click', function (e) {\n  var latlng = e.latlng;\n  var reverse = 'https://search.mapzen.com/v1/reverse?point.lat=' + latlng.lat + '&point.lon=' + latlng.lng + '&size=1&layers=address&api_key=' + SEARCH_API_KEY;\n\n  // Add a marker on click immediately\n  removeMarkers();\n  var marker = new L.marker(latlng);\n  markers.push(marker);\n  map.addLayer(marker);\n  map.panTo(latlng);\n\n  // Reverse geocode and then display things based on it\n  window.fetch(reverse)\n    .then(function (response) {\n      if (!response.ok) {\n        throw new Error('status code: ' + response.status);\n      }\n\n      return response.json();\n    })\n    .then(function (response) {\n      var label = response.features[0].properties.label;\n      marker.bindPopup(label).openPopup();\n    })\n    .catch(function (error) {\n      console.log('error getting reverse geocode. ' + error);\n    });\n\n  function removeMarkers () {\n    for (var i = 0; i < markers.length; i++) {\n      map.removeLayer(markers[i]);\n    }\n    markers = [];\n  };\n});\n\n// Hashes update parent if iframed\nwindow.addEventListener('hashchange', function () {\n  parent.postMessage(window.location.hash, '*');\n});\n\n// Debug\nwindow.map = map;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"leaflet\":5,\"leaflet-geocoder-mapzen\":1,\"leaflet-hash\":2,\"leaflet.locatecontrol\":4,\"whatwg-fetch\":6}]},{},[7])\n\n","(function(window) {\n\tvar HAS_HASHCHANGE = (function() {\n\t\tvar doc_mode = window.documentMode;\n\t\treturn ('onhashchange' in window) &&\n\t\t\t(doc_mode === undefined || doc_mode > 7);\n\t})();\n\n\tL.Hash = function(map) {\n\t\tthis.onHashChange = L.Util.bind(this.onHashChange, this);\n\n\t\tif (map) {\n\t\t\tthis.init(map);\n\t\t}\n\t};\n\n\tL.Hash.parseHash = function(hash) {\n\t\tif(hash.indexOf('#') === 0) {\n\t\t\thash = hash.substr(1);\n\t\t}\n\t\tvar args = hash.split(\"/\");\n\t\tif (args.length == 3) {\n\t\t\tvar zoom = parseInt(args[0], 10),\n\t\t\tlat = parseFloat(args[1]),\n\t\t\tlon = parseFloat(args[2]);\n\t\t\tif (isNaN(zoom) || isNaN(lat) || isNaN(lon)) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tcenter: new L.LatLng(lat, lon),\n\t\t\t\t\tzoom: zoom\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tL.Hash.formatHash = function(map) {\n\t\tvar center = map.getCenter(),\n\t\t    zoom = map.getZoom(),\n\t\t    precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));\n\n\t\treturn \"#\" + [zoom,\n\t\t\tcenter.lat.toFixed(precision),\n\t\t\tcenter.lng.toFixed(precision)\n\t\t].join(\"/\");\n\t},\n\n\tL.Hash.prototype = {\n\t\tmap: null,\n\t\tlastHash: null,\n\n\t\tparseHash: L.Hash.parseHash,\n\t\tformatHash: L.Hash.formatHash,\n\n\t\tinit: function(map) {\n\t\t\tthis.map = map;\n\n\t\t\t// reset the hash\n\t\t\tthis.lastHash = null;\n\t\t\tthis.onHashChange();\n\n\t\t\tif (!this.isListening) {\n\t\t\t\tthis.startListening();\n\t\t\t}\n\t\t},\n\n\t\tremoveFrom: function(map) {\n\t\t\tif (this.changeTimeout) {\n\t\t\t\tclearTimeout(this.changeTimeout);\n\t\t\t}\n\n\t\t\tif (this.isListening) {\n\t\t\t\tthis.stopListening();\n\t\t\t}\n\n\t\t\tthis.map = null;\n\t\t},\n\n\t\tonMapMove: function() {\n\t\t\t// bail if we're moving the map (updating from a hash),\n\t\t\t// or if the map is not yet loaded\n\n\t\t\tif (this.movingMap || !this.map._loaded) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar hash = this.formatHash(this.map);\n\t\t\tif (this.lastHash != hash) {\n\t\t\t\tlocation.replace(hash);\n\t\t\t\tthis.lastHash = hash;\n\t\t\t}\n\t\t},\n\n\t\tmovingMap: false,\n\t\tupdate: function() {\n\t\t\tvar hash = location.hash;\n\t\t\tif (hash === this.lastHash) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar parsed = this.parseHash(hash);\n\t\t\tif (parsed) {\n\t\t\t\tthis.movingMap = true;\n\n\t\t\t\tthis.map.setView(parsed.center, parsed.zoom);\n\n\t\t\t\tthis.movingMap = false;\n\t\t\t} else {\n\t\t\t\tthis.onMapMove(this.map);\n\t\t\t}\n\t\t},\n\n\t\t// defer hash change updates every 100ms\n\t\tchangeDefer: 100,\n\t\tchangeTimeout: null,\n\t\tonHashChange: function() {\n\t\t\t// throttle calls to update() so that they only happen every\n\t\t\t// `changeDefer` ms\n\t\t\tif (!this.changeTimeout) {\n\t\t\t\tvar that = this;\n\t\t\t\tthis.changeTimeout = setTimeout(function() {\n\t\t\t\t\tthat.update();\n\t\t\t\t\tthat.changeTimeout = null;\n\t\t\t\t}, this.changeDefer);\n\t\t\t}\n\t\t},\n\n\t\tisListening: false,\n\t\thashChangeInterval: null,\n\t\tstartListening: function() {\n\t\t\tthis.map.on(\"moveend\", this.onMapMove, this);\n\n\t\t\tif (HAS_HASHCHANGE) {\n\t\t\t\tL.DomEvent.addListener(window, \"hashchange\", this.onHashChange);\n\t\t\t} else {\n\t\t\t\tclearInterval(this.hashChangeInterval);\n\t\t\t\tthis.hashChangeInterval = setInterval(this.onHashChange, 50);\n\t\t\t}\n\t\t\tthis.isListening = true;\n\t\t},\n\n\t\tstopListening: function() {\n\t\t\tthis.map.off(\"moveend\", this.onMapMove, this);\n\n\t\t\tif (HAS_HASHCHANGE) {\n\t\t\t\tL.DomEvent.removeListener(window, \"hashchange\", this.onHashChange);\n\t\t\t} else {\n\t\t\t\tclearInterval(this.hashChangeInterval);\n\t\t\t}\n\t\t\tthis.isListening = false;\n\t\t}\n\t};\n\tL.hash = function(map) {\n\t\treturn new L.Hash(map);\n\t};\n\tL.Map.prototype.addHash = function() {\n\t\tthis._hash = L.hash(this);\n\t};\n\tL.Map.prototype.removeHash = function() {\n\t\tthis._hash.removeFrom();\n\t};\n})(window);\n","/*\n Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com\n (c) 2010-2013, Vladimir Agafonkin\n (c) 2010-2011, CloudMade\n*/\n(function (window, document, undefined) {\r\nvar oldL = window.L,\r\n    L = {};\r\n\r\nL.version = '0.7.7';\r\n\r\n// define Leaflet for Node module pattern loaders, including Browserify\r\nif (typeof module === 'object' && typeof module.exports === 'object') {\r\n\tmodule.exports = L;\r\n\r\n// define Leaflet as an AMD module\r\n} else if (typeof define === 'function' && define.amd) {\r\n\tdefine(L);\r\n}\r\n\r\n// define Leaflet as a global L variable, saving the original L to restore later if needed\r\n\r\nL.noConflict = function () {\r\n\twindow.L = oldL;\r\n\treturn this;\r\n};\r\n\r\nwindow.L = L;\r\n\n\n/*\r\n * L.Util contains various utility functions used throughout Leaflet code.\r\n */\r\n\r\nL.Util = {\r\n\textend: function (dest) { // (Object[, Object, ...]) ->\r\n\t\tvar sources = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, j, len, src;\r\n\r\n\t\tfor (j = 0, len = sources.length; j < len; j++) {\r\n\t\t\tsrc = sources[j] || {};\r\n\t\t\tfor (i in src) {\r\n\t\t\t\tif (src.hasOwnProperty(i)) {\r\n\t\t\t\t\tdest[i] = src[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dest;\r\n\t},\r\n\r\n\tbind: function (fn, obj) { // (Function, Object) -> Function\r\n\t\tvar args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;\r\n\t\treturn function () {\r\n\t\t\treturn fn.apply(obj, args || arguments);\r\n\t\t};\r\n\t},\r\n\r\n\tstamp: (function () {\r\n\t\tvar lastId = 0,\r\n\t\t    key = '_leaflet_id';\r\n\t\treturn function (obj) {\r\n\t\t\tobj[key] = obj[key] || ++lastId;\r\n\t\t\treturn obj[key];\r\n\t\t};\r\n\t}()),\r\n\r\n\tinvokeEach: function (obj, method, context) {\r\n\t\tvar i, args;\r\n\r\n\t\tif (typeof obj === 'object') {\r\n\t\t\targs = Array.prototype.slice.call(arguments, 3);\r\n\r\n\t\t\tfor (i in obj) {\r\n\t\t\t\tmethod.apply(context, [i, obj[i]].concat(args));\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\tlimitExecByInterval: function (fn, time, context) {\r\n\t\tvar lock, execOnUnlock;\r\n\r\n\t\treturn function wrapperFn() {\r\n\t\t\tvar args = arguments;\r\n\r\n\t\t\tif (lock) {\r\n\t\t\t\texecOnUnlock = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlock = true;\r\n\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tlock = false;\r\n\r\n\t\t\t\tif (execOnUnlock) {\r\n\t\t\t\t\twrapperFn.apply(context, args);\r\n\t\t\t\t\texecOnUnlock = false;\r\n\t\t\t\t}\r\n\t\t\t}, time);\r\n\r\n\t\t\tfn.apply(context, args);\r\n\t\t};\r\n\t},\r\n\r\n\tfalseFn: function () {\r\n\t\treturn false;\r\n\t},\r\n\r\n\tformatNum: function (num, digits) {\r\n\t\tvar pow = Math.pow(10, digits || 5);\r\n\t\treturn Math.round(num * pow) / pow;\r\n\t},\r\n\r\n\ttrim: function (str) {\r\n\t\treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n\t},\r\n\r\n\tsplitWords: function (str) {\r\n\t\treturn L.Util.trim(str).split(/\\s+/);\r\n\t},\r\n\r\n\tsetOptions: function (obj, options) {\r\n\t\tobj.options = L.extend({}, obj.options, options);\r\n\t\treturn obj.options;\r\n\t},\r\n\r\n\tgetParamString: function (obj, existingUrl, uppercase) {\r\n\t\tvar params = [];\r\n\t\tfor (var i in obj) {\r\n\t\t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n\t\t}\r\n\t\treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n\t},\r\n\ttemplate: function (str, data) {\r\n\t\treturn str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\r\n\t\t\tvar value = data[key];\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tthrow new Error('No value provided for variable ' + str);\r\n\t\t\t} else if (typeof value === 'function') {\r\n\t\t\t\tvalue = value(data);\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t});\r\n\t},\r\n\r\n\tisArray: Array.isArray || function (obj) {\r\n\t\treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n\t},\r\n\r\n\temptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\r\n};\r\n\r\n(function () {\r\n\r\n\t// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n\tfunction getPrefixed(name) {\r\n\t\tvar i, fn,\r\n\t\t    prefixes = ['webkit', 'moz', 'o', 'ms'];\r\n\r\n\t\tfor (i = 0; i < prefixes.length && !fn; i++) {\r\n\t\t\tfn = window[prefixes[i] + name];\r\n\t\t}\r\n\r\n\t\treturn fn;\r\n\t}\r\n\r\n\tvar lastTime = 0;\r\n\r\n\tfunction timeoutDefer(fn) {\r\n\t\tvar time = +new Date(),\r\n\t\t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n\t\tlastTime = time + timeToCall;\r\n\t\treturn window.setTimeout(fn, timeToCall);\r\n\t}\r\n\r\n\tvar requestFn = window.requestAnimationFrame ||\r\n\t        getPrefixed('RequestAnimationFrame') || timeoutDefer;\r\n\r\n\tvar cancelFn = window.cancelAnimationFrame ||\r\n\t        getPrefixed('CancelAnimationFrame') ||\r\n\t        getPrefixed('CancelRequestAnimationFrame') ||\r\n\t        function (id) { window.clearTimeout(id); };\r\n\r\n\r\n\tL.Util.requestAnimFrame = function (fn, context, immediate, element) {\r\n\t\tfn = L.bind(fn, context);\r\n\r\n\t\tif (immediate && requestFn === timeoutDefer) {\r\n\t\t\tfn();\r\n\t\t} else {\r\n\t\t\treturn requestFn.call(window, fn, element);\r\n\t\t}\r\n\t};\r\n\r\n\tL.Util.cancelAnimFrame = function (id) {\r\n\t\tif (id) {\r\n\t\t\tcancelFn.call(window, id);\r\n\t\t}\r\n\t};\r\n\r\n}());\r\n\r\n// shortcuts for most used utility functions\r\nL.extend = L.Util.extend;\r\nL.bind = L.Util.bind;\r\nL.stamp = L.Util.stamp;\r\nL.setOptions = L.Util.setOptions;\r\n\n\n/*\r\n * L.Class powers the OOP facilities of the library.\r\n * Thanks to John Resig and Dean Edwards for inspiration!\r\n */\r\n\r\nL.Class = function () {};\r\n\r\nL.Class.extend = function (props) {\r\n\r\n\t// extended class with the new prototype\r\n\tvar NewClass = function () {\r\n\r\n\t\t// call the constructor\r\n\t\tif (this.initialize) {\r\n\t\t\tthis.initialize.apply(this, arguments);\r\n\t\t}\r\n\r\n\t\t// call all constructor hooks\r\n\t\tif (this._initHooks) {\r\n\t\t\tthis.callInitHooks();\r\n\t\t}\r\n\t};\r\n\r\n\t// instantiate class without calling constructor\r\n\tvar F = function () {};\r\n\tF.prototype = this.prototype;\r\n\r\n\tvar proto = new F();\r\n\tproto.constructor = NewClass;\r\n\r\n\tNewClass.prototype = proto;\r\n\r\n\t//inherit parent's statics\r\n\tfor (var i in this) {\r\n\t\tif (this.hasOwnProperty(i) && i !== 'prototype') {\r\n\t\t\tNewClass[i] = this[i];\r\n\t\t}\r\n\t}\r\n\r\n\t// mix static properties into the class\r\n\tif (props.statics) {\r\n\t\tL.extend(NewClass, props.statics);\r\n\t\tdelete props.statics;\r\n\t}\r\n\r\n\t// mix includes into the prototype\r\n\tif (props.includes) {\r\n\t\tL.Util.extend.apply(null, [proto].concat(props.includes));\r\n\t\tdelete props.includes;\r\n\t}\r\n\r\n\t// merge options\r\n\tif (props.options && proto.options) {\r\n\t\tprops.options = L.extend({}, proto.options, props.options);\r\n\t}\r\n\r\n\t// mix given properties into the prototype\r\n\tL.extend(proto, props);\r\n\r\n\tproto._initHooks = [];\r\n\r\n\tvar parent = this;\r\n\t// jshint camelcase: false\r\n\tNewClass.__super__ = parent.prototype;\r\n\r\n\t// add method for calling all hooks\r\n\tproto.callInitHooks = function () {\r\n\r\n\t\tif (this._initHooksCalled) { return; }\r\n\r\n\t\tif (parent.prototype.callInitHooks) {\r\n\t\t\tparent.prototype.callInitHooks.call(this);\r\n\t\t}\r\n\r\n\t\tthis._initHooksCalled = true;\r\n\r\n\t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n\t\t\tproto._initHooks[i].call(this);\r\n\t\t}\r\n\t};\r\n\r\n\treturn NewClass;\r\n};\r\n\r\n\r\n// method for adding properties to prototype\r\nL.Class.include = function (props) {\r\n\tL.extend(this.prototype, props);\r\n};\r\n\r\n// merge new default options to the Class\r\nL.Class.mergeOptions = function (options) {\r\n\tL.extend(this.prototype.options, options);\r\n};\r\n\r\n// add a constructor hook\r\nL.Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n\tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n\tvar init = typeof fn === 'function' ? fn : function () {\r\n\t\tthis[fn].apply(this, args);\r\n\t};\r\n\r\n\tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n\tthis.prototype._initHooks.push(init);\r\n};\r\n\n\n/*\r\n * L.Mixin.Events is used to add custom events functionality to Leaflet classes.\r\n */\r\n\r\nvar eventsKey = '_leaflet_events';\r\n\r\nL.Mixin = {};\r\n\r\nL.Mixin.Events = {\r\n\r\n\taddEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])\r\n\r\n\t\t// types can be a map of types/handlers\r\n\t\tif (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey] = this[eventsKey] || {},\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, event, type, indexKey, indexLenKey, typeIndex;\r\n\r\n\t\t// types can be a string of space-separated words\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\tevent = {\r\n\t\t\t\taction: fn,\r\n\t\t\t\tcontext: context || this\r\n\t\t\t};\r\n\t\t\ttype = types[i];\r\n\r\n\t\t\tif (contextId) {\r\n\t\t\t\t// store listeners of a particular context in a separate hash (if it has an id)\r\n\t\t\t\t// gives a major performance boost when removing thousands of map layers\r\n\r\n\t\t\t\tindexKey = type + '_idx';\r\n\t\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\t\ttypeIndex = events[indexKey] = events[indexKey] || {};\r\n\r\n\t\t\t\tif (!typeIndex[contextId]) {\r\n\t\t\t\t\ttypeIndex[contextId] = [];\r\n\r\n\t\t\t\t\t// keep track of the number of keys in the index to quickly check if it's empty\r\n\t\t\t\t\tevents[indexLenKey] = (events[indexLenKey] || 0) + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttypeIndex[contextId].push(event);\r\n\r\n\r\n\t\t\t} else {\r\n\t\t\t\tevents[type] = events[type] || [];\r\n\t\t\t\tevents[type].push(event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasEventListeners: function (type) { // (String) -> Boolean\r\n\t\tvar events = this[eventsKey];\r\n\t\treturn !!events && ((type in events && events[type].length > 0) ||\r\n\t\t                    (type + '_idx' in events && events[type + '_idx_len'] > 0));\r\n\t},\r\n\r\n\tremoveEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])\r\n\r\n\t\tif (!this[eventsKey]) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (!types) {\r\n\t\t\treturn this.clearAllEventListeners();\r\n\t\t}\r\n\r\n\t\tif (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;\r\n\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\ttype = types[i];\r\n\t\t\tindexKey = type + '_idx';\r\n\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\ttypeIndex = events[indexKey];\r\n\r\n\t\t\tif (!fn) {\r\n\t\t\t\t// clear all listeners for a type if function isn't specified\r\n\t\t\t\tdelete events[type];\r\n\t\t\t\tdelete events[indexKey];\r\n\t\t\t\tdelete events[indexLenKey];\r\n\r\n\t\t\t} else {\r\n\t\t\t\tlisteners = contextId && typeIndex ? typeIndex[contextId] : events[type];\r\n\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tfor (j = listeners.length - 1; j >= 0; j--) {\r\n\t\t\t\t\t\tif ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {\r\n\t\t\t\t\t\t\tremoved = listeners.splice(j, 1);\r\n\t\t\t\t\t\t\t// set the old action to a no-op, because it is possible\r\n\t\t\t\t\t\t\t// that the listener is being iterated over as part of a dispatch\r\n\t\t\t\t\t\t\tremoved[0].action = L.Util.falseFn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (context && typeIndex && (listeners.length === 0)) {\r\n\t\t\t\t\t\tdelete typeIndex[contextId];\r\n\t\t\t\t\t\tevents[indexLenKey]--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclearAllEventListeners: function () {\r\n\t\tdelete this[eventsKey];\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfireEvent: function (type, data) { // (String[, Object])\r\n\t\tif (!this.hasEventListeners(type)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar event = L.Util.extend({}, data, { type: type, target: this });\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    listeners, i, len, typeIndex, contextId;\r\n\r\n\t\tif (events[type]) {\r\n\t\t\t// make sure adding/removing listeners inside other listeners won't cause infinite loop\r\n\t\t\tlisteners = events[type].slice();\r\n\r\n\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// fire event for the context-indexed listeners as well\r\n\t\ttypeIndex = events[type + '_idx'];\r\n\r\n\t\tfor (contextId in typeIndex) {\r\n\t\t\tlisteners = typeIndex[contextId].slice();\r\n\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOneTimeEventListener: function (types, fn, context) {\r\n\r\n\t\tif (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar handler = L.bind(function () {\r\n\t\t\tthis\r\n\t\t\t    .removeEventListener(types, fn, context)\r\n\t\t\t    .removeEventListener(types, handler, context);\r\n\t\t}, this);\r\n\r\n\t\treturn this\r\n\t\t    .addEventListener(types, fn, context)\r\n\t\t    .addEventListener(types, handler, context);\r\n\t}\r\n};\r\n\r\nL.Mixin.Events.on = L.Mixin.Events.addEventListener;\r\nL.Mixin.Events.off = L.Mixin.Events.removeEventListener;\r\nL.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;\r\nL.Mixin.Events.fire = L.Mixin.Events.fireEvent;\r\n\n\n/*\r\n * L.Browser handles different browser and feature detections for internal Leaflet use.\r\n */\r\n\r\n(function () {\r\n\r\n\tvar ie = 'ActiveXObject' in window,\r\n\t\tielt9 = ie && !document.addEventListener,\r\n\r\n\t    // terrible browser detection to work around Safari / iOS / Android browser bugs\r\n\t    ua = navigator.userAgent.toLowerCase(),\r\n\t    webkit = ua.indexOf('webkit') !== -1,\r\n\t    chrome = ua.indexOf('chrome') !== -1,\r\n\t    phantomjs = ua.indexOf('phantom') !== -1,\r\n\t    android = ua.indexOf('android') !== -1,\r\n\t    android23 = ua.search('android [23]') !== -1,\r\n\t\tgecko = ua.indexOf('gecko') !== -1,\r\n\r\n\t    mobile = typeof orientation !== undefined + '',\r\n\t    msPointer = !window.PointerEvent && window.MSPointerEvent,\r\n\t\tpointer = (window.PointerEvent && window.navigator.pointerEnabled) ||\r\n\t\t\t\t  msPointer,\r\n\t    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||\r\n\t             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&\r\n\t              window.matchMedia('(min-resolution:144dpi)').matches),\r\n\r\n\t    doc = document.documentElement,\r\n\t    ie3d = ie && ('transition' in doc.style),\r\n\t    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,\r\n\t    gecko3d = 'MozPerspective' in doc.style,\r\n\t    opera3d = 'OTransition' in doc.style,\r\n\t    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;\r\n\r\n\tvar touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||\r\n\t\t(window.DocumentTouch && document instanceof window.DocumentTouch));\r\n\r\n\tL.Browser = {\r\n\t\tie: ie,\r\n\t\tielt9: ielt9,\r\n\t\twebkit: webkit,\r\n\t\tgecko: gecko && !webkit && !window.opera && !ie,\r\n\r\n\t\tandroid: android,\r\n\t\tandroid23: android23,\r\n\r\n\t\tchrome: chrome,\r\n\r\n\t\tie3d: ie3d,\r\n\t\twebkit3d: webkit3d,\r\n\t\tgecko3d: gecko3d,\r\n\t\topera3d: opera3d,\r\n\t\tany3d: any3d,\r\n\r\n\t\tmobile: mobile,\r\n\t\tmobileWebkit: mobile && webkit,\r\n\t\tmobileWebkit3d: mobile && webkit3d,\r\n\t\tmobileOpera: mobile && window.opera,\r\n\r\n\t\ttouch: touch,\r\n\t\tmsPointer: msPointer,\r\n\t\tpointer: pointer,\r\n\r\n\t\tretina: retina\r\n\t};\r\n\r\n}());\r\n\n\n/*\r\n * L.Point represents a point with x and y coordinates.\r\n */\r\n\r\nL.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {\r\n\tthis.x = (round ? Math.round(x) : x);\r\n\tthis.y = (round ? Math.round(y) : y);\r\n};\r\n\r\nL.Point.prototype = {\r\n\r\n\tclone: function () {\r\n\t\treturn new L.Point(this.x, this.y);\r\n\t},\r\n\r\n\t// non-destructive, returns a new point\r\n\tadd: function (point) {\r\n\t\treturn this.clone()._add(L.point(point));\r\n\t},\r\n\r\n\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n\t_add: function (point) {\r\n\t\tthis.x += point.x;\r\n\t\tthis.y += point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsubtract: function (point) {\r\n\t\treturn this.clone()._subtract(L.point(point));\r\n\t},\r\n\r\n\t_subtract: function (point) {\r\n\t\tthis.x -= point.x;\r\n\t\tthis.y -= point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdivideBy: function (num) {\r\n\t\treturn this.clone()._divideBy(num);\r\n\t},\r\n\r\n\t_divideBy: function (num) {\r\n\t\tthis.x /= num;\r\n\t\tthis.y /= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tmultiplyBy: function (num) {\r\n\t\treturn this.clone()._multiplyBy(num);\r\n\t},\r\n\r\n\t_multiplyBy: function (num) {\r\n\t\tthis.x *= num;\r\n\t\tthis.y *= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tround: function () {\r\n\t\treturn this.clone()._round();\r\n\t},\r\n\r\n\t_round: function () {\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfloor: function () {\r\n\t\treturn this.clone()._floor();\r\n\t},\r\n\r\n\t_floor: function () {\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdistanceTo: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tvar x = point.x - this.x,\r\n\t\t    y = point.y - this.y;\r\n\r\n\t\treturn Math.sqrt(x * x + y * y);\r\n\t},\r\n\r\n\tequals: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn point.x === this.x &&\r\n\t\t       point.y === this.y;\r\n\t},\r\n\r\n\tcontains: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n\t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn 'Point(' +\r\n\t\t        L.Util.formatNum(this.x) + ', ' +\r\n\t\t        L.Util.formatNum(this.y) + ')';\r\n\t}\r\n};\r\n\r\nL.point = function (x, y, round) {\r\n\tif (x instanceof L.Point) {\r\n\t\treturn x;\r\n\t}\r\n\tif (L.Util.isArray(x)) {\r\n\t\treturn new L.Point(x[0], x[1]);\r\n\t}\r\n\tif (x === undefined || x === null) {\r\n\t\treturn x;\r\n\t}\r\n\treturn new L.Point(x, y, round);\r\n};\r\n\n\n/*\r\n * L.Bounds represents a rectangular area on the screen in pixel coordinates.\r\n */\r\n\r\nL.Bounds = function (a, b) { //(Point, Point) or Point[]\r\n\tif (!a) { return; }\r\n\r\n\tvar points = b ? [a, b] : a;\r\n\r\n\tfor (var i = 0, len = points.length; i < len; i++) {\r\n\t\tthis.extend(points[i]);\r\n\t}\r\n};\r\n\r\nL.Bounds.prototype = {\r\n\t// extend the bounds to contain the given point\r\n\textend: function (point) { // (Point)\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tif (!this.min && !this.max) {\r\n\t\t\tthis.min = point.clone();\r\n\t\t\tthis.max = point.clone();\r\n\t\t} else {\r\n\t\t\tthis.min.x = Math.min(point.x, this.min.x);\r\n\t\t\tthis.max.x = Math.max(point.x, this.max.x);\r\n\t\t\tthis.min.y = Math.min(point.y, this.min.y);\r\n\t\t\tthis.max.y = Math.max(point.y, this.max.y);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetCenter: function (round) { // (Boolean) -> Point\r\n\t\treturn new L.Point(\r\n\t\t        (this.min.x + this.max.x) / 2,\r\n\t\t        (this.min.y + this.max.y) / 2, round);\r\n\t},\r\n\r\n\tgetBottomLeft: function () { // -> Point\r\n\t\treturn new L.Point(this.min.x, this.max.y);\r\n\t},\r\n\r\n\tgetTopRight: function () { // -> Point\r\n\t\treturn new L.Point(this.max.x, this.min.y);\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\treturn this.max.subtract(this.min);\r\n\t},\r\n\r\n\tcontains: function (obj) { // (Bounds) or (Point) -> Boolean\r\n\t\tvar min, max;\r\n\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.Point) {\r\n\t\t\tobj = L.point(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.bounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.Bounds) {\r\n\t\t\tmin = obj.min;\r\n\t\t\tmax = obj.max;\r\n\t\t} else {\r\n\t\t\tmin = max = obj;\r\n\t\t}\r\n\r\n\t\treturn (min.x >= this.min.x) &&\r\n\t\t       (max.x <= this.max.x) &&\r\n\t\t       (min.y >= this.min.y) &&\r\n\t\t       (max.y <= this.max.y);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (Bounds) -> Boolean\r\n\t\tbounds = L.bounds(bounds);\r\n\r\n\t\tvar min = this.min,\r\n\t\t    max = this.max,\r\n\t\t    min2 = bounds.min,\r\n\t\t    max2 = bounds.max,\r\n\t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n\t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n\t\treturn xIntersects && yIntersects;\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this.min && this.max);\r\n\t}\r\n};\r\n\r\nL.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])\r\n\tif (!a || a instanceof L.Bounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.Bounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\r\n */\r\n\r\nL.Transformation = function (a, b, c, d) {\r\n\tthis._a = a;\r\n\tthis._b = b;\r\n\tthis._c = c;\r\n\tthis._d = d;\r\n};\r\n\r\nL.Transformation.prototype = {\r\n\ttransform: function (point, scale) { // (Point, Number) -> Point\r\n\t\treturn this._transform(point.clone(), scale);\r\n\t},\r\n\r\n\t// destructive transform (faster)\r\n\t_transform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\tpoint.x = scale * (this._a * point.x + this._b);\r\n\t\tpoint.y = scale * (this._c * point.y + this._d);\r\n\t\treturn point;\r\n\t},\r\n\r\n\tuntransform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\treturn new L.Point(\r\n\t\t        (point.x / scale - this._b) / this._a,\r\n\t\t        (point.y / scale - this._d) / this._c);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.DomUtil contains various utility functions for working with DOM.\r\n */\r\n\r\nL.DomUtil = {\r\n\tget: function (id) {\r\n\t\treturn (typeof id === 'string' ? document.getElementById(id) : id);\r\n\t},\r\n\r\n\tgetStyle: function (el, style) {\r\n\r\n\t\tvar value = el.style[style];\r\n\r\n\t\tif (!value && el.currentStyle) {\r\n\t\t\tvalue = el.currentStyle[style];\r\n\t\t}\r\n\r\n\t\tif ((!value || value === 'auto') && document.defaultView) {\r\n\t\t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n\t\t\tvalue = css ? css[style] : null;\r\n\t\t}\r\n\r\n\t\treturn value === 'auto' ? null : value;\r\n\t},\r\n\r\n\tgetViewportOffset: function (element) {\r\n\r\n\t\tvar top = 0,\r\n\t\t    left = 0,\r\n\t\t    el = element,\r\n\t\t    docBody = document.body,\r\n\t\t    docEl = document.documentElement,\r\n\t\t    pos;\r\n\r\n\t\tdo {\r\n\t\t\ttop  += el.offsetTop  || 0;\r\n\t\t\tleft += el.offsetLeft || 0;\r\n\r\n\t\t\t//add borders\r\n\t\t\ttop += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;\r\n\t\t\tleft += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;\r\n\r\n\t\t\tpos = L.DomUtil.getStyle(el, 'position');\r\n\r\n\t\t\tif (el.offsetParent === docBody && pos === 'absolute') { break; }\r\n\r\n\t\t\tif (pos === 'fixed') {\r\n\t\t\t\ttop  += docBody.scrollTop  || docEl.scrollTop  || 0;\r\n\t\t\t\tleft += docBody.scrollLeft || docEl.scrollLeft || 0;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (pos === 'relative' && !el.offsetLeft) {\r\n\t\t\t\tvar width = L.DomUtil.getStyle(el, 'width'),\r\n\t\t\t\t    maxWidth = L.DomUtil.getStyle(el, 'max-width'),\r\n\t\t\t\t    r = el.getBoundingClientRect();\r\n\r\n\t\t\t\tif (width !== 'none' || maxWidth !== 'none') {\r\n\t\t\t\t\tleft += r.left + el.clientLeft;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//calculate full y offset since we're breaking out of the loop\r\n\t\t\t\ttop += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tel = el.offsetParent;\r\n\r\n\t\t} while (el);\r\n\r\n\t\tel = element;\r\n\r\n\t\tdo {\r\n\t\t\tif (el === docBody) { break; }\r\n\r\n\t\t\ttop  -= el.scrollTop  || 0;\r\n\t\t\tleft -= el.scrollLeft || 0;\r\n\r\n\t\t\tel = el.parentNode;\r\n\t\t} while (el);\r\n\r\n\t\treturn new L.Point(left, top);\r\n\t},\r\n\r\n\tdocumentIsLtr: function () {\r\n\t\tif (!L.DomUtil._docIsLtrCached) {\r\n\t\t\tL.DomUtil._docIsLtrCached = true;\r\n\t\t\tL.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';\r\n\t\t}\r\n\t\treturn L.DomUtil._docIsLtr;\r\n\t},\r\n\r\n\tcreate: function (tagName, className, container) {\r\n\r\n\t\tvar el = document.createElement(tagName);\r\n\t\tel.className = className;\r\n\r\n\t\tif (container) {\r\n\t\t\tcontainer.appendChild(el);\r\n\t\t}\r\n\r\n\t\treturn el;\r\n\t},\r\n\r\n\thasClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\treturn el.classList.contains(name);\r\n\t\t}\r\n\t\tvar className = L.DomUtil._getClass(el);\r\n\t\treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n\t},\r\n\r\n\taddClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tvar classes = L.Util.splitWords(name);\r\n\t\t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n\t\t\t\tel.classList.add(classes[i]);\r\n\t\t\t}\r\n\t\t} else if (!L.DomUtil.hasClass(el, name)) {\r\n\t\t\tvar className = L.DomUtil._getClass(el);\r\n\t\t\tL.DomUtil._setClass(el, (className ? className + ' ' : '') + name);\r\n\t\t}\r\n\t},\r\n\r\n\tremoveClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tel.classList.remove(name);\r\n\t\t} else {\r\n\t\t\tL.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n\t\t}\r\n\t},\r\n\r\n\t_setClass: function (el, name) {\r\n\t\tif (el.className.baseVal === undefined) {\r\n\t\t\tel.className = name;\r\n\t\t} else {\r\n\t\t\t// in case of SVG element\r\n\t\t\tel.className.baseVal = name;\r\n\t\t}\r\n\t},\r\n\r\n\t_getClass: function (el) {\r\n\t\treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n\t},\r\n\r\n\tsetOpacity: function (el, value) {\r\n\r\n\t\tif ('opacity' in el.style) {\r\n\t\t\tel.style.opacity = value;\r\n\r\n\t\t} else if ('filter' in el.style) {\r\n\r\n\t\t\tvar filter = false,\r\n\t\t\t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n\t\t\t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n\t\t\ttry {\r\n\t\t\t\tfilter = el.filters.item(filterName);\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n\t\t\t\t// it isn't needed and breaks transparent pngs.\r\n\t\t\t\tif (value === 1) { return; }\r\n\t\t\t}\r\n\r\n\t\t\tvalue = Math.round(value * 100);\r\n\r\n\t\t\tif (filter) {\r\n\t\t\t\tfilter.Enabled = (value !== 100);\r\n\t\t\t\tfilter.Opacity = value;\r\n\t\t\t} else {\r\n\t\t\t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\ttestProp: function (props) {\r\n\r\n\t\tvar style = document.documentElement.style;\r\n\r\n\t\tfor (var i = 0; i < props.length; i++) {\r\n\t\t\tif (props[i] in style) {\r\n\t\t\t\treturn props[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tgetTranslateString: function (point) {\r\n\t\t// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate\r\n\t\t// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care\r\n\t\t// (same speed either way), Opera 12 doesn't support translate3d\r\n\r\n\t\tvar is3d = L.Browser.webkit3d,\r\n\t\t    open = 'translate' + (is3d ? '3d' : '') + '(',\r\n\t\t    close = (is3d ? ',0' : '') + ')';\r\n\r\n\t\treturn open + point.x + 'px,' + point.y + 'px' + close;\r\n\t},\r\n\r\n\tgetScaleString: function (scale, origin) {\r\n\r\n\t\tvar preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),\r\n\t\t    scaleStr = ' scale(' + scale + ') ';\r\n\r\n\t\treturn preTranslateStr + scaleStr;\r\n\t},\r\n\r\n\tsetPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])\r\n\r\n\t\t// jshint camelcase: false\r\n\t\tel._leaflet_pos = point;\r\n\r\n\t\tif (!disable3D && L.Browser.any3d) {\r\n\t\t\tel.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);\r\n\t\t} else {\r\n\t\t\tel.style.left = point.x + 'px';\r\n\t\t\tel.style.top = point.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\tgetPosition: function (el) {\r\n\t\t// this method is only used for elements previously positioned using setPosition,\r\n\t\t// so it's safe to cache the position for performance\r\n\r\n\t\t// jshint camelcase: false\r\n\t\treturn el._leaflet_pos;\r\n\t}\r\n};\r\n\r\n\r\n// prefix style property names\r\n\r\nL.DomUtil.TRANSFORM = L.DomUtil.testProp(\r\n        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n// webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n// the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\nL.DomUtil.TRANSITION = L.DomUtil.testProp(\r\n        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\nL.DomUtil.TRANSITION_END =\r\n        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?\r\n        L.DomUtil.TRANSITION + 'End' : 'transitionend';\r\n\r\n(function () {\r\n    if ('onselectstart' in document) {\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\r\n            }\r\n        });\r\n    } else {\r\n        var userSelectProperty = L.DomUtil.testProp(\r\n            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    var style = document.documentElement.style;\r\n                    this._userSelect = style[userSelectProperty];\r\n                    style[userSelectProperty] = 'none';\r\n                }\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    document.documentElement.style[userSelectProperty] = this._userSelect;\r\n                    delete this._userSelect;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\tL.extend(L.DomUtil, {\r\n\t\tdisableImageDrag: function () {\r\n\t\t\tL.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t},\r\n\r\n\t\tenableImageDrag: function () {\r\n\t\t\tL.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t}\r\n\t});\r\n})();\r\n\n\n/*\r\n * L.LatLng represents a geographical point with latitude and longitude coordinates.\r\n */\r\n\r\nL.LatLng = function (lat, lng, alt) { // (Number, Number, Number)\r\n\tlat = parseFloat(lat);\r\n\tlng = parseFloat(lng);\r\n\r\n\tif (isNaN(lat) || isNaN(lng)) {\r\n\t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n\t}\r\n\r\n\tthis.lat = lat;\r\n\tthis.lng = lng;\r\n\r\n\tif (alt !== undefined) {\r\n\t\tthis.alt = parseFloat(alt);\r\n\t}\r\n};\r\n\r\nL.extend(L.LatLng, {\r\n\tDEG_TO_RAD: Math.PI / 180,\r\n\tRAD_TO_DEG: 180 / Math.PI,\r\n\tMAX_MARGIN: 1.0E-9 // max margin of error for the \"equals\" check\r\n});\r\n\r\nL.LatLng.prototype = {\r\n\tequals: function (obj) { // (LatLng) -> Boolean\r\n\t\tif (!obj) { return false; }\r\n\r\n\t\tobj = L.latLng(obj);\r\n\r\n\t\tvar margin = Math.max(\r\n\t\t        Math.abs(this.lat - obj.lat),\r\n\t\t        Math.abs(this.lng - obj.lng));\r\n\r\n\t\treturn margin <= L.LatLng.MAX_MARGIN;\r\n\t},\r\n\r\n\ttoString: function (precision) { // (Number) -> String\r\n\t\treturn 'LatLng(' +\r\n\t\t        L.Util.formatNum(this.lat, precision) + ', ' +\r\n\t\t        L.Util.formatNum(this.lng, precision) + ')';\r\n\t},\r\n\r\n\t// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula\r\n\t// TODO move to projection code, LatLng shouldn't know about Earth\r\n\tdistanceTo: function (other) { // (LatLng) -> Number\r\n\t\tother = L.latLng(other);\r\n\r\n\t\tvar R = 6378137, // earth radius in meters\r\n\t\t    d2r = L.LatLng.DEG_TO_RAD,\r\n\t\t    dLat = (other.lat - this.lat) * d2r,\r\n\t\t    dLon = (other.lng - this.lng) * d2r,\r\n\t\t    lat1 = this.lat * d2r,\r\n\t\t    lat2 = other.lat * d2r,\r\n\t\t    sin1 = Math.sin(dLat / 2),\r\n\t\t    sin2 = Math.sin(dLon / 2);\r\n\r\n\t\tvar a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);\r\n\r\n\t\treturn R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\t},\r\n\r\n\twrap: function (a, b) { // (Number, Number) -> LatLng\r\n\t\tvar lng = this.lng;\r\n\r\n\t\ta = a || -180;\r\n\t\tb = b ||  180;\r\n\r\n\t\tlng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);\r\n\r\n\t\treturn new L.LatLng(this.lat, lng);\r\n\t}\r\n};\r\n\r\nL.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)\r\n\tif (a instanceof L.LatLng) {\r\n\t\treturn a;\r\n\t}\r\n\tif (L.Util.isArray(a)) {\r\n\t\tif (typeof a[0] === 'number' || typeof a[0] === 'string') {\r\n\t\t\treturn new L.LatLng(a[0], a[1], a[2]);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\tif (a === undefined || a === null) {\r\n\t\treturn a;\r\n\t}\r\n\tif (typeof a === 'object' && 'lat' in a) {\r\n\t\treturn new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);\r\n\t}\r\n\tif (b === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\treturn new L.LatLng(a, b);\r\n};\r\n\r\n\n\n/*\r\n * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\r\n */\r\n\r\nL.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])\r\n\tif (!southWest) { return; }\r\n\r\n\tvar latlngs = northEast ? [southWest, northEast] : southWest;\r\n\r\n\tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n\t\tthis.extend(latlngs[i]);\r\n\t}\r\n};\r\n\r\nL.LatLngBounds.prototype = {\r\n\t// extend the bounds to contain the given point or bounds\r\n\textend: function (obj) { // (LatLng) or (LatLngBounds)\r\n\t\tif (!obj) { return this; }\r\n\r\n\t\tvar latLng = L.latLng(obj);\r\n\t\tif (latLng !== null) {\r\n\t\t\tobj = latLng;\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.LatLng) {\r\n\t\t\tif (!this._southWest && !this._northEast) {\r\n\t\t\t\tthis._southWest = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t\tthis._northEast = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t} else {\r\n\t\t\t\tthis._southWest.lat = Math.min(obj.lat, this._southWest.lat);\r\n\t\t\t\tthis._southWest.lng = Math.min(obj.lng, this._southWest.lng);\r\n\r\n\t\t\t\tthis._northEast.lat = Math.max(obj.lat, this._northEast.lat);\r\n\t\t\t\tthis._northEast.lng = Math.max(obj.lng, this._northEast.lng);\r\n\t\t\t}\r\n\t\t} else if (obj instanceof L.LatLngBounds) {\r\n\t\t\tthis.extend(obj._southWest);\r\n\t\t\tthis.extend(obj._northEast);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// extend the bounds by a percentage\r\n\tpad: function (bufferRatio) { // (Number) -> LatLngBounds\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n\t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n\t\t        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n\t},\r\n\r\n\tgetCenter: function () { // -> LatLng\r\n\t\treturn new L.LatLng(\r\n\t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n\t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n\t},\r\n\r\n\tgetSouthWest: function () {\r\n\t\treturn this._southWest;\r\n\t},\r\n\r\n\tgetNorthEast: function () {\r\n\t\treturn this._northEast;\r\n\t},\r\n\r\n\tgetNorthWest: function () {\r\n\t\treturn new L.LatLng(this.getNorth(), this.getWest());\r\n\t},\r\n\r\n\tgetSouthEast: function () {\r\n\t\treturn new L.LatLng(this.getSouth(), this.getEast());\r\n\t},\r\n\r\n\tgetWest: function () {\r\n\t\treturn this._southWest.lng;\r\n\t},\r\n\r\n\tgetSouth: function () {\r\n\t\treturn this._southWest.lat;\r\n\t},\r\n\r\n\tgetEast: function () {\r\n\t\treturn this._northEast.lng;\r\n\t},\r\n\r\n\tgetNorth: function () {\r\n\t\treturn this._northEast.lat;\r\n\t},\r\n\r\n\tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\r\n\t\t\tobj = L.latLng(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2, ne2;\r\n\r\n\t\tif (obj instanceof L.LatLngBounds) {\r\n\t\t\tsw2 = obj.getSouthWest();\r\n\t\t\tne2 = obj.getNorthEast();\r\n\t\t} else {\r\n\t\t\tsw2 = ne2 = obj;\r\n\t\t}\r\n\r\n\t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n\t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (LatLngBounds)\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2 = bounds.getSouthWest(),\r\n\t\t    ne2 = bounds.getNorthEast(),\r\n\r\n\t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n\t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n\t\treturn latIntersects && lngIntersects;\r\n\t},\r\n\r\n\ttoBBoxString: function () {\r\n\t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n\t},\r\n\r\n\tequals: function (bounds) { // (LatLngBounds)\r\n\t\tif (!bounds) { return false; }\r\n\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\treturn this._southWest.equals(bounds.getSouthWest()) &&\r\n\t\t       this._northEast.equals(bounds.getNorthEast());\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this._southWest && this._northEast);\r\n\t}\r\n};\r\n\r\n//TODO International date line?\r\n\r\nL.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)\r\n\tif (!a || a instanceof L.LatLngBounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.LatLngBounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Projection contains various geographical projections used by CRS classes.\r\n */\r\n\r\nL.Projection = {};\r\n\n\n/*\r\n * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\r\n */\r\n\r\nL.Projection.SphericalMercator = {\r\n\tMAX_LATITUDE: 85.0511287798,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    x = latlng.lng * d,\r\n\t\t    y = lat * d;\r\n\r\n\t\ty = Math.log(Math.tan((Math.PI / 4) + (y / 2)));\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    lng = point.x * d,\r\n\t\t    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;\r\n\r\n\t\treturn new L.LatLng(lat, lng);\r\n\t}\r\n};\r\n\n\n/*\r\n * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\r\n */\r\n\r\nL.Projection.LonLat = {\r\n\tproject: function (latlng) {\r\n\t\treturn new L.Point(latlng.lng, latlng.lat);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\treturn new L.LatLng(point.y, point.x);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\r\n */\r\n\r\nL.CRS = {\r\n\tlatLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    scale = this.scale(zoom);\r\n\r\n\t\treturn this.transformation._transform(projectedPoint, scale);\r\n\t},\r\n\r\n\tpointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng\r\n\t\tvar scale = this.scale(zoom),\r\n\t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n\t\treturn this.projection.unproject(untransformedPoint);\r\n\t},\r\n\r\n\tproject: function (latlng) {\r\n\t\treturn this.projection.project(latlng);\r\n\t},\r\n\r\n\tscale: function (zoom) {\r\n\t\treturn 256 * Math.pow(2, zoom);\r\n\t},\r\n\r\n\tgetSize: function (zoom) {\r\n\t\tvar s = this.scale(zoom);\r\n\t\treturn L.point(s, s);\r\n\t}\r\n};\r\n\n\n/*\n * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n */\n\nL.CRS.Simple = L.extend({}, L.CRS, {\n\tprojection: L.Projection.LonLat,\n\ttransformation: new L.Transformation(1, 0, -1, 0),\n\n\tscale: function (zoom) {\n\t\treturn Math.pow(2, zoom);\n\t}\n});\n\n\n/*\r\n * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping\r\n * and is used by Leaflet by default.\r\n */\r\n\r\nL.CRS.EPSG3857 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3857',\r\n\r\n\tprojection: L.Projection.SphericalMercator,\r\n\ttransformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    earthRadius = 6378137;\r\n\t\treturn projectedPoint.multiplyBy(earthRadius);\r\n\t}\r\n});\r\n\r\nL.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\r\n\tcode: 'EPSG:900913'\r\n});\r\n\n\n/*\r\n * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\r\n */\r\n\r\nL.CRS.EPSG4326 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:4326',\r\n\r\n\tprojection: L.Projection.LonLat,\r\n\ttransformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)\r\n});\r\n\n\n/*\r\n * L.Map is the central class of the API - it is used to create a map.\r\n */\r\n\r\nL.Map = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tcrs: L.CRS.EPSG3857,\r\n\r\n\t\t/*\r\n\t\tcenter: LatLng,\r\n\t\tzoom: Number,\r\n\t\tlayers: Array,\r\n\t\t*/\r\n\r\n\t\tfadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,\r\n\t\ttrackResize: true,\r\n\t\tmarkerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d\r\n\t},\r\n\r\n\tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\r\n\t\tthis._initContainer(id);\r\n\t\tthis._initLayout();\r\n\r\n\t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n\t\tthis._onResize = L.bind(this._onResize, this);\r\n\r\n\t\tthis._initEvents();\r\n\r\n\t\tif (options.maxBounds) {\r\n\t\t\tthis.setMaxBounds(options.maxBounds);\r\n\t\t}\r\n\r\n\t\tif (options.center && options.zoom !== undefined) {\r\n\t\t\tthis.setView(L.latLng(options.center), options.zoom, {reset: true});\r\n\t\t}\r\n\r\n\t\tthis._handlers = [];\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._zoomBoundLayers = {};\r\n\t\tthis._tileLayersNum = 0;\r\n\r\n\t\tthis.callInitHooks();\r\n\r\n\t\tthis._addLayers(options.layers);\r\n\t},\r\n\r\n\r\n\t// public methods that modify map state\r\n\r\n\t// replaced by animation-powered implementation in Map.PanAnimation.js\r\n\tsetView: function (center, zoom) {\r\n\t\tzoom = zoom === undefined ? this.getZoom() : zoom;\r\n\t\tthis._resetView(L.latLng(center), this._limitZoom(zoom));\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZoom: function (zoom, options) {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthis._zoom = this._limitZoom(zoom);\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n\t},\r\n\r\n\tzoomIn: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom + (delta || 1), options);\r\n\t},\r\n\r\n\tzoomOut: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom - (delta || 1), options);\r\n\t},\r\n\r\n\tsetZoomAround: function (latlng, zoom, options) {\r\n\t\tvar scale = this.getZoomScale(zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n\t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n\t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n\t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n\t},\r\n\r\n\tfitBounds: function (bounds, options) {\r\n\r\n\t\toptions = options || {};\r\n\t\tbounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\r\n\r\n\t\tvar paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n\t\t    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n\t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\r\n\t\tzoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n\t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n\t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n\t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n\t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n\t\treturn this.setView(center, zoom, options);\r\n\t},\r\n\r\n\tfitWorld: function (options) {\r\n\t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n\t},\r\n\r\n\tpanTo: function (center, options) { // (LatLng)\r\n\t\treturn this.setView(center, this._zoom, {pan: options});\r\n\t},\r\n\r\n\tpanBy: function (offset) { // (Point)\r\n\t\t// replaced with animated panBy in Map.PanAnimation.js\r\n\t\tthis.fire('movestart');\r\n\r\n\t\tthis._rawPanBy(L.point(offset));\r\n\r\n\t\tthis.fire('move');\r\n\t\treturn this.fire('moveend');\r\n\t},\r\n\r\n\tsetMaxBounds: function (bounds) {\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tthis.options.maxBounds = bounds;\r\n\r\n\t\tif (!bounds) {\r\n\t\t\treturn this.off('moveend', this._panInsideMaxBounds, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._panInsideMaxBounds();\r\n\t\t}\r\n\r\n\t\treturn this.on('moveend', this._panInsideMaxBounds, this);\r\n\t},\r\n\r\n\tpanInsideBounds: function (bounds, options) {\r\n\t\tvar center = this.getCenter(),\r\n\t\t\tnewCenter = this._limitCenter(center, this._zoom, bounds);\r\n\r\n\t\tif (center.equals(newCenter)) { return this; }\r\n\r\n\t\treturn this.panTo(newCenter, options);\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\t// TODO method is too big, refactor\r\n\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (this._layers[id]) { return this; }\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\t// TODO getMaxZoom, getMinZoom in ILayer (instead of options)\r\n\t\tif (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {\r\n\t\t\tthis._zoomBoundLayers[id] = layer;\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor!!!\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum++;\r\n\t\t\tthis._tileLayersToLoad++;\r\n\t\t\tlayer.on('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._layerAdd(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (!this._layers[id]) { return this; }\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tlayer.onRemove(this);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('layerremove', {layer: layer});\r\n\t\t}\r\n\r\n\t\tif (this._zoomBoundLayers[id]) {\r\n\t\t\tdelete this._zoomBoundLayers[id];\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum--;\r\n\t\t\tthis._tileLayersToLoad--;\r\n\t\t\tlayer.off('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (L.stamp(layer) in this._layers);\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvalidateSize: function (options) {\r\n\t\tif (!this._loaded) { return this; }\r\n\r\n\t\toptions = L.extend({\r\n\t\t\tanimate: false,\r\n\t\t\tpan: true\r\n\t\t}, options === true ? {animate: true} : options);\r\n\r\n\t\tvar oldSize = this.getSize();\r\n\t\tthis._sizeChanged = true;\r\n\t\tthis._initialCenter = null;\r\n\r\n\t\tvar newSize = this.getSize(),\r\n\t\t    oldCenter = oldSize.divideBy(2).round(),\r\n\t\t    newCenter = newSize.divideBy(2).round(),\r\n\t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n\t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n\t\tif (options.animate && options.pan) {\r\n\t\t\tthis.panBy(offset);\r\n\r\n\t\t} else {\r\n\t\t\tif (options.pan) {\r\n\t\t\t\tthis._rawPanBy(offset);\r\n\t\t\t}\r\n\r\n\t\t\tthis.fire('move');\r\n\r\n\t\t\tif (options.debounceMoveend) {\r\n\t\t\t\tclearTimeout(this._sizeTimer);\r\n\t\t\t\tthis._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\r\n\t\t\t} else {\r\n\t\t\t\tthis.fire('moveend');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.fire('resize', {\r\n\t\t\toldSize: oldSize,\r\n\t\t\tnewSize: newSize\r\n\t\t});\r\n\t},\r\n\r\n\t// TODO handler.addTo\r\n\taddHandler: function (name, HandlerClass) {\r\n\t\tif (!HandlerClass) { return this; }\r\n\r\n\t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n\t\tthis._handlers.push(handler);\r\n\r\n\t\tif (this.options[name]) {\r\n\t\t\thandler.enable();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremove: function () {\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('unload');\r\n\t\t}\r\n\r\n\t\tthis._initEvents('off');\r\n\r\n\t\ttry {\r\n\t\t\t// throws error in IE6-8\r\n\t\t\tdelete this._container._leaflet;\r\n\t\t} catch (e) {\r\n\t\t\tthis._container._leaflet = undefined;\r\n\t\t}\r\n\r\n\t\tthis._clearPanes();\r\n\t\tif (this._clearControlPos) {\r\n\t\t\tthis._clearControlPos();\r\n\t\t}\r\n\r\n\t\tthis._clearHandlers();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\r\n\t// public methods for getting map state\r\n\r\n\tgetCenter: function () { // (Boolean) -> LatLng\r\n\t\tthis._checkIfLoaded();\r\n\r\n\t\tif (this._initialCenter && !this._moved()) {\r\n\t\t\treturn this._initialCenter;\r\n\t\t}\r\n\t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\tgetZoom: function () {\r\n\t\treturn this._zoom;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = this.getPixelBounds(),\r\n\t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n\t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n\t\treturn new L.LatLngBounds(sw, ne);\r\n\t},\r\n\r\n\tgetMinZoom: function () {\r\n\t\treturn this.options.minZoom === undefined ?\r\n\t\t\t(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :\r\n\t\t\tthis.options.minZoom;\r\n\t},\r\n\r\n\tgetMaxZoom: function () {\r\n\t\treturn this.options.maxZoom === undefined ?\r\n\t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n\t\t\tthis.options.maxZoom;\r\n\t},\r\n\r\n\tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar zoom = this.getMinZoom() - (inside ? 1 : 0),\r\n\t\t    maxZoom = this.getMaxZoom(),\r\n\t\t    size = this.getSize(),\r\n\r\n\t\t    nw = bounds.getNorthWest(),\r\n\t\t    se = bounds.getSouthEast(),\r\n\r\n\t\t    zoomNotFound = true,\r\n\t\t    boundsSize;\r\n\r\n\t\tpadding = L.point(padding || [0, 0]);\r\n\r\n\t\tdo {\r\n\t\t\tzoom++;\r\n\t\t\tboundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);\r\n\t\t\tzoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\r\n\r\n\t\t} while (zoomNotFound && zoom <= maxZoom);\r\n\r\n\t\tif (zoomNotFound && inside) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn inside ? zoom : zoom - 1;\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\tif (!this._size || this._sizeChanged) {\r\n\t\t\tthis._size = new L.Point(\r\n\t\t\t\tthis._container.clientWidth,\r\n\t\t\t\tthis._container.clientHeight);\r\n\r\n\t\t\tthis._sizeChanged = false;\r\n\t\t}\r\n\t\treturn this._size.clone();\r\n\t},\r\n\r\n\tgetPixelBounds: function () {\r\n\t\tvar topLeftPoint = this._getTopLeftPoint();\r\n\t\treturn new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n\t},\r\n\r\n\tgetPixelOrigin: function () {\r\n\t\tthis._checkIfLoaded();\r\n\t\treturn this._initialTopLeftPoint;\r\n\t},\r\n\r\n\tgetPanes: function () {\r\n\t\treturn this._panes;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\r\n\t// TODO replace with universal implementation after refactoring projections\r\n\r\n\tgetZoomScale: function (toZoom) {\r\n\t\tvar crs = this.options.crs;\r\n\t\treturn crs.scale(toZoom) / crs.scale(this._zoom);\r\n\t},\r\n\r\n\tgetScaleZoom: function (scale) {\r\n\t\treturn this._zoom + (Math.log(scale) / Math.LN2);\r\n\t},\r\n\r\n\r\n\t// conversion methods\r\n\r\n\tproject: function (latlng, zoom) { // (LatLng[, Number]) -> Point\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\r\n\t},\r\n\r\n\tunproject: function (point, zoom) { // (Point[, Number]) -> LatLng\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.pointToLatLng(L.point(point), zoom);\r\n\t},\r\n\r\n\tlayerPointToLatLng: function (point) { // (Point)\r\n\t\tvar projectedPoint = L.point(point).add(this.getPixelOrigin());\r\n\t\treturn this.unproject(projectedPoint);\r\n\t},\r\n\r\n\tlatLngToLayerPoint: function (latlng) { // (LatLng)\r\n\t\tvar projectedPoint = this.project(L.latLng(latlng))._round();\r\n\t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n\t},\r\n\r\n\tcontainerPointToLayerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\tlayerPointToContainerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).add(this._getMapPanePos());\r\n\t},\r\n\r\n\tcontainerPointToLatLng: function (point) {\r\n\t\tvar layerPoint = this.containerPointToLayerPoint(L.point(point));\r\n\t\treturn this.layerPointToLatLng(layerPoint);\r\n\t},\r\n\r\n\tlatLngToContainerPoint: function (latlng) {\r\n\t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\r\n\t},\r\n\r\n\tmouseEventToContainerPoint: function (e) { // (MouseEvent)\r\n\t\treturn L.DomEvent.getMousePosition(e, this._container);\r\n\t},\r\n\r\n\tmouseEventToLayerPoint: function (e) { // (MouseEvent)\r\n\t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n\t},\r\n\r\n\tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n\t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n\t},\r\n\r\n\r\n\t// map initialization methods\r\n\r\n\t_initContainer: function (id) {\r\n\t\tvar container = this._container = L.DomUtil.get(id);\r\n\r\n\t\tif (!container) {\r\n\t\t\tthrow new Error('Map container not found.');\r\n\t\t} else if (container._leaflet) {\r\n\t\t\tthrow new Error('Map container is already initialized.');\r\n\t\t}\r\n\r\n\t\tcontainer._leaflet = true;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar container = this._container;\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-container' +\r\n\t\t\t(L.Browser.touch ? ' leaflet-touch' : '') +\r\n\t\t\t(L.Browser.retina ? ' leaflet-retina' : '') +\r\n\t\t\t(L.Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n\t\t\t(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));\r\n\r\n\t\tvar position = L.DomUtil.getStyle(container, 'position');\r\n\r\n\t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n\t\t\tcontainer.style.position = 'relative';\r\n\t\t}\r\n\r\n\t\tthis._initPanes();\r\n\r\n\t\tif (this._initControlPos) {\r\n\t\t\tthis._initControlPos();\r\n\t\t}\r\n\t},\r\n\r\n\t_initPanes: function () {\r\n\t\tvar panes = this._panes = {};\r\n\r\n\t\tthis._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);\r\n\r\n\t\tthis._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);\r\n\t\tpanes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);\r\n\t\tpanes.shadowPane = this._createPane('leaflet-shadow-pane');\r\n\t\tpanes.overlayPane = this._createPane('leaflet-overlay-pane');\r\n\t\tpanes.markerPane = this._createPane('leaflet-marker-pane');\r\n\t\tpanes.popupPane = this._createPane('leaflet-popup-pane');\r\n\r\n\t\tvar zoomHide = ' leaflet-zoom-hide';\r\n\r\n\t\tif (!this.options.markerZoomAnimation) {\r\n\t\t\tL.DomUtil.addClass(panes.markerPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.shadowPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.popupPane, zoomHide);\r\n\t\t}\r\n\t},\r\n\r\n\t_createPane: function (className, container) {\r\n\t\treturn L.DomUtil.create('div', className, container || this._panes.objectsPane);\r\n\t},\r\n\r\n\t_clearPanes: function () {\r\n\t\tthis._container.removeChild(this._mapPane);\r\n\t},\r\n\r\n\t_addLayers: function (layers) {\r\n\t\tlayers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];\r\n\r\n\t\tfor (var i = 0, len = layers.length; i < len; i++) {\r\n\t\t\tthis.addLayer(layers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// private methods that modify map state\r\n\r\n\t_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {\r\n\r\n\t\tvar zoomChanged = (this._zoom !== zoom);\r\n\r\n\t\tif (!afterZoomAnim) {\r\n\t\t\tthis.fire('movestart');\r\n\r\n\t\t\tif (zoomChanged) {\r\n\t\t\t\tthis.fire('zoomstart');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._zoom = zoom;\r\n\t\tthis._initialCenter = center;\r\n\r\n\t\tthis._initialTopLeftPoint = this._getNewTopLeftPoint(center);\r\n\r\n\t\tif (!preserveMapOffset) {\r\n\t\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\t\t} else {\r\n\t\t\tthis._initialTopLeftPoint._add(this._getMapPanePos());\r\n\t\t}\r\n\r\n\t\tthis._tileLayersToLoad = this._tileLayersNum;\r\n\r\n\t\tvar loading = !this._loaded;\r\n\t\tthis._loaded = true;\r\n\r\n\t\tthis.fire('viewreset', {hard: !preserveMapOffset});\r\n\r\n\t\tif (loading) {\r\n\t\t\tthis.fire('load');\r\n\t\t\tthis.eachLayer(this._layerAdd, this);\r\n\t\t}\r\n\r\n\t\tthis.fire('move');\r\n\r\n\t\tif (zoomChanged || afterZoomAnim) {\r\n\t\t\tthis.fire('zoomend');\r\n\t\t}\r\n\r\n\t\tthis.fire('moveend', {hard: !preserveMapOffset});\r\n\t},\r\n\r\n\t_rawPanBy: function (offset) {\r\n\t\tL.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n\t},\r\n\r\n\t_getZoomSpan: function () {\r\n\t\treturn this.getMaxZoom() - this.getMinZoom();\r\n\t},\r\n\r\n\t_updateZoomLevels: function () {\r\n\t\tvar i,\r\n\t\t\tminZoom = Infinity,\r\n\t\t\tmaxZoom = -Infinity,\r\n\t\t\toldZoomSpan = this._getZoomSpan();\r\n\r\n\t\tfor (i in this._zoomBoundLayers) {\r\n\t\t\tvar layer = this._zoomBoundLayers[i];\r\n\t\t\tif (!isNaN(layer.options.minZoom)) {\r\n\t\t\t\tminZoom = Math.min(minZoom, layer.options.minZoom);\r\n\t\t\t}\r\n\t\t\tif (!isNaN(layer.options.maxZoom)) {\r\n\t\t\t\tmaxZoom = Math.max(maxZoom, layer.options.maxZoom);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (i === undefined) { // we have no tilelayers\r\n\t\t\tthis._layersMaxZoom = this._layersMinZoom = undefined;\r\n\t\t} else {\r\n\t\t\tthis._layersMaxZoom = maxZoom;\r\n\t\t\tthis._layersMinZoom = minZoom;\r\n\t\t}\r\n\r\n\t\tif (oldZoomSpan !== this._getZoomSpan()) {\r\n\t\t\tthis.fire('zoomlevelschange');\r\n\t\t}\r\n\t},\r\n\r\n\t_panInsideMaxBounds: function () {\r\n\t\tthis.panInsideBounds(this.options.maxBounds);\r\n\t},\r\n\r\n\t_checkIfLoaded: function () {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthrow new Error('Set map center and zoom first.');\r\n\t\t}\r\n\t},\r\n\r\n\t// map events\r\n\r\n\t_initEvents: function (onOff) {\r\n\t\tif (!L.DomEvent) { return; }\r\n\r\n\t\tonOff = onOff || 'on';\r\n\r\n\t\tL.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\tvar events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',\r\n\t\t              'mouseleave', 'mousemove', 'contextmenu'],\r\n\t\t    i, len;\r\n\r\n\t\tfor (i = 0, len = events.length; i < len; i++) {\r\n\t\t\tL.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (this.options.trackResize) {\r\n\t\t\tL.DomEvent[onOff](window, 'resize', this._onResize, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onResize: function () {\r\n\t\tL.Util.cancelAnimFrame(this._resizeRequest);\r\n\t\tthis._resizeRequest = L.Util.requestAnimFrame(\r\n\t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (!this._loaded || (!e._simulated &&\r\n\t\t        ((this.dragging && this.dragging.moved()) ||\r\n\t\t         (this.boxZoom  && this.boxZoom.moved()))) ||\r\n\t\t            L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tthis.fire('preclick');\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._loaded || L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tvar type = e.type;\r\n\r\n\t\ttype = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));\r\n\r\n\t\tif (!this.hasEventListeners(type)) { return; }\r\n\r\n\t\tif (type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\r\n\t\tvar containerPoint = this.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = this.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = this.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\t},\r\n\r\n\t_onTileLayerLoad: function () {\r\n\t\tthis._tileLayersToLoad--;\r\n\t\tif (this._tileLayersNum && !this._tileLayersToLoad) {\r\n\t\t\tthis.fire('tilelayersload');\r\n\t\t}\r\n\t},\r\n\r\n\t_clearHandlers: function () {\r\n\t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n\t\t\tthis._handlers[i].disable();\r\n\t\t}\r\n\t},\r\n\r\n\twhenReady: function (callback, context) {\r\n\t\tif (this._loaded) {\r\n\t\t\tcallback.call(context || this, this);\r\n\t\t} else {\r\n\t\t\tthis.on('load', callback, context);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_layerAdd: function (layer) {\r\n\t\tlayer.onAdd(this);\r\n\t\tthis.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\r\n\t// private methods for getting map state\r\n\r\n\t_getMapPanePos: function () {\r\n\t\treturn L.DomUtil.getPosition(this._mapPane);\r\n\t},\r\n\r\n\t_moved: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\treturn pos && !pos.equals([0, 0]);\r\n\t},\r\n\r\n\t_getTopLeftPoint: function () {\r\n\t\treturn this.getPixelOrigin().subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\t_getNewTopLeftPoint: function (center, zoom) {\r\n\t\tvar viewHalf = this.getSize()._divideBy(2);\r\n\t\t// TODO round on display, not calculation to increase precision?\r\n\t\treturn this.project(center, zoom)._subtract(viewHalf)._round();\r\n\t},\r\n\r\n\t_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {\r\n\t\tvar topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());\r\n\t\treturn this.project(latlng, newZoom)._subtract(topLeft);\r\n\t},\r\n\r\n\t// layer point of the current center\r\n\t_getCenterLayerPoint: function () {\r\n\t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n\t},\r\n\r\n\t// offset of the specified place to the current center in pixels\r\n\t_getCenterOffset: function (latlng) {\r\n\t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\t// adjust center for view to get inside bounds\r\n\t_limitCenter: function (center, zoom, bounds) {\r\n\r\n\t\tif (!bounds) { return center; }\r\n\r\n\t\tvar centerPoint = this.project(center, zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n\t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n\t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n\t},\r\n\r\n\t// adjust offset for view to get inside bounds\r\n\t_limitOffset: function (offset, bounds) {\r\n\t\tif (!bounds) { return offset; }\r\n\r\n\t\tvar viewBounds = this.getPixelBounds(),\r\n\t\t    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n\t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n\t},\r\n\r\n\t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n\t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n\t\tvar nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\r\n\t\t    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\r\n\r\n\t\t    dx = this._rebound(nwOffset.x, -seOffset.x),\r\n\t\t    dy = this._rebound(nwOffset.y, -seOffset.y);\r\n\r\n\t\treturn new L.Point(dx, dy);\r\n\t},\r\n\r\n\t_rebound: function (left, right) {\r\n\t\treturn left + right > 0 ?\r\n\t\t\tMath.round(left - right) / 2 :\r\n\t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n\t},\r\n\r\n\t_limitZoom: function (zoom) {\r\n\t\tvar min = this.getMinZoom(),\r\n\t\t    max = this.getMaxZoom();\r\n\r\n\t\treturn Math.max(min, Math.min(max, zoom));\r\n\t}\r\n});\r\n\r\nL.map = function (id, options) {\r\n\treturn new L.Map(id, options);\r\n};\r\n\n\n/*\r\n * Mercator projection that takes into account that the Earth is not a perfect sphere.\r\n * Less popular than spherical mercator; used by projections like EPSG:3395.\r\n */\r\n\r\nL.Projection.Mercator = {\r\n\tMAX_LATITUDE: 85.0840591556,\r\n\r\n\tR_MINOR: 6356752.314245179,\r\n\tR_MAJOR: 6378137,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    x = latlng.lng * d * r,\r\n\t\t    y = lat * d,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1.0 - tmp * tmp),\r\n\t\t    con = eccent * Math.sin(y);\r\n\r\n\t\tcon = Math.pow((1 - con) / (1 + con), eccent * 0.5);\r\n\r\n\t\tvar ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;\r\n\t\ty = -r * Math.log(ts);\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    lng = point.x * d / r,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1 - (tmp * tmp)),\r\n\t\t    ts = Math.exp(- point.y / r),\r\n\t\t    phi = (Math.PI / 2) - 2 * Math.atan(ts),\r\n\t\t    numIter = 15,\r\n\t\t    tol = 1e-7,\r\n\t\t    i = numIter,\r\n\t\t    dphi = 0.1,\r\n\t\t    con;\r\n\r\n\t\twhile ((Math.abs(dphi) > tol) && (--i > 0)) {\r\n\t\t\tcon = eccent * Math.sin(phi);\r\n\t\t\tdphi = (Math.PI / 2) - 2 * Math.atan(ts *\r\n\t\t\t            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;\r\n\t\t\tphi += dphi;\r\n\t\t}\r\n\r\n\t\treturn new L.LatLng(phi * d, lng);\r\n\t}\r\n};\r\n\n\n\r\nL.CRS.EPSG3395 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3395',\r\n\r\n\tprojection: L.Projection.Mercator,\r\n\r\n\ttransformation: (function () {\r\n\t\tvar m = L.Projection.Mercator,\r\n\t\t    r = m.R_MAJOR,\r\n\t\t    scale = 0.5 / (Math.PI * r);\r\n\r\n\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\r\n\t}())\r\n});\r\n\n\n/*\r\n * L.TileLayer is used for standard xyz-numbered tile layers.\r\n */\r\n\r\nL.TileLayer = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminZoom: 0,\r\n\t\tmaxZoom: 18,\r\n\t\ttileSize: 256,\r\n\t\tsubdomains: 'abc',\r\n\t\terrorTileUrl: '',\r\n\t\tattribution: '',\r\n\t\tzoomOffset: 0,\r\n\t\topacity: 1,\r\n\t\t/*\r\n\t\tmaxNativeZoom: null,\r\n\t\tzIndex: null,\r\n\t\ttms: false,\r\n\t\tcontinuousWorld: false,\r\n\t\tnoWrap: false,\r\n\t\tzoomReverse: false,\r\n\t\tdetectRetina: false,\r\n\t\treuseTiles: false,\r\n\t\tbounds: false,\r\n\t\t*/\r\n\t\tunloadInvisibleTiles: L.Browser.mobile,\r\n\t\tupdateWhenIdle: L.Browser.mobile\r\n\t},\r\n\r\n\tinitialize: function (url, options) {\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n\t\tif (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\r\n\r\n\t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\t\t\toptions.zoomOffset++;\r\n\r\n\t\t\tif (options.minZoom > 0) {\r\n\t\t\t\toptions.minZoom--;\r\n\t\t\t}\r\n\t\t\tthis.options.maxZoom--;\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\toptions.bounds = L.latLngBounds(options.bounds);\r\n\t\t}\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar subdomains = this.options.subdomains;\r\n\r\n\t\tif (typeof subdomains === 'string') {\r\n\t\t\tthis.options.subdomains = subdomains.split('');\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._animated = map._zoomAnimated;\r\n\r\n\t\t// create a container div for tiles\r\n\t\tthis._initContainer();\r\n\r\n\t\t// set up events\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.on({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tthis._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);\r\n\t\t\tmap.on('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t\tthis._update();\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis._container.parentNode.removeChild(this._container);\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.off({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tmap.off('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._container = null;\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.appendChild(this._container);\r\n\t\t\tthis._setAutoZIndex(pane, Math.max);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.insertBefore(this._container, pane.firstChild);\r\n\t\t\tthis._setAutoZIndex(pane, Math.min);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\tthis.options.zIndex = zIndex;\r\n\t\tthis._updateZIndex();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url, noRedraw) {\r\n\t\tthis._url = url;\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateZIndex: function () {\r\n\t\tif (this._container && this.options.zIndex !== undefined) {\r\n\t\t\tthis._container.style.zIndex = this.options.zIndex;\r\n\t\t}\r\n\t},\r\n\r\n\t_setAutoZIndex: function (pane, compare) {\r\n\r\n\t\tvar layers = pane.children,\r\n\t\t    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min\r\n\t\t    zIndex, i, len;\r\n\r\n\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\r\n\t\t\tif (layers[i] !== this._container) {\r\n\t\t\t\tzIndex = parseInt(layers[i].style.zIndex, 10);\r\n\r\n\t\t\t\tif (!isNaN(zIndex)) {\r\n\t\t\t\t\tedgeZIndex = compare(edgeZIndex, zIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.options.zIndex = this._container.style.zIndex =\r\n\t\t        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tvar i,\r\n\t\t    tiles = this._tiles;\r\n\r\n\t\tif (L.Browser.ielt9) {\r\n\t\t\tfor (i in tiles) {\r\n\t\t\t\tL.DomUtil.setOpacity(tiles[i], this.options.opacity);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tL.DomUtil.setOpacity(this._container, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_initContainer: function () {\r\n\t\tvar tilePane = this._map._panes.tilePane;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._container = L.DomUtil.create('div', 'leaflet-layer');\r\n\r\n\t\t\tthis._updateZIndex();\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\tvar className = 'leaflet-tile-container';\r\n\r\n\t\t\t\tthis._bgBuffer = L.DomUtil.create('div', className, this._container);\r\n\t\t\t\tthis._tileContainer = L.DomUtil.create('div', className, this._container);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tthis._tileContainer = this._container;\r\n\t\t\t}\r\n\r\n\t\t\ttilePane.appendChild(this._container);\r\n\r\n\t\t\tif (this.options.opacity < 1) {\r\n\t\t\t\tthis._updateOpacity();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_reset: function (e) {\r\n\t\tfor (var key in this._tiles) {\r\n\t\t\tthis.fire('tileunload', {tile: this._tiles[key]});\r\n\t\t}\r\n\r\n\t\tthis._tiles = {};\r\n\t\tthis._tilesToLoad = 0;\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tthis._unusedTiles = [];\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.innerHTML = '';\r\n\r\n\t\tif (this._animated && e && e.hard) {\r\n\t\t\tthis._clearBgBuffer();\r\n\t\t}\r\n\r\n\t\tthis._initContainer();\r\n\t},\r\n\r\n\t_getTileSize: function () {\r\n\t\tvar map = this._map,\r\n\t\t    zoom = map.getZoom() + this.options.zoomOffset,\r\n\t\t    zoomN = this.options.maxNativeZoom,\r\n\t\t    tileSize = this.options.tileSize;\r\n\r\n\t\tif (zoomN && zoom > zoomN) {\r\n\t\t\ttileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);\r\n\t\t}\r\n\r\n\t\treturn tileSize;\r\n\t},\r\n\r\n\t_update: function () {\r\n\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    bounds = map.getPixelBounds(),\r\n\t\t    zoom = map.getZoom(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tileBounds = L.bounds(\r\n\t\t        bounds.min.divideBy(tileSize)._floor(),\r\n\t\t        bounds.max.divideBy(tileSize)._floor());\r\n\r\n\t\tthis._addTilesFromCenterOut(tileBounds);\r\n\r\n\t\tif (this.options.unloadInvisibleTiles || this.options.reuseTiles) {\r\n\t\t\tthis._removeOtherTiles(tileBounds);\r\n\t\t}\r\n\t},\r\n\r\n\t_addTilesFromCenterOut: function (bounds) {\r\n\t\tvar queue = [],\r\n\t\t    center = bounds.getCenter();\r\n\r\n\t\tvar j, i, point;\r\n\r\n\t\tfor (j = bounds.min.y; j <= bounds.max.y; j++) {\r\n\t\t\tfor (i = bounds.min.x; i <= bounds.max.x; i++) {\r\n\t\t\t\tpoint = new L.Point(i, j);\r\n\r\n\t\t\t\tif (this._tileShouldBeLoaded(point)) {\r\n\t\t\t\t\tqueue.push(point);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar tilesToLoad = queue.length;\r\n\r\n\t\tif (tilesToLoad === 0) { return; }\r\n\r\n\t\t// load tiles in order of their distance to center\r\n\t\tqueue.sort(function (a, b) {\r\n\t\t\treturn a.distanceTo(center) - b.distanceTo(center);\r\n\t\t});\r\n\r\n\t\tvar fragment = document.createDocumentFragment();\r\n\r\n\t\t// if its the first batch of tiles to load\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('loading');\r\n\t\t}\r\n\r\n\t\tthis._tilesToLoad += tilesToLoad;\r\n\r\n\t\tfor (i = 0; i < tilesToLoad; i++) {\r\n\t\t\tthis._addTile(queue[i], fragment);\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.appendChild(fragment);\r\n\t},\r\n\r\n\t_tileShouldBeLoaded: function (tilePoint) {\r\n\t\tif ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {\r\n\t\t\treturn false; // already loaded\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (!options.continuousWorld) {\r\n\t\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t\t// don't load if exceeds world bounds\r\n\t\t\tif ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||\r\n\t\t\t\ttilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\tvar tileSize = this._getTileSize(),\r\n\t\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\t\t\t    nw = this._map.unproject(nwPoint),\r\n\t\t\t    se = this._map.unproject(sePoint);\r\n\r\n\t\t\t// TODO temporary hack, will be removed after refactoring projections\r\n\t\t\t// https://github.com/Leaflet/Leaflet/issues/1618\r\n\t\t\tif (!options.continuousWorld && !options.noWrap) {\r\n\t\t\t\tnw = nw.wrap();\r\n\t\t\t\tse = se.wrap();\r\n\t\t\t}\r\n\r\n\t\t\tif (!options.bounds.intersects([nw, se])) { return false; }\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_removeOtherTiles: function (bounds) {\r\n\t\tvar kArr, x, y, key;\r\n\r\n\t\tfor (key in this._tiles) {\r\n\t\t\tkArr = key.split(':');\r\n\t\t\tx = parseInt(kArr[0], 10);\r\n\t\t\ty = parseInt(kArr[1], 10);\r\n\r\n\t\t\t// remove tile if it's out of bounds\r\n\t\t\tif (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {\r\n\t\t\t\tthis._removeTile(key);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_removeTile: function (key) {\r\n\t\tvar tile = this._tiles[key];\r\n\r\n\t\tthis.fire('tileunload', {tile: tile, url: tile.src});\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tL.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\r\n\t\t\tthis._unusedTiles.push(tile);\r\n\r\n\t\t} else if (tile.parentNode === this._tileContainer) {\r\n\t\t\tthis._tileContainer.removeChild(tile);\r\n\t\t}\r\n\r\n\t\t// for https://github.com/CloudMade/Leaflet/issues/137\r\n\t\tif (!L.Browser.android) {\r\n\t\t\ttile.onload = null;\r\n\t\t\ttile.src = L.Util.emptyImageUrl;\r\n\t\t}\r\n\r\n\t\tdelete this._tiles[key];\r\n\t},\r\n\r\n\t_addTile: function (tilePoint, container) {\r\n\t\tvar tilePos = this._getTilePos(tilePoint);\r\n\r\n\t\t// get unused tile - or create a new tile\r\n\t\tvar tile = this._getTile();\r\n\r\n\t\t/*\r\n\t\tChrome 20 layouts much faster with top/left (verify with timeline, frames)\r\n\t\tAndroid 4 browser has display issues with top/left and requires transform instead\r\n\t\t(other browsers don't currently care) - see debug/hacks/jitter.html for an example\r\n\t\t*/\r\n\t\tL.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);\r\n\r\n\t\tthis._tiles[tilePoint.x + ':' + tilePoint.y] = tile;\r\n\r\n\t\tthis._loadTile(tile, tilePoint);\r\n\r\n\t\tif (tile.parentNode !== this._tileContainer) {\r\n\t\t\tcontainer.appendChild(tile);\r\n\t\t}\r\n\t},\r\n\r\n\t_getZoomForUrl: function () {\r\n\r\n\t\tvar options = this.options,\r\n\t\t    zoom = this._map.getZoom();\r\n\r\n\t\tif (options.zoomReverse) {\r\n\t\t\tzoom = options.maxZoom - zoom;\r\n\t\t}\r\n\r\n\t\tzoom += options.zoomOffset;\r\n\r\n\t\treturn options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;\r\n\t},\r\n\r\n\t_getTilePos: function (tilePoint) {\r\n\t\tvar origin = this._map.getPixelOrigin(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\treturn tilePoint.multiplyBy(tileSize).subtract(origin);\r\n\t},\r\n\r\n\t// image-specific code (override to implement e.g. Canvas or SVG tile layer)\r\n\r\n\tgetTileUrl: function (tilePoint) {\r\n\t\treturn L.Util.template(this._url, L.extend({\r\n\t\t\ts: this._getSubdomain(tilePoint),\r\n\t\t\tz: tilePoint.z,\r\n\t\t\tx: tilePoint.x,\r\n\t\t\ty: tilePoint.y\r\n\t\t}, this.options));\r\n\t},\r\n\r\n\t_getWrapTileNum: function () {\r\n\t\tvar crs = this._map.options.crs,\r\n\t\t    size = crs.getSize(this._map.getZoom());\r\n\t\treturn size.divideBy(this._getTileSize())._floor();\r\n\t},\r\n\r\n\t_adjustTilePoint: function (tilePoint) {\r\n\r\n\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t// wrap tile coordinates\r\n\t\tif (!this.options.continuousWorld && !this.options.noWrap) {\r\n\t\t\ttilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;\r\n\t\t}\r\n\r\n\t\tif (this.options.tms) {\r\n\t\t\ttilePoint.y = limit.y - tilePoint.y - 1;\r\n\t\t}\r\n\r\n\t\ttilePoint.z = this._getZoomForUrl();\r\n\t},\r\n\r\n\t_getSubdomain: function (tilePoint) {\r\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n\t\treturn this.options.subdomains[index];\r\n\t},\r\n\r\n\t_getTile: function () {\r\n\t\tif (this.options.reuseTiles && this._unusedTiles.length > 0) {\r\n\t\t\tvar tile = this._unusedTiles.pop();\r\n\t\t\tthis._resetTile(tile);\r\n\t\t\treturn tile;\r\n\t\t}\r\n\t\treturn this._createTile();\r\n\t},\r\n\r\n\t// Override if data stored on a tile needs to be cleaned up before reuse\r\n\t_resetTile: function (/*tile*/) {},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('img', 'leaflet-tile');\r\n\t\ttile.style.width = tile.style.height = this._getTileSize() + 'px';\r\n\t\ttile.galleryimg = 'no';\r\n\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\r\n\t\tif (L.Browser.ielt9 && this.options.opacity !== undefined) {\r\n\t\t\tL.DomUtil.setOpacity(tile, this.options.opacity);\r\n\t\t}\r\n\t\t// without this hack, tiles disappear after zoom on Chrome for Android\r\n\t\t// https://github.com/Leaflet/Leaflet/issues/2078\r\n\t\tif (L.Browser.mobileWebkit3d) {\r\n\t\t\ttile.style.WebkitBackfaceVisibility = 'hidden';\r\n\t\t}\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer  = this;\r\n\t\ttile.onload  = this._tileOnLoad;\r\n\t\ttile.onerror = this._tileOnError;\r\n\r\n\t\tthis._adjustTilePoint(tilePoint);\r\n\t\ttile.src     = this.getTileUrl(tilePoint);\r\n\r\n\t\tthis.fire('tileloadstart', {\r\n\t\t\ttile: tile,\r\n\t\t\turl: tile.src\r\n\t\t});\r\n\t},\r\n\r\n\t_tileLoaded: function () {\r\n\t\tthis._tilesToLoad--;\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tL.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\r\n\t\t}\r\n\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('load');\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\t// clear scaled tiles after all new tiles are loaded (for performance)\r\n\t\t\t\tclearTimeout(this._clearBgBufferTimer);\r\n\t\t\t\tthis._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_tileOnLoad: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\t//Only if we are loading an actual image\r\n\t\tif (this.src !== L.Util.emptyImageUrl) {\r\n\t\t\tL.DomUtil.addClass(this, 'leaflet-tile-loaded');\r\n\r\n\t\t\tlayer.fire('tileload', {\r\n\t\t\t\ttile: this,\r\n\t\t\t\turl: this.src\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t},\r\n\r\n\t_tileOnError: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\tlayer.fire('tileerror', {\r\n\t\t\ttile: this,\r\n\t\t\turl: this.src\r\n\t\t});\r\n\r\n\t\tvar newUrl = layer.options.errorTileUrl;\r\n\t\tif (newUrl) {\r\n\t\t\tthis.src = newUrl;\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t}\r\n});\r\n\r\nL.tileLayer = function (url, options) {\r\n\treturn new L.TileLayer(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.WMS is used for putting WMS tile layers on the map.\r\n */\r\n\r\nL.TileLayer.WMS = L.TileLayer.extend({\r\n\r\n\tdefaultWmsParams: {\r\n\t\tservice: 'WMS',\r\n\t\trequest: 'GetMap',\r\n\t\tversion: '1.1.1',\r\n\t\tlayers: '',\r\n\t\tstyles: '',\r\n\t\tformat: 'image/jpeg',\r\n\t\ttransparent: false\r\n\t},\r\n\r\n\tinitialize: function (url, options) { // (String, Object)\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar wmsParams = L.extend({}, this.defaultWmsParams),\r\n\t\t    tileSize = options.tileSize || this.options.tileSize;\r\n\r\n\t\tif (options.detectRetina && L.Browser.retina) {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize * 2;\r\n\t\t} else {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize;\r\n\t\t}\r\n\r\n\t\tfor (var i in options) {\r\n\t\t\t// all keys that are not TileLayer options go to WMS params\r\n\t\t\tif (!this.options.hasOwnProperty(i) && i !== 'crs') {\r\n\t\t\t\twmsParams[i] = options[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.wmsParams = wmsParams;\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\r\n\t\tthis._crs = this.options.crs || map.options.crs;\r\n\r\n\t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n\t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n\t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\r\n\t\tL.TileLayer.prototype.onAdd.call(this, map);\r\n\t},\r\n\r\n\tgetTileUrl: function (tilePoint) { // (Point, Number) -> String\r\n\r\n\t\tvar map = this._map,\r\n\t\t    tileSize = this.options.tileSize,\r\n\r\n\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\r\n\t\t    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\r\n\t\t    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\r\n\t\t    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?\r\n\t\t        [se.y, nw.x, nw.y, se.x].join(',') :\r\n\t\t        [nw.x, se.y, se.x, nw.y].join(','),\r\n\r\n\t\t    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});\r\n\r\n\t\treturn url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;\r\n\t},\r\n\r\n\tsetParams: function (params, noRedraw) {\r\n\r\n\t\tL.extend(this.wmsParams, params);\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.tileLayer.wms = function (url, options) {\r\n\treturn new L.TileLayer.WMS(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.Canvas is a class that you can use as a base for creating\r\n * dynamically drawn Canvas-based tile layers.\r\n */\r\n\r\nL.TileLayer.Canvas = L.TileLayer.extend({\r\n\toptions: {\r\n\t\tasync: false\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tfor (var i in this._tiles) {\r\n\t\t\tthis._redrawTile(this._tiles[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_redrawTile: function (tile) {\r\n\t\tthis.drawTile(tile, tile._tilePoint, this._map._zoom);\r\n\t},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('canvas', 'leaflet-tile');\r\n\t\ttile.width = tile.height = this.options.tileSize;\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer = this;\r\n\t\ttile._tilePoint = tilePoint;\r\n\r\n\t\tthis._redrawTile(tile);\r\n\r\n\t\tif (!this.options.async) {\r\n\t\t\tthis.tileDrawn(tile);\r\n\t\t}\r\n\t},\r\n\r\n\tdrawTile: function (/*tile, tilePoint*/) {\r\n\t\t// override with rendering code\r\n\t},\r\n\r\n\ttileDrawn: function (tile) {\r\n\t\tthis._tileOnLoad.call(tile);\r\n\t}\r\n});\r\n\r\n\r\nL.tileLayer.canvas = function (options) {\r\n\treturn new L.TileLayer.Canvas(options);\r\n};\r\n\n\n/*\r\n * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\r\n */\r\n\r\nL.ImageOverlay = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\topacity: 1\r\n\t},\r\n\r\n\tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n\t\tthis._url = url;\r\n\t\tthis._bounds = L.latLngBounds(bounds);\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._image) {\r\n\t\t\tthis._initImage();\r\n\t\t}\r\n\r\n\t\tmap._panes.overlayPane.appendChild(this._image);\r\n\r\n\t\tmap.on('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.getPanes().overlayPane.removeChild(this._image);\r\n\r\n\t\tmap.off('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation) {\r\n\t\t\tmap.off('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tthis._updateOpacity();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// TODO remove bringToFront/bringToBack duplication from TileLayer/Path\r\n\tbringToFront: function () {\r\n\t\tif (this._image) {\r\n\t\t\tthis._map._panes.overlayPane.appendChild(this._image);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.overlayPane;\r\n\t\tif (this._image) {\r\n\t\t\tpane.insertBefore(this._image, pane.firstChild);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url) {\r\n\t\tthis._url = url;\r\n\t\tthis._image.src = this._url;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\t_initImage: function () {\r\n\t\tthis._image = L.DomUtil.create('img', 'leaflet-image-layer');\r\n\r\n\t\tif (this._map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-animated');\r\n\t\t} else {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-hide');\r\n\t\t}\r\n\r\n\t\tthis._updateOpacity();\r\n\r\n\t\t//TODO createImage util method to remove duplication\r\n\t\tL.extend(this._image, {\r\n\t\t\tgalleryimg: 'no',\r\n\t\t\tonselectstart: L.Util.falseFn,\r\n\t\t\tonmousemove: L.Util.falseFn,\r\n\t\t\tonload: L.bind(this._onImageLoad, this),\r\n\t\t\tsrc: this._url\r\n\t\t});\r\n\t},\r\n\r\n\t_animateZoom: function (e) {\r\n\t\tvar map = this._map,\r\n\t\t    image = this._image,\r\n\t\t    scale = map.getZoomScale(e.zoom),\r\n\t\t    nw = this._bounds.getNorthWest(),\r\n\t\t    se = this._bounds.getSouthEast(),\r\n\r\n\t\t    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),\r\n\t\t    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),\r\n\t\t    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));\r\n\r\n\t\timage.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';\r\n\t},\r\n\r\n\t_reset: function () {\r\n\t\tvar image   = this._image,\r\n\t\t    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n\t\t    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);\r\n\r\n\t\tL.DomUtil.setPosition(image, topLeft);\r\n\r\n\t\timage.style.width  = size.x + 'px';\r\n\t\timage.style.height = size.y + 'px';\r\n\t},\r\n\r\n\t_onImageLoad: function () {\r\n\t\tthis.fire('load');\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._image, this.options.opacity);\r\n\t}\r\n});\r\n\r\nL.imageOverlay = function (url, bounds, options) {\r\n\treturn new L.ImageOverlay(url, bounds, options);\r\n};\r\n\n\n/*\r\n * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\r\n */\r\n\r\nL.Icon = L.Class.extend({\r\n\toptions: {\r\n\t\t/*\r\n\t\ticonUrl: (String) (required)\r\n\t\ticonRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\ticonSize: (Point) (can be set through CSS)\r\n\t\ticonAnchor: (Point) (centered by default, can be set in CSS with negative margins)\r\n\t\tpopupAnchor: (Point) (if not specified, popup opens in the anchor point)\r\n\t\tshadowUrl: (String) (no shadow by default)\r\n\t\tshadowRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\tshadowSize: (Point)\r\n\t\tshadowAnchor: (Point)\r\n\t\t*/\r\n\t\tclassName: ''\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tcreateIcon: function (oldIcon) {\r\n\t\treturn this._createIcon('icon', oldIcon);\r\n\t},\r\n\r\n\tcreateShadow: function (oldIcon) {\r\n\t\treturn this._createIcon('shadow', oldIcon);\r\n\t},\r\n\r\n\t_createIcon: function (name, oldIcon) {\r\n\t\tvar src = this._getIconUrl(name);\r\n\r\n\t\tif (!src) {\r\n\t\t\tif (name === 'icon') {\r\n\t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar img;\r\n\t\tif (!oldIcon || oldIcon.tagName !== 'IMG') {\r\n\t\t\timg = this._createImg(src);\r\n\t\t} else {\r\n\t\t\timg = this._createImg(src, oldIcon);\r\n\t\t}\r\n\t\tthis._setIconStyles(img, name);\r\n\r\n\t\treturn img;\r\n\t},\r\n\r\n\t_setIconStyles: function (img, name) {\r\n\t\tvar options = this.options,\r\n\t\t    size = L.point(options[name + 'Size']),\r\n\t\t    anchor;\r\n\r\n\t\tif (name === 'shadow') {\r\n\t\t\tanchor = L.point(options.shadowAnchor || options.iconAnchor);\r\n\t\t} else {\r\n\t\t\tanchor = L.point(options.iconAnchor);\r\n\t\t}\r\n\r\n\t\tif (!anchor && size) {\r\n\t\t\tanchor = size.divideBy(2, true);\r\n\t\t}\r\n\r\n\t\timg.className = 'leaflet-marker-' + name + ' ' + options.className;\r\n\r\n\t\tif (anchor) {\r\n\t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n\t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n\t\t}\r\n\r\n\t\tif (size) {\r\n\t\t\timg.style.width  = size.x + 'px';\r\n\t\t\timg.style.height = size.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\t_createImg: function (src, el) {\r\n\t\tel = el || document.createElement('img');\r\n\t\tel.src = src;\r\n\t\treturn el;\r\n\t},\r\n\r\n\t_getIconUrl: function (name) {\r\n\t\tif (L.Browser.retina && this.options[name + 'RetinaUrl']) {\r\n\t\t\treturn this.options[name + 'RetinaUrl'];\r\n\t\t}\r\n\t\treturn this.options[name + 'Url'];\r\n\t}\r\n});\r\n\r\nL.icon = function (options) {\r\n\treturn new L.Icon(options);\r\n};\r\n\n\n/*\n * L.Icon.Default is the blue marker icon used by default in Leaflet.\n */\n\nL.Icon.Default = L.Icon.extend({\n\n\toptions: {\n\t\ticonSize: [25, 41],\n\t\ticonAnchor: [12, 41],\n\t\tpopupAnchor: [1, -34],\n\n\t\tshadowSize: [41, 41]\n\t},\n\n\t_getIconUrl: function (name) {\n\t\tvar key = name + 'Url';\n\n\t\tif (this.options[key]) {\n\t\t\treturn this.options[key];\n\t\t}\n\n\t\tif (L.Browser.retina && name === 'icon') {\n\t\t\tname += '-2x';\n\t\t}\n\n\t\tvar path = L.Icon.Default.imagePath;\n\n\t\tif (!path) {\n\t\t\tthrow new Error('Couldn\\'t autodetect L.Icon.Default.imagePath, set it manually.');\n\t\t}\n\n\t\treturn path + '/marker-' + name + '.png';\n\t}\n});\n\nL.Icon.Default.imagePath = (function () {\n\tvar scripts = document.getElementsByTagName('script'),\n\t    leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n\tvar i, len, src, matches, path;\n\n\tfor (i = 0, len = scripts.length; i < len; i++) {\n\t\tsrc = scripts[i].src;\n\t\tmatches = src.match(leafletRe);\n\n\t\tif (matches) {\n\t\t\tpath = src.split(leafletRe)[0];\n\t\t\treturn (path ? path + '/' : '') + 'images';\n\t\t}\n\t}\n}());\n\n\n/*\r\n * L.Marker is used to display clickable/draggable icons on the map.\r\n */\r\n\r\nL.Marker = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\ticon: new L.Icon.Default(),\r\n\t\ttitle: '',\r\n\t\talt: '',\r\n\t\tclickable: true,\r\n\t\tdraggable: false,\r\n\t\tkeyboard: true,\r\n\t\tzIndexOffset: 0,\r\n\t\topacity: 1,\r\n\t\triseOnHover: false,\r\n\t\triseOffset: 250\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.setOptions(this, options);\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tmap.on('viewreset', this.update, this);\r\n\r\n\t\tthis._initIcon();\r\n\t\tthis.update();\r\n\t\tthis.fire('add');\r\n\r\n\t\tif (map.options.zoomAnimation && map.options.markerZoomAnimation) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tif (this.dragging) {\r\n\t\t\tthis.dragging.disable();\r\n\t\t}\r\n\r\n\t\tthis._removeIcon();\r\n\t\tthis._removeShadow();\r\n\r\n\t\tthis.fire('remove');\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.update,\r\n\t\t\t'zoomanim': this._animateZoom\r\n\t\t}, this);\r\n\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\r\n\t\tthis.update();\r\n\r\n\t\treturn this.fire('move', { latlng: this._latlng });\r\n\t},\r\n\r\n\tsetZIndexOffset: function (offset) {\r\n\t\tthis.options.zIndexOffset = offset;\r\n\t\tthis.update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetIcon: function (icon) {\r\n\r\n\t\tthis.options.icon = icon;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._initIcon();\r\n\t\t\tthis.update();\r\n\t\t}\r\n\r\n\t\tif (this._popup) {\r\n\t\t\tthis.bindPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (this._icon) {\r\n\t\t\tthis._setPos(this._map.latLngToLayerPoint(this._latlng).round());\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initIcon: function () {\r\n\t\tvar options = this.options,\r\n\t\t    map = this._map,\r\n\t\t    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),\r\n\t\t    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';\r\n\r\n\t\tvar icon = options.icon.createIcon(this._icon),\r\n\t\t\taddIcon = false;\r\n\r\n\t\t// if we're not reusing the icon, remove the old one and init new one\r\n\t\tif (icon !== this._icon) {\r\n\t\t\tif (this._icon) {\r\n\t\t\t\tthis._removeIcon();\r\n\t\t\t}\r\n\t\t\taddIcon = true;\r\n\r\n\t\t\tif (options.title) {\r\n\t\t\t\ticon.title = options.title;\r\n\t\t\t}\r\n\r\n\t\t\tif (options.alt) {\r\n\t\t\t\ticon.alt = options.alt;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tL.DomUtil.addClass(icon, classToAdd);\r\n\r\n\t\tif (options.keyboard) {\r\n\t\t\ticon.tabIndex = '0';\r\n\t\t}\r\n\r\n\t\tthis._icon = icon;\r\n\r\n\t\tthis._initInteraction();\r\n\r\n\t\tif (options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.on(icon, 'mouseover', this._bringToFront, this)\r\n\t\t\t\t.on(icon, 'mouseout', this._resetZIndex, this);\r\n\t\t}\r\n\r\n\t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n\t\t\taddShadow = false;\r\n\r\n\t\tif (newShadow !== this._shadow) {\r\n\t\t\tthis._removeShadow();\r\n\t\t\taddShadow = true;\r\n\t\t}\r\n\r\n\t\tif (newShadow) {\r\n\t\t\tL.DomUtil.addClass(newShadow, classToAdd);\r\n\t\t}\r\n\t\tthis._shadow = newShadow;\r\n\r\n\r\n\t\tif (options.opacity < 1) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\r\n\t\tvar panes = this._map._panes;\r\n\r\n\t\tif (addIcon) {\r\n\t\t\tpanes.markerPane.appendChild(this._icon);\r\n\t\t}\r\n\r\n\t\tif (newShadow && addShadow) {\r\n\t\t\tpanes.shadowPane.appendChild(this._shadow);\r\n\t\t}\r\n\t},\r\n\r\n\t_removeIcon: function () {\r\n\t\tif (this.options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(this._icon, 'mouseover', this._bringToFront)\r\n\t\t\t    .off(this._icon, 'mouseout', this._resetZIndex);\r\n\t\t}\r\n\r\n\t\tthis._map._panes.markerPane.removeChild(this._icon);\r\n\r\n\t\tthis._icon = null;\r\n\t},\r\n\r\n\t_removeShadow: function () {\r\n\t\tif (this._shadow) {\r\n\t\t\tthis._map._panes.shadowPane.removeChild(this._shadow);\r\n\t\t}\r\n\t\tthis._shadow = null;\r\n\t},\r\n\r\n\t_setPos: function (pos) {\r\n\t\tL.DomUtil.setPosition(this._icon, pos);\r\n\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setPosition(this._shadow, pos);\r\n\t\t}\r\n\r\n\t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n\t\tthis._resetZIndex();\r\n\t},\r\n\r\n\t_updateZIndex: function (offset) {\r\n\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n\t},\r\n\r\n\t_animateZoom: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n\t\tthis._setPos(pos);\r\n\t},\r\n\r\n\t_initInteraction: function () {\r\n\r\n\t\tif (!this.options.clickable) { return; }\r\n\r\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\r\n\r\n\t\tvar icon = this._icon,\r\n\t\t    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];\r\n\r\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\r\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\r\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\r\n\r\n\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n\t\t\tif (this.options.draggable) {\r\n\t\t\t\tthis.dragging.enable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tvar wasDragged = this.dragging && this.dragging.moved();\r\n\r\n\t\tif (this.hasEventListeners(e.type) || wasDragged) {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\r\n\t\tif (wasDragged) { return; }\r\n\r\n\t\tif ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\t},\r\n\r\n\t_onKeyPress: function (e) {\r\n\t\tif (e.keyCode === 13) {\r\n\t\t\tthis.fire('click', {\r\n\t\t\t\toriginalEvent: e,\r\n\t\t\t\tlatlng: this._latlng\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\r\n\t\t// TODO proper custom event propagation\r\n\t\t// this line will always be called if marker is in a FeatureGroup\r\n\t\tif (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousedown') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._icon, this.options.opacity);\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setOpacity(this._shadow, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_bringToFront: function () {\r\n\t\tthis._updateZIndex(this.options.riseOffset);\r\n\t},\r\n\r\n\t_resetZIndex: function () {\r\n\t\tthis._updateZIndex(0);\r\n\t}\r\n});\r\n\r\nL.marker = function (latlng, options) {\r\n\treturn new L.Marker(latlng, options);\r\n};\r\n\n\n/*\n * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n * to use with L.Marker.\n */\n\nL.DivIcon = L.Icon.extend({\n\toptions: {\n\t\ticonSize: [12, 12], // also can be set through CSS\n\t\t/*\n\t\ticonAnchor: (Point)\n\t\tpopupAnchor: (Point)\n\t\thtml: (String)\n\t\tbgPos: (Point)\n\t\t*/\n\t\tclassName: 'leaflet-div-icon',\n\t\thtml: false\n\t},\n\n\tcreateIcon: function (oldIcon) {\n\t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n\t\t    options = this.options;\n\n\t\tif (options.html !== false) {\n\t\t\tdiv.innerHTML = options.html;\n\t\t} else {\n\t\t\tdiv.innerHTML = '';\n\t\t}\n\n\t\tif (options.bgPos) {\n\t\t\tdiv.style.backgroundPosition =\n\t\t\t        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n\t\t}\n\n\t\tthis._setIconStyles(div, 'icon');\n\t\treturn div;\n\t},\n\n\tcreateShadow: function () {\n\t\treturn null;\n\t}\n});\n\nL.divIcon = function (options) {\n\treturn new L.DivIcon(options);\n};\n\n\n/*\r\n * L.Popup is used for displaying popups on the map.\r\n */\r\n\r\nL.Map.mergeOptions({\r\n\tclosePopupOnClick: true\r\n});\r\n\r\nL.Popup = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminWidth: 50,\r\n\t\tmaxWidth: 300,\r\n\t\t// maxHeight: null,\r\n\t\tautoPan: true,\r\n\t\tcloseButton: true,\r\n\t\toffset: [0, 7],\r\n\t\tautoPanPadding: [5, 5],\r\n\t\t// autoPanPaddingTopLeft: null,\r\n\t\t// autoPanPaddingBottomRight: null,\r\n\t\tkeepInView: false,\r\n\t\tclassName: '',\r\n\t\tzoomAnimation: true\r\n\t},\r\n\r\n\tinitialize: function (options, source) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._source = source;\r\n\t\tthis._animated = L.Browser.any3d && this.options.zoomAnimation;\r\n\t\tthis._isOpen = false;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initLayout();\r\n\t\t}\r\n\r\n\t\tvar animFade = map.options.fadeAnimation;\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\t\tmap._panes.popupPane.appendChild(this._container);\r\n\r\n\t\tmap.on(this._getEvents(), this);\r\n\r\n\t\tthis.update();\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 1);\r\n\t\t}\r\n\r\n\t\tthis.fire('open');\r\n\r\n\t\tmap.fire('popupopen', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupopen', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenOn: function (map) {\r\n\t\tmap.openPopup(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._panes.popupPane.removeChild(this._container);\r\n\r\n\t\tL.Util.falseFn(this._container.offsetWidth); // force reflow\r\n\r\n\t\tmap.off(this._getEvents(), this);\r\n\r\n\t\tif (map.options.fadeAnimation) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\r\n\t\tthis._map = null;\r\n\r\n\t\tthis.fire('close');\r\n\r\n\t\tmap.fire('popupclose', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupclose', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tif (this._map) {\r\n\t\t\tthis._updatePosition();\r\n\t\t\tthis._adjustPan();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContent: function () {\r\n\t\treturn this._content;\r\n\t},\r\n\r\n\tsetContent: function (content) {\r\n\t\tthis._content = content;\r\n\t\tthis.update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._container.style.visibility = 'hidden';\r\n\r\n\t\tthis._updateContent();\r\n\t\tthis._updateLayout();\r\n\t\tthis._updatePosition();\r\n\r\n\t\tthis._container.style.visibility = '';\r\n\r\n\t\tthis._adjustPan();\r\n\t},\r\n\r\n\t_getEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tviewreset: this._updatePosition\r\n\t\t};\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tevents.zoomanim = this._zoomAnimation;\r\n\t\t}\r\n\t\tif ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n\t\t\tevents.preclick = this._close;\r\n\t\t}\r\n\t\tif (this.options.keepInView) {\r\n\t\t\tevents.moveend = this._adjustPan;\r\n\t\t}\r\n\r\n\t\treturn events;\r\n\t},\r\n\r\n\t_close: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.closePopup(this);\r\n\t\t}\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar prefix = 'leaflet-popup',\r\n\t\t\tcontainerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +\r\n\t\t\t        (this._animated ? 'animated' : 'hide'),\r\n\t\t\tcontainer = this._container = L.DomUtil.create('div', containerClass),\r\n\t\t\tcloseButton;\r\n\r\n\t\tif (this.options.closeButton) {\r\n\t\t\tcloseButton = this._closeButton =\r\n\t\t\t        L.DomUtil.create('a', prefix + '-close-button', container);\r\n\t\t\tcloseButton.href = '#close';\r\n\t\t\tcloseButton.innerHTML = '&#215;';\r\n\t\t\tL.DomEvent.disableClickPropagation(closeButton);\r\n\r\n\t\t\tL.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\r\n\t\t}\r\n\r\n\t\tvar wrapper = this._wrapper =\r\n\t\t        L.DomUtil.create('div', prefix + '-content-wrapper', container);\r\n\t\tL.DomEvent.disableClickPropagation(wrapper);\r\n\r\n\t\tthis._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\r\n\r\n\t\tL.DomEvent.disableScrollPropagation(this._contentNode);\r\n\t\tL.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\r\n\r\n\t\tthis._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\r\n\t\tthis._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\r\n\t},\r\n\r\n\t_updateContent: function () {\r\n\t\tif (!this._content) { return; }\r\n\r\n\t\tif (typeof this._content === 'string') {\r\n\t\t\tthis._contentNode.innerHTML = this._content;\r\n\t\t} else {\r\n\t\t\twhile (this._contentNode.hasChildNodes()) {\r\n\t\t\t\tthis._contentNode.removeChild(this._contentNode.firstChild);\r\n\t\t\t}\r\n\t\t\tthis._contentNode.appendChild(this._content);\r\n\t\t}\r\n\t\tthis.fire('contentupdate');\r\n\t},\r\n\r\n\t_updateLayout: function () {\r\n\t\tvar container = this._contentNode,\r\n\t\t    style = container.style;\r\n\r\n\t\tstyle.width = '';\r\n\t\tstyle.whiteSpace = 'nowrap';\r\n\r\n\t\tvar width = container.offsetWidth;\r\n\t\twidth = Math.min(width, this.options.maxWidth);\r\n\t\twidth = Math.max(width, this.options.minWidth);\r\n\r\n\t\tstyle.width = (width + 1) + 'px';\r\n\t\tstyle.whiteSpace = '';\r\n\r\n\t\tstyle.height = '';\r\n\r\n\t\tvar height = container.offsetHeight,\r\n\t\t    maxHeight = this.options.maxHeight,\r\n\t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n\t\tif (maxHeight && height > maxHeight) {\r\n\t\t\tstyle.height = maxHeight + 'px';\r\n\t\t\tL.DomUtil.addClass(container, scrolledClass);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.removeClass(container, scrolledClass);\r\n\t\t}\r\n\r\n\t\tthis._containerWidth = this._container.offsetWidth;\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n\t\t    animated = this._animated,\r\n\t\t    offset = L.point(this.options.offset);\r\n\r\n\t\tif (animated) {\r\n\t\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t\t}\r\n\r\n\t\tthis._containerBottom = -offset.y - (animated ? 0 : pos.y);\r\n\t\tthis._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);\r\n\r\n\t\t// bottom position the popup in case the height of the popup changes (images loading etc)\r\n\t\tthis._container.style.bottom = this._containerBottom + 'px';\r\n\t\tthis._container.style.left = this._containerLeft + 'px';\r\n\t},\r\n\r\n\t_zoomAnimation: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);\r\n\r\n\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t},\r\n\r\n\t_adjustPan: function () {\r\n\t\tif (!this.options.autoPan) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerHeight = this._container.offsetHeight,\r\n\t\t    containerWidth = this._containerWidth,\r\n\r\n\t\t    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tlayerPos._add(L.DomUtil.getPosition(this._container));\r\n\t\t}\r\n\r\n\t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n\t\t    padding = L.point(this.options.autoPanPadding),\r\n\t\t    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\r\n\t\t    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\r\n\t\t    size = map.getSize(),\r\n\t\t    dx = 0,\r\n\t\t    dy = 0;\r\n\r\n\t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n\t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n\t\t}\r\n\t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n\t\t\tdx = containerPos.x - paddingTL.x;\r\n\t\t}\r\n\t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n\t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n\t\t}\r\n\t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n\t\t\tdy = containerPos.y - paddingTL.y;\r\n\t\t}\r\n\r\n\t\tif (dx || dy) {\r\n\t\t\tmap\r\n\t\t\t    .fire('autopanstart')\r\n\t\t\t    .panBy([dx, dy]);\r\n\t\t}\r\n\t},\r\n\r\n\t_onCloseButtonClick: function (e) {\r\n\t\tthis._close();\r\n\t\tL.DomEvent.stop(e);\r\n\t}\r\n});\r\n\r\nL.popup = function (options, source) {\r\n\treturn new L.Popup(options, source);\r\n};\r\n\r\n\r\nL.Map.include({\r\n\topenPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])\r\n\t\tthis.closePopup();\r\n\r\n\t\tif (!(popup instanceof L.Popup)) {\r\n\t\t\tvar content = popup;\r\n\r\n\t\t\tpopup = new L.Popup(options)\r\n\t\t\t    .setLatLng(latlng)\r\n\t\t\t    .setContent(content);\r\n\t\t}\r\n\t\tpopup._isOpen = true;\r\n\r\n\t\tthis._popup = popup;\r\n\t\treturn this.addLayer(popup);\r\n\t},\r\n\r\n\tclosePopup: function (popup) {\r\n\t\tif (!popup || popup === this._popup) {\r\n\t\t\tpopup = this._popup;\r\n\t\t\tthis._popup = null;\r\n\t\t}\r\n\t\tif (popup) {\r\n\t\t\tthis.removeLayer(popup);\r\n\t\t\tpopup._isOpen = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Marker, adding popup-related methods.\r\n */\r\n\r\nL.Marker.include({\r\n\topenPopup: function () {\r\n\t\tif (this._popup && this._map && !this._map.hasLayer(this._popup)) {\r\n\t\t\tthis._popup.setLatLng(this._latlng);\r\n\t\t\tthis._map.openPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttogglePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tif (this._popup._isOpen) {\r\n\t\t\t\tthis.closePopup();\r\n\t\t\t} else {\r\n\t\t\t\tthis.openPopup();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tvar anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);\r\n\r\n\t\tanchor = anchor.add(L.Popup.prototype.options.offset);\r\n\r\n\t\tif (options && options.offset) {\r\n\t\t\tanchor = anchor.add(options.offset);\r\n\t\t}\r\n\r\n\t\toptions = L.extend({offset: anchor}, options);\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this.togglePopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this)\r\n\t\t\t    .on('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tL.setOptions(content, options);\r\n\t\t\tthis._popup = content;\r\n\t\t\tcontent._source = this;\r\n\t\t} else {\r\n\t\t\tthis._popup = new L.Popup(options, this)\r\n\t\t\t\t.setContent(content);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetPopupContent: function (content) {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this.togglePopup, this)\r\n\t\t\t    .off('remove', this.closePopup, this)\r\n\t\t\t    .off('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPopup: function () {\r\n\t\treturn this._popup;\r\n\t},\r\n\r\n\t_movePopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LayerGroup is a class to combine several layers into one so that\r\n * you can manipulate the group (e.g. add/remove it) as one layer.\r\n */\r\n\r\nL.LayerGroup = L.Class.extend({\r\n\tinitialize: function (layers) {\r\n\t\tthis._layers = {};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (layers) {\r\n\t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\t\t\t\tthis.addLayer(layers[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tvar id = this.getLayerId(layer);\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.addLayer(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n\t\tif (this._map && this._layers[id]) {\r\n\t\t\tthis._map.removeLayer(this._layers[id]);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (layer in this._layers || this.getLayerId(layer) in this._layers);\r\n\t},\r\n\r\n\tclearLayers: function () {\r\n\t\tthis.eachLayer(this.removeLayer, this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvoke: function (methodName) {\r\n\t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, layer;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tlayer = this._layers[i];\r\n\r\n\t\t\tif (layer[methodName]) {\r\n\t\t\t\tlayer[methodName].apply(layer, args);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis.eachLayer(map.addLayer, map);\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis.eachLayer(map.removeLayer, map);\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetLayer: function (id) {\r\n\t\treturn this._layers[id];\r\n\t},\r\n\r\n\tgetLayers: function () {\r\n\t\tvar layers = [];\r\n\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tlayers.push(this._layers[i]);\r\n\t\t}\r\n\t\treturn layers;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\treturn this.invoke('setZIndex', zIndex);\r\n\t},\r\n\r\n\tgetLayerId: function (layer) {\r\n\t\treturn L.stamp(layer);\r\n\t}\r\n});\r\n\r\nL.layerGroup = function (layers) {\r\n\treturn new L.LayerGroup(layers);\r\n};\r\n\n\n/*\r\n * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\r\n * shared between a group of interactive layers (like vectors or markers).\r\n */\r\n\r\nL.FeatureGroup = L.LayerGroup.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tEVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tif (this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif ('on' in layer) {\r\n\t\t\tlayer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent && layer.bindPopup) {\r\n\t\t\tlayer.bindPopup(this._popupContent, this._popupOptions);\r\n\t\t}\r\n\r\n\t\treturn this.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tif (!this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif (layer in this._layers) {\r\n\t\t\tlayer = this._layers[layer];\r\n\t\t}\r\n\r\n\t\tif ('off' in layer) {\r\n\t\t\tlayer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent) {\r\n\t\t\tthis.invoke('unbindPopup');\r\n\t\t}\r\n\r\n\t\treturn this.fire('layerremove', {layer: layer});\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tthis._popupContent = content;\r\n\t\tthis._popupOptions = options;\r\n\t\treturn this.invoke('bindPopup', content, options);\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\t\t// open popup on the first layer\r\n\t\tfor (var id in this._layers) {\r\n\t\t\tthis._layers[id].openPopup(latlng);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\treturn this.invoke('setStyle', style);\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\treturn this.invoke('bringToFront');\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\treturn this.invoke('bringToBack');\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = new L.LatLngBounds();\r\n\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tbounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());\r\n\t\t});\r\n\r\n\t\treturn bounds;\r\n\t},\r\n\r\n\t_propagateEvent: function (e) {\r\n\t\te = L.extend({\r\n\t\t\tlayer: e.target,\r\n\t\t\ttarget: this\r\n\t\t}, e);\r\n\t\tthis.fire(e.type, e);\r\n\t}\r\n});\r\n\r\nL.featureGroup = function (layers) {\r\n\treturn new L.FeatureGroup(layers);\r\n};\r\n\n\n/*\r\n * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.\r\n */\r\n\r\nL.Path = L.Class.extend({\r\n\tincludes: [L.Mixin.Events],\r\n\r\n\tstatics: {\r\n\t\t// how much to extend the clip area around the map view\r\n\t\t// (relative to its size, e.g. 0.5 is half the screen in each direction)\r\n\t\t// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)\r\n\t\tCLIP_PADDING: (function () {\r\n\t\t\tvar max = L.Browser.mobile ? 1280 : 2000,\r\n\t\t\t    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;\r\n\t\t\treturn Math.max(0, Math.min(0.5, target));\r\n\t\t})()\r\n\t},\r\n\r\n\toptions: {\r\n\t\tstroke: true,\r\n\t\tcolor: '#0033ff',\r\n\t\tdashArray: null,\r\n\t\tlineCap: null,\r\n\t\tlineJoin: null,\r\n\t\tweight: 5,\r\n\t\topacity: 0.5,\r\n\r\n\t\tfill: false,\r\n\t\tfillColor: null, //same as color by default\r\n\t\tfillOpacity: 0.2,\r\n\r\n\t\tclickable: true\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initElements();\r\n\t\t\tthis._initEvents();\r\n\t\t}\r\n\r\n\t\tthis.projectLatlngs();\r\n\t\tthis._updatePath();\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._map._pathRoot.appendChild(this._container);\r\n\t\t}\r\n\r\n\t\tthis.fire('add');\r\n\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._pathRoot.removeChild(this._container);\r\n\r\n\t\t// Need to fire remove event before we set _map to null as the event hooks might need the object\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\r\n\t\tif (L.Browser.vml) {\r\n\t\t\tthis._container = null;\r\n\t\t\tthis._stroke = null;\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\t// do all projection stuff here\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._updateStyle();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._updatePath();\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_updatePathViewport: function () {\r\n\t\tvar p = L.Path.CLIP_PADDING,\r\n\t\t    size = this.getSize(),\r\n\t\t    panePos = L.DomUtil.getPosition(this._mapPane),\r\n\t\t    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),\r\n\t\t    max = min.add(size.multiplyBy(1 + p * 2)._round());\r\n\r\n\t\tthis._pathViewport = new L.Bounds(min, max);\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Path with SVG-specific rendering code.\r\n */\r\n\r\nL.Path.SVG_NS = 'http://www.w3.org/2000/svg';\r\n\r\nL.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);\r\n\r\nL.Path = L.Path.extend({\r\n\tstatics: {\r\n\t\tSVG: L.Browser.svg\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container;\r\n\r\n\t\tif (path && root.lastChild !== path) {\r\n\t\t\troot.appendChild(path);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container,\r\n\t\t    first = root.firstChild;\r\n\r\n\t\tif (path && first !== path) {\r\n\t\t\troot.insertBefore(path, first);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\t// form path string here\r\n\t},\r\n\r\n\t_createElement: function (name) {\r\n\t\treturn document.createElementNS(L.Path.SVG_NS, name);\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._initPath();\r\n\t\tthis._initStyle();\r\n\t},\r\n\r\n\t_initPath: function () {\r\n\t\tthis._container = this._createElement('g');\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\r\n\t\tif (this.options.className) {\r\n\t\t\tL.DomUtil.addClass(this._path, this.options.className);\r\n\t\t}\r\n\r\n\t\tthis._container.appendChild(this._path);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke-linejoin', 'round');\r\n\t\t\tthis._path.setAttribute('stroke-linecap', 'round');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill-rule', 'evenodd');\r\n\t\t}\r\n\t\tif (this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', this.options.pointerEvents);\r\n\t\t}\r\n\t\tif (!this.options.clickable && !this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', 'none');\r\n\t\t}\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke', this.options.color);\r\n\t\t\tthis._path.setAttribute('stroke-opacity', this.options.opacity);\r\n\t\t\tthis._path.setAttribute('stroke-width', this.options.weight);\r\n\t\t\tif (this.options.dashArray) {\r\n\t\t\t\tthis._path.setAttribute('stroke-dasharray', this.options.dashArray);\r\n\t\t\t} else {\r\n\t\t\t\tthis._path.removeAttribute('stroke-dasharray');\r\n\t\t\t}\r\n\t\t\tif (this.options.lineCap) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linecap', this.options.lineCap);\r\n\t\t\t}\r\n\t\t\tif (this.options.lineJoin) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linejoin', this.options.lineJoin);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('stroke', 'none');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill', this.options.fillColor || this.options.color);\r\n\t\t\tthis._path.setAttribute('fill-opacity', this.options.fillOpacity);\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('fill', 'none');\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar str = this.getPathString();\r\n\t\tif (!str) {\r\n\t\t\t// fix webkit empty string parsing bug\r\n\t\t\tstr = 'M0 0';\r\n\t\t}\r\n\t\tthis._path.setAttribute('d', str);\r\n\t},\r\n\r\n\t// TODO remove duplication with L.Map\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tif (L.Browser.svg || !L.Browser.vml) {\r\n\t\t\t\tL.DomUtil.addClass(this._path, 'leaflet-clickable');\r\n\t\t\t}\r\n\r\n\t\t\tL.DomEvent.on(this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\t\tvar events = ['dblclick', 'mousedown', 'mouseover',\r\n\t\t\t              'mouseout', 'mousemove', 'contextmenu'];\r\n\t\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\t\tL.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._map || !this.hasEventListeners(e.type)) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerPoint = map.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = map.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = map.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\r\n\t\tif (e.type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousemove') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_initPathRoot: function () {\r\n\t\tif (!this._pathRoot) {\r\n\t\t\tthis._pathRoot = L.Path.prototype._createElement('svg');\r\n\t\t\tthis._panes.overlayPane.appendChild(this._pathRoot);\r\n\r\n\t\t\tif (this.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');\r\n\r\n\t\t\t\tthis.on({\r\n\t\t\t\t\t'zoomanim': this._animatePathZoom,\r\n\t\t\t\t\t'zoomend': this._endPathZoom\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');\r\n\t\t\t}\r\n\r\n\t\t\tthis.on('moveend', this._updateSvgViewport);\r\n\t\t\tthis._updateSvgViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_animatePathZoom: function (e) {\r\n\t\tvar scale = this.getZoomScale(e.zoom),\r\n\t\t    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);\r\n\r\n\t\tthis._pathRoot.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';\r\n\r\n\t\tthis._pathZooming = true;\r\n\t},\r\n\r\n\t_endPathZoom: function () {\r\n\t\tthis._pathZooming = false;\r\n\t},\r\n\r\n\t_updateSvgViewport: function () {\r\n\r\n\t\tif (this._pathZooming) {\r\n\t\t\t// Do not update SVGs while a zoom animation is going on otherwise the animation will break.\r\n\t\t\t// When the zoom animation ends we will be updated again anyway\r\n\t\t\t// This fixes the case where you do a momentum move and zoom while the move is still ongoing.\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    max = vp.max,\r\n\t\t    width = max.x - min.x,\r\n\t\t    height = max.y - min.y,\r\n\t\t    root = this._pathRoot,\r\n\t\t    pane = this._panes.overlayPane;\r\n\r\n\t\t// Hack to make flicker on drag end on mobile webkit less irritating\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.removeChild(root);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.setAttribute('width', width);\r\n\t\troot.setAttribute('height', height);\r\n\t\troot.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));\r\n\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.appendChild(root);\r\n\t\t}\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.\r\n */\r\n\r\nL.Path.include({\r\n\r\n\tbindPopup: function (content, options) {\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tthis._popup = content;\r\n\t\t} else {\r\n\t\t\tif (!this._popup || options) {\r\n\t\t\t\tthis._popup = new L.Popup(options, this);\r\n\t\t\t}\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this._openPopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this);\r\n\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this._openPopup)\r\n\t\t\t    .off('remove', this.closePopup);\r\n\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\r\n\t\tif (this._popup) {\r\n\t\t\t// open the popup from one of the path's points if not specified\r\n\t\t\tlatlng = latlng || this._latlng ||\r\n\t\t\t         this._latlngs[Math.floor(this._latlngs.length / 2)];\r\n\r\n\t\t\tthis._openPopup({latlng: latlng});\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_openPopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t\tthis._map.openPopup(this._popup);\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for IE6-8 through VML.\r\n * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\r\n */\r\n\r\nL.Browser.vml = !L.Browser.svg && (function () {\r\n\ttry {\r\n\t\tvar div = document.createElement('div');\r\n\t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\r\n\r\n\t\tvar shape = div.firstChild;\r\n\t\tshape.style.behavior = 'url(#default#VML)';\r\n\r\n\t\treturn shape && (typeof shape.adj === 'object');\r\n\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t}\r\n}());\r\n\r\nL.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\tVML: true,\r\n\t\tCLIP_PADDING: 0.02\r\n\t},\r\n\r\n\t_createElement: (function () {\r\n\t\ttry {\r\n\t\t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\r\n\t\t\t};\r\n\t\t} catch (e) {\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement(\r\n\t\t\t\t        '<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\r\n\t\t\t};\r\n\t\t}\r\n\t}()),\r\n\r\n\t_initPath: function () {\r\n\t\tvar container = this._container = this._createElement('shape');\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-vml-shape' +\r\n\t\t\t(this.options.className ? ' ' + this.options.className : ''));\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tL.DomUtil.addClass(container, 'leaflet-clickable');\r\n\t\t}\r\n\r\n\t\tcontainer.coordsize = '1 1';\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\t\tcontainer.appendChild(this._path);\r\n\r\n\t\tthis._map._pathRoot.appendChild(container);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar stroke = this._stroke,\r\n\t\t    fill = this._fill,\r\n\t\t    options = this.options,\r\n\t\t    container = this._container;\r\n\r\n\t\tcontainer.stroked = options.stroke;\r\n\t\tcontainer.filled = options.fill;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tif (!stroke) {\r\n\t\t\t\tstroke = this._stroke = this._createElement('stroke');\r\n\t\t\t\tstroke.endcap = 'round';\r\n\t\t\t\tcontainer.appendChild(stroke);\r\n\t\t\t}\r\n\t\t\tstroke.weight = options.weight + 'px';\r\n\t\t\tstroke.color = options.color;\r\n\t\t\tstroke.opacity = options.opacity;\r\n\r\n\t\t\tif (options.dashArray) {\r\n\t\t\t\tstroke.dashStyle = L.Util.isArray(options.dashArray) ?\r\n\t\t\t\t    options.dashArray.join(' ') :\r\n\t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\r\n\t\t\t} else {\r\n\t\t\t\tstroke.dashStyle = '';\r\n\t\t\t}\r\n\t\t\tif (options.lineCap) {\r\n\t\t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\r\n\t\t\t}\r\n\t\t\tif (options.lineJoin) {\r\n\t\t\t\tstroke.joinstyle = options.lineJoin;\r\n\t\t\t}\r\n\r\n\t\t} else if (stroke) {\r\n\t\t\tcontainer.removeChild(stroke);\r\n\t\t\tthis._stroke = null;\r\n\t\t}\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tif (!fill) {\r\n\t\t\t\tfill = this._fill = this._createElement('fill');\r\n\t\t\t\tcontainer.appendChild(fill);\r\n\t\t\t}\r\n\t\t\tfill.color = options.fillColor || options.color;\r\n\t\t\tfill.opacity = options.fillOpacity;\r\n\r\n\t\t} else if (fill) {\r\n\t\t\tcontainer.removeChild(fill);\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar style = this._container.style;\r\n\r\n\t\tstyle.display = 'none';\r\n\t\tthis._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug\r\n\t\tstyle.display = '';\r\n\t}\r\n});\r\n\r\nL.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tif (this._pathRoot) { return; }\r\n\r\n\t\tvar root = this._pathRoot = document.createElement('div');\r\n\t\troot.className = 'leaflet-vml-container';\r\n\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\tthis.on('moveend', this._updatePathViewport);\r\n\t\tthis._updatePathViewport();\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for all browsers that support canvas.\r\n */\r\n\r\nL.Browser.canvas = (function () {\r\n\treturn !!document.createElement('canvas').getContext;\r\n}());\r\n\r\nL.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\t//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value\r\n\t\tCANVAS: true,\r\n\t\tSVG: false\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateStyle();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('viewreset', this.projectLatlngs, this)\r\n\t\t    .off('moveend', this._updatePath, this);\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.off('click', this._onClick, this);\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\r\n\t\tthis._requestUpdate();\r\n\t\t\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\t_requestUpdate: function () {\r\n\t\tif (this._map && !L.Path._updateRequest) {\r\n\t\t\tL.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMapMoveEnd: function () {\r\n\t\tL.Path._updateRequest = null;\r\n\t\tthis.fire('moveend');\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._ctx = this._map._canvasCtx;\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tthis._ctx.lineWidth = options.weight;\r\n\t\t\tthis._ctx.strokeStyle = options.color;\r\n\t\t}\r\n\t\tif (options.fill) {\r\n\t\t\tthis._ctx.fillStyle = options.fillColor || options.color;\r\n\t\t}\r\n\r\n\t\tif (options.lineCap) {\r\n\t\t\tthis._ctx.lineCap = options.lineCap;\r\n\t\t}\r\n\t\tif (options.lineJoin) {\r\n\t\t\tthis._ctx.lineJoin = options.lineJoin;\r\n\t\t}\r\n\t},\r\n\r\n\t_drawPath: function () {\r\n\t\tvar i, j, len, len2, point, drawMethod;\r\n\r\n\t\tthis._ctx.beginPath();\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tfor (j = 0, len2 = this._parts[i].length; j < len2; j++) {\r\n\t\t\t\tpoint = this._parts[i][j];\r\n\t\t\t\tdrawMethod = (j === 0 ? 'move' : 'line') + 'To';\r\n\r\n\t\t\t\tthis._ctx[drawMethod](point.x, point.y);\r\n\t\t\t}\r\n\t\t\t// TODO refactor ugly hack\r\n\t\t\tif (this instanceof L.Polygon) {\r\n\t\t\t\tthis._ctx.closePath();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\treturn !this._parts.length;\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (this._checkIfEmpty()) { return; }\r\n\r\n\t\tvar ctx = this._ctx,\r\n\t\t    options = this.options;\r\n\r\n\t\tthis._drawPath();\r\n\t\tctx.save();\r\n\t\tthis._updateStyle();\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tctx.globalAlpha = options.fillOpacity;\r\n\t\t\tctx.fill(options.fillRule || 'evenodd');\r\n\t\t}\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tctx.globalAlpha = options.opacity;\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\r\n\t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t\tthis._map.on('click dblclick contextmenu', this._fireMouseEvent, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis.fire(e.type, e);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tif (!this._map || this._map._animatingZoom) { return; }\r\n\r\n\t\t// TODO don't do on each move\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis._ctx.canvas.style.cursor = 'pointer';\r\n\t\t\tthis._mouseInside = true;\r\n\t\t\tthis.fire('mouseover', e);\r\n\r\n\t\t} else if (this._mouseInside) {\r\n\t\t\tthis._ctx.canvas.style.cursor = '';\r\n\t\t\tthis._mouseInside = false;\r\n\t\t\tthis.fire('mouseout', e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tvar root = this._pathRoot,\r\n\t\t    ctx;\r\n\r\n\t\tif (!root) {\r\n\t\t\troot = this._pathRoot = document.createElement('canvas');\r\n\t\t\troot.style.position = 'absolute';\r\n\t\t\tctx = this._canvasCtx = root.getContext('2d');\r\n\r\n\t\t\tctx.lineCap = 'round';\r\n\t\t\tctx.lineJoin = 'round';\r\n\r\n\t\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\t\tif (this.options.zoomAnimation) {\r\n\t\t\t\tthis._pathRoot.className = 'leaflet-zoom-animated';\r\n\t\t\t\tthis.on('zoomanim', this._animatePathZoom);\r\n\t\t\t\tthis.on('zoomend', this._endPathZoom);\r\n\t\t\t}\r\n\t\t\tthis.on('moveend', this._updateCanvasViewport);\r\n\t\t\tthis._updateCanvasViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_updateCanvasViewport: function () {\r\n\t\t// don't redraw while zooming. See _updateSvgViewport for more details\r\n\t\tif (this._pathZooming) { return; }\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    size = vp.max.subtract(min),\r\n\t\t    root = this._pathRoot;\r\n\r\n\t\t//TODO check if this works properly on mobile webkit\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.width = size.x;\r\n\t\troot.height = size.y;\r\n\t\troot.getContext('2d').translate(-min.x, -min.y);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LineUtil contains different utility functions for line segments\r\n * and polylines (clipping, simplification, distances, etc.)\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations for this file\r\n\r\nL.LineUtil = {\r\n\r\n\t// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n\t// Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n\tsimplify: function (/*Point[]*/ points, /*Number*/ tolerance) {\r\n\t\tif (!tolerance || !points.length) {\r\n\t\t\treturn points.slice();\r\n\t\t}\r\n\r\n\t\tvar sqTolerance = tolerance * tolerance;\r\n\r\n\t\t// stage 1: vertex reduction\r\n\t\tpoints = this._reducePoints(points, sqTolerance);\r\n\r\n\t\t// stage 2: Douglas-Peucker simplification\r\n\t\tpoints = this._simplifyDP(points, sqTolerance);\r\n\r\n\t\treturn points;\r\n\t},\r\n\r\n\t// distance from a point to a segment between two points\r\n\tpointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\r\n\t},\r\n\r\n\tclosestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn this._sqClosestPointOnSegment(p, p1, p2);\r\n\t},\r\n\r\n\t// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\n\t_simplifyDP: function (points, sqTolerance) {\r\n\r\n\t\tvar len = points.length,\r\n\t\t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n\t\t    markers = new ArrayConstructor(len);\r\n\r\n\t\tmarkers[0] = markers[len - 1] = 1;\r\n\r\n\t\tthis._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n\t\tvar i,\r\n\t\t    newPoints = [];\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (markers[i]) {\r\n\t\t\t\tnewPoints.push(points[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newPoints;\r\n\t},\r\n\r\n\t_simplifyDPStep: function (points, markers, sqTolerance, first, last) {\r\n\r\n\t\tvar maxSqDist = 0,\r\n\t\t    index, i, sqDist;\r\n\r\n\t\tfor (i = first + 1; i <= last - 1; i++) {\r\n\t\t\tsqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n\t\t\tif (sqDist > maxSqDist) {\r\n\t\t\t\tindex = i;\r\n\t\t\t\tmaxSqDist = sqDist;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (maxSqDist > sqTolerance) {\r\n\t\t\tmarkers[index] = 1;\r\n\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, first, index);\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, index, last);\r\n\t\t}\r\n\t},\r\n\r\n\t// reduce points that are too close to each other to a single point\r\n\t_reducePoints: function (points, sqTolerance) {\r\n\t\tvar reducedPoints = [points[0]];\r\n\r\n\t\tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n\t\t\tif (this._sqDist(points[i], points[prev]) > sqTolerance) {\r\n\t\t\t\treducedPoints.push(points[i]);\r\n\t\t\t\tprev = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (prev < len - 1) {\r\n\t\t\treducedPoints.push(points[len - 1]);\r\n\t\t}\r\n\t\treturn reducedPoints;\r\n\t},\r\n\r\n\t// Cohen-Sutherland line clipping algorithm.\r\n\t// Used to avoid rendering parts of a polyline that are not currently visible.\r\n\r\n\tclipSegment: function (a, b, bounds, useLastCode) {\r\n\t\tvar codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\r\n\t\t    codeB = this._getBitCode(b, bounds),\r\n\r\n\t\t    codeOut, p, newCode;\r\n\r\n\t\t// save 2nd code to avoid calculating it on the next segment\r\n\t\tthis._lastCode = codeB;\r\n\r\n\t\twhile (true) {\r\n\t\t\t// if a,b is inside the clip window (trivial accept)\r\n\t\t\tif (!(codeA | codeB)) {\r\n\t\t\t\treturn [a, b];\r\n\t\t\t// if a,b is outside the clip window (trivial reject)\r\n\t\t\t} else if (codeA & codeB) {\r\n\t\t\t\treturn false;\r\n\t\t\t// other cases\r\n\t\t\t} else {\r\n\t\t\t\tcodeOut = codeA || codeB;\r\n\t\t\t\tp = this._getEdgeIntersection(a, b, codeOut, bounds);\r\n\t\t\t\tnewCode = this._getBitCode(p, bounds);\r\n\r\n\t\t\t\tif (codeOut === codeA) {\r\n\t\t\t\t\ta = p;\r\n\t\t\t\t\tcodeA = newCode;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tb = p;\r\n\t\t\t\t\tcodeB = newCode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getEdgeIntersection: function (a, b, code, bounds) {\r\n\t\tvar dx = b.x - a.x,\r\n\t\t    dy = b.y - a.y,\r\n\t\t    min = bounds.min,\r\n\t\t    max = bounds.max;\r\n\r\n\t\tif (code & 8) { // top\r\n\t\t\treturn new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);\r\n\t\t} else if (code & 4) { // bottom\r\n\t\t\treturn new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);\r\n\t\t} else if (code & 2) { // right\r\n\t\t\treturn new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);\r\n\t\t} else if (code & 1) { // left\r\n\t\t\treturn new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);\r\n\t\t}\r\n\t},\r\n\r\n\t_getBitCode: function (/*Point*/ p, bounds) {\r\n\t\tvar code = 0;\r\n\r\n\t\tif (p.x < bounds.min.x) { // left\r\n\t\t\tcode |= 1;\r\n\t\t} else if (p.x > bounds.max.x) { // right\r\n\t\t\tcode |= 2;\r\n\t\t}\r\n\t\tif (p.y < bounds.min.y) { // bottom\r\n\t\t\tcode |= 4;\r\n\t\t} else if (p.y > bounds.max.y) { // top\r\n\t\t\tcode |= 8;\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\t},\r\n\r\n\t// square distance (to avoid unnecessary Math.sqrt calls)\r\n\t_sqDist: function (p1, p2) {\r\n\t\tvar dx = p2.x - p1.x,\r\n\t\t    dy = p2.y - p1.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\t},\r\n\r\n\t// return closest point on segment or distance to that point\r\n\t_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\r\n\t\tvar x = p1.x,\r\n\t\t    y = p1.y,\r\n\t\t    dx = p2.x - x,\r\n\t\t    dy = p2.y - y,\r\n\t\t    dot = dx * dx + dy * dy,\r\n\t\t    t;\r\n\r\n\t\tif (dot > 0) {\r\n\t\t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n\t\t\tif (t > 1) {\r\n\t\t\t\tx = p2.x;\r\n\t\t\t\ty = p2.y;\r\n\t\t\t} else if (t > 0) {\r\n\t\t\t\tx += dx * t;\r\n\t\t\t\ty += dy * t;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdx = p.x - x;\r\n\t\tdy = p.y - y;\r\n\r\n\t\treturn sqDist ? dx * dx + dy * dy : new L.Point(x, y);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.Polyline is used to display polylines on a map.\r\n */\r\n\r\nL.Polyline = L.Path.extend({\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t},\r\n\r\n\toptions: {\r\n\t\t// how much to simplify the polyline on each zoom level\r\n\t\t// more = better performance and smoother look, less = more accurate\r\n\t\tsmoothFactor: 1.0,\r\n\t\tnoClip: false\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._originalPoints = [];\r\n\r\n\t\tfor (var i = 0, len = this._latlngs.length; i < len; i++) {\r\n\t\t\tthis._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);\r\n\t\t}\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tfor (var i = 0, len = this._parts.length, str = ''; i < len; i++) {\r\n\t\t\tstr += this._getPathPartStr(this._parts[i]);\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\tgetLatLngs: function () {\r\n\t\treturn this._latlngs;\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\taddLatLng: function (latlng) {\r\n\t\tthis._latlngs.push(L.latLng(latlng));\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tspliceLatLngs: function () { // (Number index, Number howMany)\r\n\t\tvar removed = [].splice.apply(this._latlngs, arguments);\r\n\t\tthis._convertLatLngs(this._latlngs, true);\r\n\t\tthis.redraw();\r\n\t\treturn removed;\r\n\t},\r\n\r\n\tclosestLayerPoint: function (p) {\r\n\t\tvar minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;\r\n\r\n\t\tfor (var j = 0, jLen = parts.length; j < jLen; j++) {\r\n\t\t\tvar points = parts[j];\r\n\t\t\tfor (var i = 1, len = points.length; i < len; i++) {\r\n\t\t\t\tp1 = points[i - 1];\r\n\t\t\t\tp2 = points[i];\r\n\t\t\t\tvar sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);\r\n\t\t\t\tif (sqDist < minDistance) {\r\n\t\t\t\t\tminDistance = sqDist;\r\n\t\t\t\t\tminPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (minPoint) {\r\n\t\t\tminPoint.distance = Math.sqrt(minDistance);\r\n\t\t}\r\n\t\treturn minPoint;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\treturn new L.LatLngBounds(this.getLatLngs());\r\n\t},\r\n\r\n\t_convertLatLngs: function (latlngs, overwrite) {\r\n\t\tvar i, len, target = overwrite ? latlngs : [];\r\n\r\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\r\n\t\t\tif (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttarget[i] = L.latLng(latlngs[i]);\r\n\t\t}\r\n\t\treturn target;\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tL.Path.prototype._initEvents.call(this);\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar round = L.Path.VML;\r\n\r\n\t\tfor (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {\r\n\t\t\tp = points[j];\r\n\t\t\tif (round) {\r\n\t\t\t\tp._round();\r\n\t\t\t}\r\n\t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    len = points.length,\r\n\t\t    i, k, segment;\r\n\r\n\t\tif (this.options.noClip) {\r\n\t\t\tthis._parts = [points];\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._parts = [];\r\n\r\n\t\tvar parts = this._parts,\r\n\t\t    vp = this._map._pathViewport,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (i = 0, k = 0; i < len - 1; i++) {\r\n\t\t\tsegment = lu.clipSegment(points[i], points[i + 1], vp, i);\r\n\t\t\tif (!segment) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tparts[k] = parts[k] || [];\r\n\t\t\tparts[k].push(segment[0]);\r\n\r\n\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\r\n\t\t\tif ((segment[1] !== points[i + 1]) || (i === len - 2)) {\r\n\t\t\t\tparts[k].push(segment[1]);\r\n\t\t\t\tk++;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// simplify each clipped part of the polyline\r\n\t_simplifyPoints: function () {\r\n\t\tvar parts = this._parts,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (var i = 0, len = parts.length; i < len; i++) {\r\n\t\t\tparts[i] = lu.simplify(parts[i], this.options.smoothFactor);\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._clipPoints();\r\n\t\tthis._simplifyPoints();\r\n\r\n\t\tL.Path.prototype._updatePath.call(this);\r\n\t}\r\n});\r\n\r\nL.polyline = function (latlngs, options) {\r\n\treturn new L.Polyline(latlngs, options);\r\n};\r\n\n\n/*\r\n * L.PolyUtil contains utility functions for polygons (clipping, etc.).\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations here\r\n\r\nL.PolyUtil = {};\r\n\r\n/*\r\n * Sutherland-Hodgeman polygon clipping algorithm.\r\n * Used to avoid rendering parts of a polygon that are not currently visible.\r\n */\r\nL.PolyUtil.clipPolygon = function (points, bounds) {\r\n\tvar clippedPoints,\r\n\t    edges = [1, 4, 2, 8],\r\n\t    i, j, k,\r\n\t    a, b,\r\n\t    len, edge, p,\r\n\t    lu = L.LineUtil;\r\n\r\n\tfor (i = 0, len = points.length; i < len; i++) {\r\n\t\tpoints[i]._code = lu._getBitCode(points[i], bounds);\r\n\t}\r\n\r\n\t// for each edge (left, bottom, right, top)\r\n\tfor (k = 0; k < 4; k++) {\r\n\t\tedge = edges[k];\r\n\t\tclippedPoints = [];\r\n\r\n\t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n\t\t\ta = points[i];\r\n\t\t\tb = points[j];\r\n\r\n\t\t\t// if a is inside the clip window\r\n\t\t\tif (!(a._code & edge)) {\r\n\t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n\t\t\t\tif (b._code & edge) {\r\n\t\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\t\tclippedPoints.push(p);\r\n\t\t\t\t}\r\n\t\t\t\tclippedPoints.push(a);\r\n\r\n\t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n\t\t\t} else if (!(b._code & edge)) {\r\n\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\tclippedPoints.push(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpoints = clippedPoints;\r\n\t}\r\n\r\n\treturn points;\r\n};\r\n\n\n/*\r\n * L.Polygon is used to display polygons on a map.\r\n */\r\n\r\nL.Polygon = L.Polyline.extend({\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Polyline.prototype.initialize.call(this, latlngs, options);\r\n\t\tthis._initWithHoles(latlngs);\r\n\t},\r\n\r\n\t_initWithHoles: function (latlngs) {\r\n\t\tvar i, len, hole;\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._latlngs = this._convertLatLngs(latlngs[0]);\r\n\t\t\tthis._holes = latlngs.slice(1);\r\n\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = this._holes[i] = this._convertLatLngs(this._holes[i]);\r\n\t\t\t\tif (hole[0].equals(hole[hole.length - 1])) {\r\n\t\t\t\t\thole.pop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// filter out last point if its equal to the first one\r\n\t\tlatlngs = this._latlngs;\r\n\r\n\t\tif (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {\r\n\t\t\tlatlngs.pop();\r\n\t\t}\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tL.Polyline.prototype.projectLatlngs.call(this);\r\n\r\n\t\t// project polygon holes points\r\n\t\t// TODO move this logic to Polyline to get rid of duplication\r\n\t\tthis._holePoints = [];\r\n\r\n\t\tif (!this._holes) { return; }\r\n\r\n\t\tvar i, j, len, len2;\r\n\r\n\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\tthis._holePoints[i] = [];\r\n\r\n\t\t\tfor (j = 0, len2 = this._holes[i].length; j < len2; j++) {\r\n\t\t\t\tthis._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._initWithHoles(latlngs);\r\n\t\t\treturn this.redraw();\r\n\t\t} else {\r\n\t\t\treturn L.Polyline.prototype.setLatLngs.call(this, latlngs);\r\n\t\t}\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    newParts = [];\r\n\r\n\t\tthis._parts = [points].concat(this._holePoints);\r\n\r\n\t\tif (this.options.noClip) { return; }\r\n\r\n\t\tfor (var i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tvar clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);\r\n\t\t\tif (clipped.length) {\r\n\t\t\t\tnewParts.push(clipped);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._parts = newParts;\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar str = L.Polyline.prototype._getPathPartStr.call(this, points);\r\n\t\treturn str + (L.Browser.svg ? 'z' : 'x');\r\n\t}\r\n});\r\n\r\nL.polygon = function (latlngs, options) {\r\n\treturn new L.Polygon(latlngs, options);\r\n};\r\n\n\n/*\r\n * Contains L.MultiPolyline and L.MultiPolygon layers.\r\n */\r\n\r\n(function () {\r\n\tfunction createMulti(Klass) {\r\n\r\n\t\treturn L.FeatureGroup.extend({\r\n\r\n\t\t\tinitialize: function (latlngs, options) {\r\n\t\t\t\tthis._layers = {};\r\n\t\t\t\tthis._options = options;\r\n\t\t\t\tthis.setLatLngs(latlngs);\r\n\t\t\t},\r\n\r\n\t\t\tsetLatLngs: function (latlngs) {\r\n\t\t\t\tvar i = 0,\r\n\t\t\t\t    len = latlngs.length;\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tif (i < len) {\r\n\t\t\t\t\t\tlayer.setLatLngs(latlngs[i++]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.removeLayer(layer);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\twhile (i < len) {\r\n\t\t\t\t\tthis.addLayer(new Klass(latlngs[i++], this._options));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\tgetLatLngs: function () {\r\n\t\t\t\tvar latlngs = [];\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tlatlngs.push(layer.getLatLngs());\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn latlngs;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tL.MultiPolyline = createMulti(L.Polyline);\r\n\tL.MultiPolygon = createMulti(L.Polygon);\r\n\r\n\tL.multiPolyline = function (latlngs, options) {\r\n\t\treturn new L.MultiPolyline(latlngs, options);\r\n\t};\r\n\r\n\tL.multiPolygon = function (latlngs, options) {\r\n\t\treturn new L.MultiPolygon(latlngs, options);\r\n\t};\r\n}());\r\n\n\n/*\r\n * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\r\n */\r\n\r\nL.Rectangle = L.Polygon.extend({\r\n\tinitialize: function (latLngBounds, options) {\r\n\t\tL.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\r\n\t},\r\n\r\n\tsetBounds: function (latLngBounds) {\r\n\t\tthis.setLatLngs(this._boundsToLatLngs(latLngBounds));\r\n\t},\r\n\r\n\t_boundsToLatLngs: function (latLngBounds) {\r\n\t\tlatLngBounds = L.latLngBounds(latLngBounds);\r\n\t\treturn [\r\n\t\t\tlatLngBounds.getSouthWest(),\r\n\t\t\tlatLngBounds.getNorthWest(),\r\n\t\t\tlatLngBounds.getNorthEast(),\r\n\t\t\tlatLngBounds.getSouthEast()\r\n\t\t];\r\n\t}\r\n});\r\n\r\nL.rectangle = function (latLngBounds, options) {\r\n\treturn new L.Rectangle(latLngBounds, options);\r\n};\r\n\n\n/*\r\n * L.Circle is a circle overlay (with a certain radius in meters).\r\n */\r\n\r\nL.Circle = L.Path.extend({\r\n\tinitialize: function (latlng, radius, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tthis._mRadius = radius;\r\n\t},\r\n\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis._mRadius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latlng = this._latlng,\r\n\t\t    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);\r\n\r\n\t\tthis._point = this._map.latLngToLayerPoint(latlng);\r\n\t\tthis._radius = Math.max(this._point.x - pointLeft.x, 1);\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latRadius = (this._mRadius / 40075017) * 360,\r\n\t\t    latlng = this._latlng;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        [latlng.lat - latRadius, latlng.lng - lngRadius],\r\n\t\t        [latlng.lat + latRadius, latlng.lng + lngRadius]);\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tvar p = this._point,\r\n\t\t    r = this._radius;\r\n\r\n\t\tif (this._checkIfEmpty()) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tif (L.Browser.svg) {\r\n\t\t\treturn 'M' + p.x + ',' + (p.y - r) +\r\n\t\t\t       'A' + r + ',' + r + ',0,1,1,' +\r\n\t\t\t       (p.x - 0.1) + ',' + (p.y - r) + ' z';\r\n\t\t} else {\r\n\t\t\tp._round();\r\n\t\t\tr = Math.round(r);\r\n\t\t\treturn 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);\r\n\t\t}\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._mRadius;\r\n\t},\r\n\r\n\t// TODO Earth hardcoded, move into projection code!\r\n\r\n\t_getLatRadius: function () {\r\n\t\treturn (this._mRadius / 40075017) * 360;\r\n\t},\r\n\r\n\t_getLngRadius: function () {\r\n\t\treturn this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\tif (!this._map) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tvar vp = this._map._pathViewport,\r\n\t\t    r = this._radius,\r\n\t\t    p = this._point;\r\n\r\n\t\treturn p.x - r > vp.max.x || p.y - r > vp.max.y ||\r\n\t\t       p.x + r < vp.min.x || p.y + r < vp.min.y;\r\n\t}\r\n});\r\n\r\nL.circle = function (latlng, radius, options) {\r\n\treturn new L.Circle(latlng, radius, options);\r\n};\r\n\n\n/*\r\n * L.CircleMarker is a circle overlay with a permanent pixel radius.\r\n */\r\n\r\nL.CircleMarker = L.Circle.extend({\r\n\toptions: {\r\n\t\tradius: 10,\r\n\t\tweight: 2\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.Circle.prototype.initialize.call(this, latlng, null, options);\r\n\t\tthis._radius = this.options.radius;\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\r\n\t},\r\n\r\n\t_updateStyle : function () {\r\n\t\tL.Circle.prototype._updateStyle.call(this);\r\n\t\tthis.setRadius(this.options.radius);\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tL.Circle.prototype.setLatLng.call(this, latlng);\r\n\t\tif (this._popup && this._popup._isOpen) {\r\n\t\t\tthis._popup.setLatLng(latlng);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis.options.radius = this._radius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._radius;\r\n\t}\r\n});\r\n\r\nL.circleMarker = function (latlng, options) {\r\n\treturn new L.CircleMarker(latlng, options);\r\n};\r\n\n\n/*\r\n * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.\r\n */\r\n\r\nL.Polyline.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p, closed) {\r\n\t\tvar i, j, k, len, len2, dist, part,\r\n\t\t    w = this.options.weight / 2;\r\n\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tw += 10; // polyline click tolerance on touch devices\r\n\t\t}\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tif (!closed && (j === 0)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);\r\n\r\n\t\t\t\tif (dist <= w) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.\r\n */\r\n\r\nL.Polygon.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p) {\r\n\t\tvar inside = false,\r\n\t\t    part, p1, p2,\r\n\t\t    i, j, k,\r\n\t\t    len, len2;\r\n\r\n\t\t// TODO optimization: check if within bounds first\r\n\r\n\t\tif (L.Polyline.prototype._containsPoint.call(this, p, true)) {\r\n\t\t\t// click on polygon border\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// ray casting algorithm for detecting if point is in polygon\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tp1 = part[j];\r\n\t\t\t\tp2 = part[k];\r\n\r\n\t\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) &&\r\n\t\t\t\t\t\t(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\r\n\t\t\t\t\tinside = !inside;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn inside;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Circle with Canvas-specific code.\r\n */\r\n\r\nL.Circle.include(!L.Path.CANVAS ? {} : {\r\n\t_drawPath: function () {\r\n\t\tvar p = this._point;\r\n\t\tthis._ctx.beginPath();\r\n\t\tthis._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);\r\n\t},\r\n\r\n\t_containsPoint: function (p) {\r\n\t\tvar center = this._point,\r\n\t\t    w2 = this.options.stroke ? this.options.weight / 2 : 0;\r\n\r\n\t\treturn (p.distanceTo(center) <= this._radius + w2);\r\n\t}\r\n});\r\n\n\n/*\n * CircleMarker canvas specific drawing parts.\n */\n\nL.CircleMarker.include(!L.Path.CANVAS ? {} : {\n\t_updateStyle: function () {\n\t\tL.Path.prototype._updateStyle.call(this);\n\t}\n});\n\n\n/*\r\n * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\r\n */\r\n\r\nL.GeoJSON = L.FeatureGroup.extend({\r\n\r\n\tinitialize: function (geojson, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\r\n\t\tif (geojson) {\r\n\t\t\tthis.addData(geojson);\r\n\t\t}\r\n\t},\r\n\r\n\taddData: function (geojson) {\r\n\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\r\n\t\t    i, len, feature;\r\n\r\n\t\tif (features) {\r\n\t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n\t\t\t\t// Only add this if geometry or geometries are set and not null\r\n\t\t\t\tfeature = features[i];\r\n\t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n\t\t\t\t\tthis.addData(features[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.filter && !options.filter(geojson)) { return; }\r\n\r\n\t\tvar layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);\r\n\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\r\n\r\n\t\tlayer.defaultOptions = layer.options;\r\n\t\tthis.resetStyle(layer);\r\n\r\n\t\tif (options.onEachFeature) {\r\n\t\t\toptions.onEachFeature(geojson, layer);\r\n\t\t}\r\n\r\n\t\treturn this.addLayer(layer);\r\n\t},\r\n\r\n\tresetStyle: function (layer) {\r\n\t\tvar style = this.options.style;\r\n\t\tif (style) {\r\n\t\t\t// reset any custom styles\r\n\t\t\tL.Util.extend(layer.options, layer.defaultOptions);\r\n\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}, this);\r\n\t},\r\n\r\n\t_setLayerStyle: function (layer, style) {\r\n\t\tif (typeof style === 'function') {\r\n\t\t\tstyle = style(layer.feature);\r\n\t\t}\r\n\t\tif (layer.setStyle) {\r\n\t\t\tlayer.setStyle(style);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.extend(L.GeoJSON, {\r\n\tgeometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {\r\n\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n\t\t    coords = geometry.coordinates,\r\n\t\t    layers = [],\r\n\t\t    latlng, latlngs, i, len;\r\n\r\n\t\tcoordsToLatLng = coordsToLatLng || this.coordsToLatLng;\r\n\r\n\t\tswitch (geometry.type) {\r\n\t\tcase 'Point':\r\n\t\t\tlatlng = coordsToLatLng(coords);\r\n\t\t\treturn pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\r\n\r\n\t\tcase 'MultiPoint':\r\n\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\t\tlatlng = coordsToLatLng(coords[i]);\r\n\t\t\t\tlayers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tcase 'LineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);\r\n\t\t\treturn new L.Polyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'Polygon':\r\n\t\t\tif (coords.length === 2 && !coords[1].length) {\r\n\t\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t\t}\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.Polygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiLineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiPolygon':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'GeometryCollection':\r\n\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n\r\n\t\t\t\tlayers.push(this.geometryToLayer({\r\n\t\t\t\t\tgeometry: geometry.geometries[i],\r\n\t\t\t\t\ttype: 'Feature',\r\n\t\t\t\t\tproperties: geojson.properties\r\n\t\t\t\t}, pointToLayer, coordsToLatLng, vectorOptions));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t}\r\n\t},\r\n\r\n\tcoordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng\r\n\t\treturn new L.LatLng(coords[1], coords[0], coords[2]);\r\n\t},\r\n\r\n\tcoordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array\r\n\t\tvar latlng, i, len,\r\n\t\t    latlngs = [];\r\n\r\n\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\tlatlng = levelsDeep ?\r\n\t\t\t        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :\r\n\t\t\t        (coordsToLatLng || this.coordsToLatLng)(coords[i]);\r\n\r\n\t\t\tlatlngs.push(latlng);\r\n\t\t}\r\n\r\n\t\treturn latlngs;\r\n\t},\r\n\r\n\tlatLngToCoords: function (latlng) {\r\n\t\tvar coords = [latlng.lng, latlng.lat];\r\n\r\n\t\tif (latlng.alt !== undefined) {\r\n\t\t\tcoords.push(latlng.alt);\r\n\t\t}\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tlatLngsToCoords: function (latLngs) {\r\n\t\tvar coords = [];\r\n\r\n\t\tfor (var i = 0, len = latLngs.length; i < len; i++) {\r\n\t\t\tcoords.push(L.GeoJSON.latLngToCoords(latLngs[i]));\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tgetFeature: function (layer, newGeometry) {\r\n\t\treturn layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);\r\n\t},\r\n\r\n\tasFeature: function (geoJSON) {\r\n\t\tif (geoJSON.type === 'Feature') {\r\n\t\t\treturn geoJSON;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: 'Feature',\r\n\t\t\tproperties: {},\r\n\t\t\tgeometry: geoJSON\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar PointToGeoJSON = {\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Point',\r\n\t\t\tcoordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\r\n\t\t});\r\n\t}\r\n};\r\n\r\nL.Marker.include(PointToGeoJSON);\r\nL.Circle.include(PointToGeoJSON);\r\nL.CircleMarker.include(PointToGeoJSON);\r\n\r\nL.Polyline.include({\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'LineString',\r\n\t\t\tcoordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())\r\n\t\t});\r\n\t}\r\n});\r\n\r\nL.Polygon.include({\r\n\ttoGeoJSON: function () {\r\n\t\tvar coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],\r\n\t\t    i, len, hole;\r\n\r\n\t\tcoords[0].push(coords[0][0]);\r\n\r\n\t\tif (this._holes) {\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = L.GeoJSON.latLngsToCoords(this._holes[i]);\r\n\t\t\t\thole.push(hole[0]);\r\n\t\t\t\tcoords.push(hole);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Polygon',\r\n\t\t\tcoordinates: coords\r\n\t\t});\r\n\t}\r\n});\r\n\r\n(function () {\r\n\tfunction multiToGeoJSON(type) {\r\n\t\treturn function () {\r\n\t\t\tvar coords = [];\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tcoords.push(layer.toGeoJSON().geometry.coordinates);\r\n\t\t\t});\r\n\r\n\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\ttype: type,\r\n\t\t\t\tcoordinates: coords\r\n\t\t\t});\r\n\t\t};\r\n\t}\r\n\r\n\tL.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});\r\n\tL.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});\r\n\r\n\tL.LayerGroup.include({\r\n\t\ttoGeoJSON: function () {\r\n\r\n\t\t\tvar geometry = this.feature && this.feature.geometry,\r\n\t\t\t\tjsons = [],\r\n\t\t\t\tjson;\r\n\r\n\t\t\tif (geometry && geometry.type === 'MultiPoint') {\r\n\t\t\t\treturn multiToGeoJSON('MultiPoint').call(this);\r\n\t\t\t}\r\n\r\n\t\t\tvar isGeometryCollection = geometry && geometry.type === 'GeometryCollection';\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tif (layer.toGeoJSON) {\r\n\t\t\t\t\tjson = layer.toGeoJSON();\r\n\t\t\t\t\tjsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (isGeometryCollection) {\r\n\t\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\t\tgeometries: jsons,\r\n\t\t\t\t\ttype: 'GeometryCollection'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\ttype: 'FeatureCollection',\r\n\t\t\t\tfeatures: jsons\r\n\t\t\t};\r\n\t\t}\r\n\t});\r\n}());\r\n\r\nL.geoJson = function (geojson, options) {\r\n\treturn new L.GeoJSON(geojson, options);\r\n};\r\n\n\n/*\r\n * L.DomEvent contains functions for working with DOM events.\r\n */\r\n\r\nL.DomEvent = {\r\n\t/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */\r\n\taddListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler, originalHandler, newType;\r\n\r\n\t\tif (obj[key]) { return this; }\r\n\r\n\t\thandler = function (e) {\r\n\t\t\treturn fn.call(context || obj, e || L.DomEvent._getEvent());\r\n\t\t};\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\treturn this.addPointerListener(obj, type, handler, id);\r\n\t\t}\r\n\t\tif (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {\r\n\t\t\tthis.addDoubleTapListener(obj, handler, id);\r\n\t\t}\r\n\r\n\t\tif ('addEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.addEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\tnewType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');\r\n\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\tif (!L.DomEvent._checkMouse(obj, e)) { return; }\r\n\t\t\t\t\treturn originalHandler(e);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(newType, handler, false);\r\n\r\n\t\t\t} else if (type === 'click' && L.Browser.android) {\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\treturn L.DomEvent._filterClick(e, originalHandler);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t}\r\n\r\n\t\t} else if ('attachEvent' in obj) {\r\n\t\t\tobj.attachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = handler;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveListener: function (obj, type, fn) {  // (HTMLElement, String, Function)\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler = obj[key];\r\n\r\n\t\tif (!handler) { return this; }\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\tthis.removePointerListener(obj, type, id);\r\n\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {\r\n\t\t\tthis.removeDoubleTapListener(obj, id);\r\n\r\n\t\t} else if ('removeEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.removeEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\t\t\t\tobj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\t\t\t}\r\n\t\t} else if ('detachEvent' in obj) {\r\n\t\t\tobj.detachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = null;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopPropagation: function (e) {\r\n\r\n\t\tif (e.stopPropagation) {\r\n\t\t\te.stopPropagation();\r\n\t\t} else {\r\n\t\t\te.cancelBubble = true;\r\n\t\t}\r\n\t\tL.DomEvent._skipped(e);\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdisableScrollPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'mousewheel', stop)\r\n\t\t\t.on(el, 'MozMousePixelScroll', stop);\r\n\t},\r\n\r\n\tdisableClickPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(el, L.Draggable.START[i], stop);\r\n\t\t}\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'click', L.DomEvent._fakeStop)\r\n\t\t\t.on(el, 'dblclick', stop);\r\n\t},\r\n\r\n\tpreventDefault: function (e) {\r\n\r\n\t\tif (e.preventDefault) {\r\n\t\t\te.preventDefault();\r\n\t\t} else {\r\n\t\t\te.returnValue = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstop: function (e) {\r\n\t\treturn L.DomEvent\r\n\t\t\t.preventDefault(e)\r\n\t\t\t.stopPropagation(e);\r\n\t},\r\n\r\n\tgetMousePosition: function (e, container) {\r\n\t\tif (!container) {\r\n\t\t\treturn new L.Point(e.clientX, e.clientY);\r\n\t\t}\r\n\r\n\t\tvar rect = container.getBoundingClientRect();\r\n\r\n\t\treturn new L.Point(\r\n\t\t\te.clientX - rect.left - container.clientLeft,\r\n\t\t\te.clientY - rect.top - container.clientTop);\r\n\t},\r\n\r\n\tgetWheelDelta: function (e) {\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif (e.wheelDelta) {\r\n\t\t\tdelta = e.wheelDelta / 120;\r\n\t\t}\r\n\t\tif (e.detail) {\r\n\t\t\tdelta = -e.detail / 3;\r\n\t\t}\r\n\t\treturn delta;\r\n\t},\r\n\r\n\t_skipEvents: {},\r\n\r\n\t_fakeStop: function (e) {\r\n\t\t// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\r\n\t\tL.DomEvent._skipEvents[e.type] = true;\r\n\t},\r\n\r\n\t_skipped: function (e) {\r\n\t\tvar skipped = this._skipEvents[e.type];\r\n\t\t// reset when checking, as it's only used in map container and propagates outside of the map\r\n\t\tthis._skipEvents[e.type] = false;\r\n\t\treturn skipped;\r\n\t},\r\n\r\n\t// check if element really left/entered the event target (for mouseenter/mouseleave)\r\n\t_checkMouse: function (el, e) {\r\n\r\n\t\tvar related = e.relatedTarget;\r\n\r\n\t\tif (!related) { return true; }\r\n\r\n\t\ttry {\r\n\t\t\twhile (related && (related !== el)) {\r\n\t\t\t\trelated = related.parentNode;\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn (related !== el);\r\n\t},\r\n\r\n\t_getEvent: function () { // evil magic for IE\r\n\t\t/*jshint noarg:false */\r\n\t\tvar e = window.event;\r\n\t\tif (!e) {\r\n\t\t\tvar caller = arguments.callee.caller;\r\n\t\t\twhile (caller) {\r\n\t\t\t\te = caller['arguments'][0];\r\n\t\t\t\tif (e && window.Event === e.constructor) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcaller = caller.caller;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn e;\r\n\t},\r\n\r\n\t// this is a horrible workaround for a bug in Android where a single touch triggers two click events\r\n\t_filterClick: function (e, handler) {\r\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t// on the same event should be triggered far faster;\r\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\r\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tL.DomEvent._lastClick = timeStamp;\r\n\r\n\t\treturn handler(e);\r\n\t}\r\n};\r\n\r\nL.DomEvent.on = L.DomEvent.addListener;\r\nL.DomEvent.off = L.DomEvent.removeListener;\r\n\n\n/*\r\n * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\r\n */\r\n\r\nL.Draggable = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tSTART: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\r\n\t\tEND: {\r\n\t\t\tmousedown: 'mouseup',\r\n\t\t\ttouchstart: 'touchend',\r\n\t\t\tpointerdown: 'touchend',\r\n\t\t\tMSPointerDown: 'touchend'\r\n\t\t},\r\n\t\tMOVE: {\r\n\t\t\tmousedown: 'mousemove',\r\n\t\t\ttouchstart: 'touchmove',\r\n\t\t\tpointerdown: 'touchmove',\r\n\t\t\tMSPointerDown: 'touchmove'\r\n\t\t}\r\n\t},\r\n\r\n\tinitialize: function (element, dragStartTarget) {\r\n\t\tthis._element = element;\r\n\t\tthis._dragStartTarget = dragStartTarget || element;\r\n\t},\r\n\r\n\tenable: function () {\r\n\t\tif (this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = true;\r\n\t},\r\n\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = false;\r\n\t\tthis._moved = false;\r\n\t},\r\n\r\n\t_onDown: function (e) {\r\n\t\tthis._moved = false;\r\n\r\n\t\tif (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\r\n\r\n\t\tL.DomEvent.stopPropagation(e);\r\n\r\n\t\tif (L.Draggable._disabled) { return; }\r\n\r\n\t\tL.DomUtil.disableImageDrag();\r\n\t\tL.DomUtil.disableTextSelection();\r\n\r\n\t\tif (this._moving) { return; }\r\n\r\n\t\tvar first = e.touches ? e.touches[0] : e;\r\n\r\n\t\tthis._startPoint = new L.Point(first.clientX, first.clientY);\r\n\t\tthis._startPos = this._newPos = L.DomUtil.getPosition(this._element);\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)\r\n\t\t    .on(document, L.Draggable.END[e.type], this._onUp, this);\r\n\t},\r\n\r\n\t_onMove: function (e) {\r\n\t\tif (e.touches && e.touches.length > 1) {\r\n\t\t\tthis._moved = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n\t\t    newPoint = new L.Point(first.clientX, first.clientY),\r\n\t\t    offset = newPoint.subtract(this._startPoint);\r\n\r\n\t\tif (!offset.x && !offset.y) { return; }\r\n\t\tif (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }\r\n\r\n\t\tL.DomEvent.preventDefault(e);\r\n\r\n\t\tif (!this._moved) {\r\n\t\t\tthis.fire('dragstart');\r\n\r\n\t\t\tthis._moved = true;\r\n\t\t\tthis._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\r\n\r\n\t\t\tL.DomUtil.addClass(document.body, 'leaflet-dragging');\r\n\t\t\tthis._lastTarget = e.target || e.srcElement;\r\n\t\t\tL.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t}\r\n\r\n\t\tthis._newPos = this._startPos.add(offset);\r\n\t\tthis._moving = true;\r\n\r\n\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\t\tthis._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tthis.fire('predrag');\r\n\t\tL.DomUtil.setPosition(this._element, this._newPos);\r\n\t\tthis.fire('drag');\r\n\t},\r\n\r\n\t_onUp: function () {\r\n\t\tL.DomUtil.removeClass(document.body, 'leaflet-dragging');\r\n\r\n\t\tif (this._lastTarget) {\r\n\t\t\tL.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t\tthis._lastTarget = null;\r\n\t\t}\r\n\r\n\t\tfor (var i in L.Draggable.MOVE) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(document, L.Draggable.MOVE[i], this._onMove)\r\n\t\t\t    .off(document, L.Draggable.END[i], this._onUp);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.enableImageDrag();\r\n\t\tL.DomUtil.enableTextSelection();\r\n\r\n\t\tif (this._moved && this._moving) {\r\n\t\t\t// ensure drag is not fired after dragend\r\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\r\n\t\t\tthis.fire('dragend', {\r\n\t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._moving = false;\r\n\t}\r\n});\r\n\n\n/*\n\tL.Handler is a base class for handler classes that are used internally to inject\n\tinteraction features like dragging to classes like Map and Marker.\n*/\n\nL.Handler = L.Class.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t},\n\n\tenable: function () {\n\t\tif (this._enabled) { return; }\n\n\t\tthis._enabled = true;\n\t\tthis.addHooks();\n\t},\n\n\tdisable: function () {\n\t\tif (!this._enabled) { return; }\n\n\t\tthis._enabled = false;\n\t\tthis.removeHooks();\n\t},\n\n\tenabled: function () {\n\t\treturn !!this._enabled;\n\t}\n});\n\n\n/*\n * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdragging: true,\n\n\tinertia: !L.Browser.android23,\n\tinertiaDeceleration: 3400, // px/s^2\n\tinertiaMaxSpeed: Infinity, // px/s\n\tinertiaThreshold: L.Browser.touch ? 32 : 18, // ms\n\teaseLinearity: 0.25,\n\n\t// TODO refactor, move to CRS\n\tworldCopyJump: false\n});\n\nL.Map.Drag = L.Handler.extend({\n\taddHooks: function () {\n\t\tif (!this._draggable) {\n\t\t\tvar map = this._map;\n\n\t\t\tthis._draggable = new L.Draggable(map._mapPane, map._container);\n\n\t\t\tthis._draggable.on({\n\t\t\t\t'dragstart': this._onDragStart,\n\t\t\t\t'drag': this._onDrag,\n\t\t\t\t'dragend': this._onDragEnd\n\t\t\t}, this);\n\n\t\t\tif (map.options.worldCopyJump) {\n\t\t\t\tthis._draggable.on('predrag', this._onPreDrag, this);\n\t\t\t\tmap.on('viewreset', this._onViewReset, this);\n\n\t\t\t\tmap.whenReady(this._onViewReset, this);\n\t\t\t}\n\t\t}\n\t\tthis._draggable.enable();\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable.disable();\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tvar map = this._map;\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tmap\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\n\t\tif (map.options.inertia) {\n\t\t\tthis._positions = [];\n\t\t\tthis._times = [];\n\t\t}\n\t},\n\n\t_onDrag: function () {\n\t\tif (this._map.options.inertia) {\n\t\t\tvar time = this._lastTime = +new Date(),\n\t\t\t    pos = this._lastPos = this._draggable._newPos;\n\n\t\t\tthis._positions.push(pos);\n\t\t\tthis._times.push(time);\n\n\t\t\tif (time - this._times[0] > 200) {\n\t\t\t\tthis._positions.shift();\n\t\t\t\tthis._times.shift();\n\t\t\t}\n\t\t}\n\n\t\tthis._map\n\t\t    .fire('move')\n\t\t    .fire('drag');\n\t},\n\n\t_onViewReset: function () {\n\t\t// TODO fix hardcoded Earth values\n\t\tvar pxCenter = this._map.getSize()._divideBy(2),\n\t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n\t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n\t\tthis._worldWidth = this._map.project([0, 180]).x;\n\t},\n\n\t_onPreDrag: function () {\n\t\t// TODO refactor to be able to adjust map pane position after zoom\n\t\tvar worldWidth = this._worldWidth,\n\t\t    halfWidth = Math.round(worldWidth / 2),\n\t\t    dx = this._initialWorldOffset,\n\t\t    x = this._draggable._newPos.x,\n\t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n\t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n\t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n\t\tthis._draggable._newPos.x = newX;\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tvar map = this._map,\n\t\t    options = map.options,\n\t\t    delay = +new Date() - this._lastTime,\n\n\t\t    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];\n\n\t\tmap.fire('dragend', e);\n\n\t\tif (noInertia) {\n\t\t\tmap.fire('moveend');\n\n\t\t} else {\n\n\t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n\t\t\t    duration = (this._lastTime + delay - this._times[0]) / 1000,\n\t\t\t    ease = options.easeLinearity,\n\n\t\t\t    speedVector = direction.multiplyBy(ease / duration),\n\t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n\t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n\t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n\t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n\t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n\t\t\tif (!offset.x || !offset.y) {\n\t\t\t\tmap.fire('moveend');\n\n\t\t\t} else {\n\t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n\t\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\t\tmap.panBy(offset, {\n\t\t\t\t\t\tduration: decelerationDuration,\n\t\t\t\t\t\teaseLinearity: ease,\n\t\t\t\t\t\tnoMoveStart: true\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\n\n/*\n * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdoubleClickZoom: true\n});\n\nL.Map.DoubleClickZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tthis._map.on('dblclick', this._onDoubleClick, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._map.off('dblclick', this._onDoubleClick, this);\n\t},\n\n\t_onDoubleClick: function (e) {\n\t\tvar map = this._map,\n\t\t    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);\n\n\t\tif (map.options.doubleClickZoom === 'center') {\n\t\t\tmap.setZoom(zoom);\n\t\t} else {\n\t\t\tmap.setZoomAround(e.containerPoint, zoom);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\n\n/*\n * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n */\n\nL.Map.mergeOptions({\n\tscrollWheelZoom: true\n});\n\nL.Map.ScrollWheelZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n\t\tL.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t\tthis._delta = 0;\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);\n\t\tL.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t},\n\n\t_onWheelScroll: function (e) {\n\t\tvar delta = L.DomEvent.getWheelDelta(e);\n\n\t\tthis._delta += delta;\n\t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n\t\tif (!this._startTime) {\n\t\t\tthis._startTime = +new Date();\n\t\t}\n\n\t\tvar left = Math.max(40 - (+new Date() - this._startTime), 0);\n\n\t\tclearTimeout(this._timer);\n\t\tthis._timer = setTimeout(L.bind(this._performZoom, this), left);\n\n\t\tL.DomEvent.preventDefault(e);\n\t\tL.DomEvent.stopPropagation(e);\n\t},\n\n\t_performZoom: function () {\n\t\tvar map = this._map,\n\t\t    delta = this._delta,\n\t\t    zoom = map.getZoom();\n\n\t\tdelta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\t\tdelta = Math.max(Math.min(delta, 4), -4);\n\t\tdelta = map._limitZoom(zoom + delta) - zoom;\n\n\t\tthis._delta = 0;\n\t\tthis._startTime = null;\n\n\t\tif (!delta) { return; }\n\n\t\tif (map.options.scrollWheelZoom === 'center') {\n\t\t\tmap.setZoom(zoom + delta);\n\t\t} else {\n\t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\n\n/*\r\n * Extends the event handling code with double tap support for mobile browsers.\r\n */\r\n\r\nL.extend(L.DomEvent, {\r\n\r\n\t_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\r\n\t_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\r\n\r\n\t// inspired by Zepto touch code by Thomas Fuchs\r\n\taddDoubleTapListener: function (obj, handler, id) {\r\n\t\tvar last,\r\n\t\t    doubleTap = false,\r\n\t\t    delay = 250,\r\n\t\t    touch,\r\n\t\t    pre = '_leaflet_',\r\n\t\t    touchstart = this._touchstart,\r\n\t\t    touchend = this._touchend,\r\n\t\t    trackedTouches = [];\r\n\r\n\t\tfunction onTouchStart(e) {\r\n\t\t\tvar count;\r\n\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\ttrackedTouches.push(e.pointerId);\r\n\t\t\t\tcount = trackedTouches.length;\r\n\t\t\t} else {\r\n\t\t\t\tcount = e.touches.length;\r\n\t\t\t}\r\n\t\t\tif (count > 1) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar now = Date.now(),\r\n\t\t\t\tdelta = now - (last || now);\r\n\r\n\t\t\ttouch = e.touches ? e.touches[0] : e;\r\n\t\t\tdoubleTap = (delta > 0 && delta <= delay);\r\n\t\t\tlast = now;\r\n\t\t}\r\n\r\n\t\tfunction onTouchEnd(e) {\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\tvar idx = trackedTouches.indexOf(e.pointerId);\r\n\t\t\t\tif (idx === -1) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\ttrackedTouches.splice(idx, 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (doubleTap) {\r\n\t\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\t\t// work around .type being readonly with MSPointer* events\r\n\t\t\t\t\tvar newTouch = { },\r\n\t\t\t\t\t\tprop;\r\n\r\n\t\t\t\t\t// jshint forin:false\r\n\t\t\t\t\tfor (var i in touch) {\r\n\t\t\t\t\t\tprop = touch[i];\r\n\t\t\t\t\t\tif (typeof prop === 'function') {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop.bind(touch);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttouch = newTouch;\r\n\t\t\t\t}\r\n\t\t\t\ttouch.type = 'dblclick';\r\n\t\t\t\thandler(touch);\r\n\t\t\t\tlast = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tobj[pre + touchstart + id] = onTouchStart;\r\n\t\tobj[pre + touchend + id] = onTouchEnd;\r\n\r\n\t\t// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen\r\n\t\t// will not come through to us, so we will lose track of how many touches are ongoing\r\n\t\tvar endElement = L.Browser.pointer ? document.documentElement : obj;\r\n\r\n\t\tobj.addEventListener(touchstart, onTouchStart, false);\r\n\t\tendElement.addEventListener(touchend, onTouchEnd, false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tendElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveDoubleTapListener: function (obj, id) {\r\n\t\tvar pre = '_leaflet_';\r\n\r\n\t\tobj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\r\n\t\t(L.Browser.pointer ? document.documentElement : obj).removeEventListener(\r\n\t\t        this._touchend, obj[pre + this._touchend + id], false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tdocument.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],\r\n\t\t\t\tfalse);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\n * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n */\n\nL.extend(L.DomEvent, {\n\n\t//static\n\tPOINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',\n\tPOINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',\n\tPOINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',\n\tPOINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n\n\t_pointers: [],\n\t_pointerDocumentListener: false,\n\n\t// Provides a touch events wrapper for (ms)pointer events.\n\t// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019\n\t//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n\taddPointerListener: function (obj, type, handler, id) {\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\treturn this.addPointerListenerStart(obj, type, handler, id);\n\t\tcase 'touchend':\n\t\t\treturn this.addPointerListenerEnd(obj, type, handler, id);\n\t\tcase 'touchmove':\n\t\t\treturn this.addPointerListenerMove(obj, type, handler, id);\n\t\tdefault:\n\t\t\tthrow 'Unknown touch event type';\n\t\t}\n\t},\n\n\taddPointerListenerStart: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    pointers = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tif (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n\t\t\t\tL.DomEvent.preventDefault(e);\n\t\t\t}\n\n\t\t\tvar alreadyInArray = false;\n\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\talreadyInArray = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!alreadyInArray) {\n\t\t\t\tpointers.push(e);\n\t\t\t}\n\n\t\t\te.touches = pointers.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchstart' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_DOWN, cb, false);\n\n\t\t// need to also listen for end events to keep the _pointers list accurate\n\t\t// this needs to be on the body and never go away\n\t\tif (!this._pointerDocumentListener) {\n\t\t\tvar internalCb = function (e) {\n\t\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\t\tpointers.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_UP, internalCb, false);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);\n\n\t\t\tthis._pointerDocumentListener = true;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerMove: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tfunction cb(e) {\n\n\t\t\t// don't fire touch moves when mouse isn't down\n\t\t\tif ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }\n\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches[i] = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t}\n\n\t\tobj[pre + 'touchmove' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_MOVE, cb, false);\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerEnd: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchend' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_UP, cb, false);\n\t\tobj.addEventListener(this.POINTER_CANCEL, cb, false);\n\n\t\treturn this;\n\t},\n\n\tremovePointerListener: function (obj, type, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    cb = obj[pre + type + id];\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\tobj.removeEventListener(this.POINTER_DOWN, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchmove':\n\t\t\tobj.removeEventListener(this.POINTER_MOVE, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchend':\n\t\t\tobj.removeEventListener(this.POINTER_UP, cb, false);\n\t\t\tobj.removeEventListener(this.POINTER_CANCEL, cb, false);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\n\n/*\n * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n */\n\nL.Map.mergeOptions({\n\ttouchZoom: L.Browser.touch && !L.Browser.android23,\n\tbounceAtZoomLimits: true\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]),\n\t\t    viewCenter = map._getCenterLayerPoint();\n\n\t\tthis._startCenter = p1.add(p2)._divideBy(2);\n\t\tthis._startDist = p1.distanceTo(p2);\n\n\t\tthis._moved = false;\n\t\tthis._zooming = true;\n\n\t\tthis._centerOffset = viewCenter.subtract(this._startCenter);\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(document, 'touchmove', this._onTouchMove, this)\n\t\t    .on(document, 'touchend', this._onTouchEnd, this);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]);\n\n\t\tthis._scale = p1.distanceTo(p2) / this._startDist;\n\t\tthis._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);\n\n\t\tif (this._scale === 1) { return; }\n\n\t\tif (!map.options.bounceAtZoomLimits) {\n\t\t\tif ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||\n\t\t\t    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }\n\t\t}\n\n\t\tif (!this._moved) {\n\t\t\tL.DomUtil.addClass(map._mapPane, 'leaflet-touching');\n\n\t\t\tmap\n\t\t\t    .fire('movestart')\n\t\t\t    .fire('zoomstart');\n\n\t\t\tthis._moved = true;\n\t\t}\n\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\t\tthis._animRequest = L.Util.requestAnimFrame(\n\t\t        this._updateOnMove, this, true, this._map._container);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_updateOnMove: function () {\n\t\tvar map = this._map,\n\t\t    origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\t\t    zoom = map.getScaleZoom(this._scale);\n\n\t\tmap._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);\n\t},\n\n\t_onTouchEnd: function () {\n\t\tif (!this._moved || !this._zooming) {\n\t\t\tthis._zooming = false;\n\t\t\treturn;\n\t\t}\n\n\t\tvar map = this._map;\n\n\t\tthis._zooming = false;\n\t\tL.DomUtil.removeClass(map._mapPane, 'leaflet-touching');\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\tL.DomEvent\n\t\t    .off(document, 'touchmove', this._onTouchMove)\n\t\t    .off(document, 'touchend', this._onTouchEnd);\n\n\t\tvar origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\n\t\t    oldZoom = map.getZoom(),\n\t\t    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,\n\t\t    roundZoomDelta = (floatZoomDelta > 0 ?\n\t\t            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),\n\n\t\t    zoom = map._limitZoom(oldZoom + roundZoomDelta),\n\t\t    scale = map.getZoomScale(zoom) / this._scale;\n\n\t\tmap._animateZoom(center, zoom, origin, scale);\n\t},\n\n\t_getScaleOrigin: function () {\n\t\tvar centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);\n\t\treturn this._startCenter.add(centerOffset);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\n\n/*\n * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n */\n\nL.Map.mergeOptions({\n\ttap: true,\n\ttapTolerance: 15\n});\n\nL.Map.Tap = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\t_onDown: function (e) {\n\t\tif (!e.touches) { return; }\n\n\t\tL.DomEvent.preventDefault(e);\n\n\t\tthis._fireClick = true;\n\n\t\t// don't simulate click or track longpress if more than 1 touch\n\t\tif (e.touches.length > 1) {\n\t\t\tthis._fireClick = false;\n\t\t\tclearTimeout(this._holdTimeout);\n\t\t\treturn;\n\t\t}\n\n\t\tvar first = e.touches[0],\n\t\t    el = first.target;\n\n\t\tthis._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\n\t\t// if touching a link, highlight it\n\t\tif (el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\tL.DomUtil.addClass(el, 'leaflet-active');\n\t\t}\n\n\t\t// simulate long hold but setting a timeout\n\t\tthis._holdTimeout = setTimeout(L.bind(function () {\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._fireClick = false;\n\t\t\t\tthis._onUp();\n\t\t\t\tthis._simulateEvent('contextmenu', first);\n\t\t\t}\n\t\t}, this), 1000);\n\n\t\tL.DomEvent\n\t\t\t.on(document, 'touchmove', this._onMove, this)\n\t\t\t.on(document, 'touchend', this._onUp, this);\n\t},\n\n\t_onUp: function (e) {\n\t\tclearTimeout(this._holdTimeout);\n\n\t\tL.DomEvent\n\t\t\t.off(document, 'touchmove', this._onMove, this)\n\t\t\t.off(document, 'touchend', this._onUp, this);\n\n\t\tif (this._fireClick && e && e.changedTouches) {\n\n\t\t\tvar first = e.changedTouches[0],\n\t\t\t    el = first.target;\n\n\t\t\tif (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\t\tL.DomUtil.removeClass(el, 'leaflet-active');\n\t\t\t}\n\n\t\t\t// simulate click if the touch didn't move too much\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._simulateEvent('click', first);\n\t\t\t}\n\t\t}\n\t},\n\n\t_isTapValid: function () {\n\t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n\t},\n\n\t_onMove: function (e) {\n\t\tvar first = e.touches[0];\n\t\tthis._newPos = new L.Point(first.clientX, first.clientY);\n\t},\n\n\t_simulateEvent: function (type, e) {\n\t\tvar simulatedEvent = document.createEvent('MouseEvents');\n\n\t\tsimulatedEvent._simulated = true;\n\t\te.target._simulatedClick = true;\n\n\t\tsimulatedEvent.initMouseEvent(\n\t\t        type, true, true, window, 1,\n\t\t        e.screenX, e.screenY,\n\t\t        e.clientX, e.clientY,\n\t\t        false, false, false, false, 0, null);\n\n\t\te.target.dispatchEvent(simulatedEvent);\n\t}\n});\n\nif (L.Browser.touch && !L.Browser.pointer) {\n\tL.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n}\n\n\n/*\n * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n  * (zoom to a selected bounding box), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tboxZoom: true\n});\n\nL.Map.BoxZoom = L.Handler.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._pane = map._panes.overlayPane;\n\t\tthis._moved = false;\n\t},\n\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._container, 'mousedown', this._onMouseDown);\n\t\tthis._moved = false;\n\t},\n\n\tmoved: function () {\n\t\treturn this._moved;\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tthis._moved = false;\n\n\t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n\t\tL.DomUtil.disableTextSelection();\n\t\tL.DomUtil.disableImageDrag();\n\n\t\tthis._startLayerPoint = this._map.mouseEventToLayerPoint(e);\n\n\t\tL.DomEvent\n\t\t    .on(document, 'mousemove', this._onMouseMove, this)\n\t\t    .on(document, 'mouseup', this._onMouseUp, this)\n\t\t    .on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._moved) {\n\t\t\tthis._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);\n\t\t\tL.DomUtil.setPosition(this._box, this._startLayerPoint);\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = 'crosshair';\n\t\t\tthis._map.fire('boxzoomstart');\n\t\t}\n\n\t\tvar startPoint = this._startLayerPoint,\n\t\t    box = this._box,\n\n\t\t    layerPoint = this._map.mouseEventToLayerPoint(e),\n\t\t    offset = layerPoint.subtract(startPoint),\n\n\t\t    newPos = new L.Point(\n\t\t        Math.min(layerPoint.x, startPoint.x),\n\t\t        Math.min(layerPoint.y, startPoint.y));\n\n\t\tL.DomUtil.setPosition(box, newPos);\n\n\t\tthis._moved = true;\n\n\t\t// TODO refactor: remove hardcoded 4 pixels\n\t\tbox.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';\n\t\tbox.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';\n\t},\n\n\t_finish: function () {\n\t\tif (this._moved) {\n\t\t\tthis._pane.removeChild(this._box);\n\t\t\tthis._container.style.cursor = '';\n\t\t}\n\n\t\tL.DomUtil.enableTextSelection();\n\t\tL.DomUtil.enableImageDrag();\n\n\t\tL.DomEvent\n\t\t    .off(document, 'mousemove', this._onMouseMove)\n\t\t    .off(document, 'mouseup', this._onMouseUp)\n\t\t    .off(document, 'keydown', this._onKeyDown);\n\t},\n\n\t_onMouseUp: function (e) {\n\n\t\tthis._finish();\n\n\t\tvar map = this._map,\n\t\t    layerPoint = map.mouseEventToLayerPoint(e);\n\n\t\tif (this._startLayerPoint.equals(layerPoint)) { return; }\n\n\t\tvar bounds = new L.LatLngBounds(\n\t\t        map.layerPointToLatLng(this._startLayerPoint),\n\t\t        map.layerPointToLatLng(layerPoint));\n\n\t\tmap.fitBounds(bounds);\n\n\t\tmap.fire('boxzoomend', {\n\t\t\tboxZoomBounds: bounds\n\t\t});\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tif (e.keyCode === 27) {\n\t\t\tthis._finish();\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\n\n/*\n * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tkeyboard: true,\n\tkeyboardPanOffset: 80,\n\tkeyboardZoomOffset: 1\n});\n\nL.Map.Keyboard = L.Handler.extend({\n\n\tkeyCodes: {\n\t\tleft:    [37],\n\t\tright:   [39],\n\t\tdown:    [40],\n\t\tup:      [38],\n\t\tzoomIn:  [187, 107, 61, 171],\n\t\tzoomOut: [189, 109, 173]\n\t},\n\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\n\t\tthis._setPanOffset(map.options.keyboardPanOffset);\n\t\tthis._setZoomOffset(map.options.keyboardZoomOffset);\n\t},\n\n\taddHooks: function () {\n\t\tvar container = this._map._container;\n\n\t\t// make the container focusable by tabbing\n\t\tif (container.tabIndex === -1) {\n\t\t\tcontainer.tabIndex = '0';\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(container, 'focus', this._onFocus, this)\n\t\t    .on(container, 'blur', this._onBlur, this)\n\t\t    .on(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .on('focus', this._addHooks, this)\n\t\t    .on('blur', this._removeHooks, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._removeHooks();\n\n\t\tvar container = this._map._container;\n\n\t\tL.DomEvent\n\t\t    .off(container, 'focus', this._onFocus, this)\n\t\t    .off(container, 'blur', this._onBlur, this)\n\t\t    .off(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .off('focus', this._addHooks, this)\n\t\t    .off('blur', this._removeHooks, this);\n\t},\n\n\t_onMouseDown: function () {\n\t\tif (this._focused) { return; }\n\n\t\tvar body = document.body,\n\t\t    docEl = document.documentElement,\n\t\t    top = body.scrollTop || docEl.scrollTop,\n\t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n\t\tthis._map._container.focus();\n\n\t\twindow.scrollTo(left, top);\n\t},\n\n\t_onFocus: function () {\n\t\tthis._focused = true;\n\t\tthis._map.fire('focus');\n\t},\n\n\t_onBlur: function () {\n\t\tthis._focused = false;\n\t\tthis._map.fire('blur');\n\t},\n\n\t_setPanOffset: function (pan) {\n\t\tvar keys = this._panKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n\t\t\tkeys[codes.left[i]] = [-1 * pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n\t\t\tkeys[codes.right[i]] = [pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n\t\t\tkeys[codes.down[i]] = [0, pan];\n\t\t}\n\t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n\t\t\tkeys[codes.up[i]] = [0, -1 * pan];\n\t\t}\n\t},\n\n\t_setZoomOffset: function (zoom) {\n\t\tvar keys = this._zoomKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n\t\t\tkeys[codes.zoomIn[i]] = zoom;\n\t\t}\n\t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n\t\t\tkeys[codes.zoomOut[i]] = -zoom;\n\t\t}\n\t},\n\n\t_addHooks: function () {\n\t\tL.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_removeHooks: function () {\n\t\tL.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tvar key = e.keyCode,\n\t\t    map = this._map;\n\n\t\tif (key in this._panKeys) {\n\n\t\t\tif (map._panAnim && map._panAnim._inProgress) { return; }\n\n\t\t\tmap.panBy(this._panKeys[key]);\n\n\t\t\tif (map.options.maxBounds) {\n\t\t\t\tmap.panInsideBounds(map.options.maxBounds);\n\t\t\t}\n\n\t\t} else if (key in this._zoomKeys) {\n\t\t\tmap.setZoom(map.getZoom() + this._zoomKeys[key]);\n\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tL.DomEvent.stop(e);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\n\n/*\n * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n */\n\nL.Handler.MarkerDrag = L.Handler.extend({\n\tinitialize: function (marker) {\n\t\tthis._marker = marker;\n\t},\n\n\taddHooks: function () {\n\t\tvar icon = this._marker._icon;\n\t\tif (!this._draggable) {\n\t\t\tthis._draggable = new L.Draggable(icon, icon);\n\t\t}\n\n\t\tthis._draggable\n\t\t\t.on('dragstart', this._onDragStart, this)\n\t\t\t.on('drag', this._onDrag, this)\n\t\t\t.on('dragend', this._onDragEnd, this);\n\t\tthis._draggable.enable();\n\t\tL.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable\n\t\t\t.off('dragstart', this._onDragStart, this)\n\t\t\t.off('drag', this._onDrag, this)\n\t\t\t.off('dragend', this._onDragEnd, this);\n\n\t\tthis._draggable.disable();\n\t\tL.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tthis._marker\n\t\t    .closePopup()\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\t},\n\n\t_onDrag: function () {\n\t\tvar marker = this._marker,\n\t\t    shadow = marker._shadow,\n\t\t    iconPos = L.DomUtil.getPosition(marker._icon),\n\t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n\t\t// update shadow position\n\t\tif (shadow) {\n\t\t\tL.DomUtil.setPosition(shadow, iconPos);\n\t\t}\n\n\t\tmarker._latlng = latlng;\n\n\t\tmarker\n\t\t    .fire('move', {latlng: latlng})\n\t\t    .fire('drag');\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tthis._marker\n\t\t    .fire('moveend')\n\t\t    .fire('dragend', e);\n\t}\n});\n\n\n/*\r\n * L.Control is a base class for implementing map controls. Handles positioning.\r\n * All other controls extend from this class.\r\n */\r\n\r\nL.Control = L.Class.extend({\r\n\toptions: {\r\n\t\tposition: 'topright'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\t\treturn this.options.position;\r\n\t},\r\n\r\n\tsetPosition: function (position) {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.removeControl(this);\r\n\t\t}\r\n\r\n\t\tthis.options.position = position;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.addControl(this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tvar container = this._container = this.onAdd(map),\r\n\t\t    pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-control');\r\n\r\n\t\tif (pos.indexOf('bottom') !== -1) {\r\n\t\t\tcorner.insertBefore(container, corner.firstChild);\r\n\t\t} else {\r\n\t\t\tcorner.appendChild(container);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveFrom: function (map) {\r\n\t\tvar pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tcorner.removeChild(this._container);\r\n\t\tthis._map = null;\r\n\r\n\t\tif (this.onRemove) {\r\n\t\t\tthis.onRemove(map);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_refocusOnMap: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.getContainer().focus();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.control = function (options) {\r\n\treturn new L.Control(options);\r\n};\r\n\r\n\r\n// adds control-related methods to L.Map\r\n\r\nL.Map.include({\r\n\taddControl: function (control) {\r\n\t\tcontrol.addTo(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveControl: function (control) {\r\n\t\tcontrol.removeFrom(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initControlPos: function () {\r\n\t\tvar corners = this._controlCorners = {},\r\n\t\t    l = 'leaflet-',\r\n\t\t    container = this._controlContainer =\r\n\t\t            L.DomUtil.create('div', l + 'control-container', this._container);\r\n\r\n\t\tfunction createCorner(vSide, hSide) {\r\n\t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\r\n\t\t\tcorners[vSide + hSide] = L.DomUtil.create('div', className, container);\r\n\t\t}\r\n\r\n\t\tcreateCorner('top', 'left');\r\n\t\tcreateCorner('top', 'right');\r\n\t\tcreateCorner('bottom', 'left');\r\n\t\tcreateCorner('bottom', 'right');\r\n\t},\r\n\r\n\t_clearControlPos: function () {\r\n\t\tthis._container.removeChild(this._controlContainer);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.Control.Zoom is used for the default zoom buttons on the map.\r\n */\r\n\r\nL.Control.Zoom = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'topleft',\r\n\t\tzoomInText: '+',\r\n\t\tzoomInTitle: 'Zoom in',\r\n\t\tzoomOutText: '-',\r\n\t\tzoomOutTitle: 'Zoom out'\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tvar zoomName = 'leaflet-control-zoom',\r\n\t\t    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');\r\n\r\n\t\tthis._map = map;\r\n\r\n\t\tthis._zoomInButton  = this._createButton(\r\n\t\t        this.options.zoomInText, this.options.zoomInTitle,\r\n\t\t        zoomName + '-in',  container, this._zoomIn,  this);\r\n\t\tthis._zoomOutButton = this._createButton(\r\n\t\t        this.options.zoomOutText, this.options.zoomOutTitle,\r\n\t\t        zoomName + '-out', container, this._zoomOut, this);\r\n\r\n\t\tthis._updateDisabled();\r\n\t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\t},\r\n\r\n\t_zoomIn: function (e) {\r\n\t\tthis._map.zoomIn(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_zoomOut: function (e) {\r\n\t\tthis._map.zoomOut(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_createButton: function (html, title, className, container, fn, context) {\r\n\t\tvar link = L.DomUtil.create('a', className, container);\r\n\t\tlink.innerHTML = html;\r\n\t\tlink.href = '#';\r\n\t\tlink.title = title;\r\n\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(link, 'click', stop)\r\n\t\t    .on(link, 'mousedown', stop)\r\n\t\t    .on(link, 'dblclick', stop)\r\n\t\t    .on(link, 'click', L.DomEvent.preventDefault)\r\n\t\t    .on(link, 'click', fn, context)\r\n\t\t    .on(link, 'click', this._refocusOnMap, context);\r\n\r\n\t\treturn link;\r\n\t},\r\n\r\n\t_updateDisabled: function () {\r\n\t\tvar map = this._map,\r\n\t\t\tclassName = 'leaflet-disabled';\r\n\r\n\t\tL.DomUtil.removeClass(this._zoomInButton, className);\r\n\t\tL.DomUtil.removeClass(this._zoomOutButton, className);\r\n\r\n\t\tif (map._zoom === map.getMinZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomOutButton, className);\r\n\t\t}\r\n\t\tif (map._zoom === map.getMaxZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomInButton, className);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tzoomControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.zoomControl) {\r\n\t\tthis.zoomControl = new L.Control.Zoom();\r\n\t\tthis.addControl(this.zoomControl);\r\n\t}\r\n});\r\n\r\nL.control.zoom = function (options) {\r\n\treturn new L.Control.Zoom(options);\r\n};\r\n\r\n\n\n/*\r\n * L.Control.Attribution is used for displaying attribution on the map (added by default).\r\n */\r\n\r\nL.Control.Attribution = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'bottomright',\r\n\t\tprefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._attributions = {};\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-control-attribution');\r\n\t\tL.DomEvent.disableClickPropagation(this._container);\r\n\r\n\t\tfor (var i in map._layers) {\r\n\t\t\tif (map._layers[i].getAttribution) {\r\n\t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerAdd, this)\r\n\t\t    .on('layerremove', this._onLayerRemove, this);\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerAdd)\r\n\t\t    .off('layerremove', this._onLayerRemove);\r\n\r\n\t},\r\n\r\n\tsetPrefix: function (prefix) {\r\n\t\tthis.options.prefix = prefix;\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (!this._attributions[text]) {\r\n\t\t\tthis._attributions[text] = 0;\r\n\t\t}\r\n\t\tthis._attributions[text]++;\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (this._attributions[text]) {\r\n\t\t\tthis._attributions[text]--;\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar attribs = [];\r\n\r\n\t\tfor (var i in this._attributions) {\r\n\t\t\tif (this._attributions[i]) {\r\n\t\t\t\tattribs.push(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar prefixAndAttribs = [];\r\n\r\n\t\tif (this.options.prefix) {\r\n\t\t\tprefixAndAttribs.push(this.options.prefix);\r\n\t\t}\r\n\t\tif (attribs.length) {\r\n\t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n\t\t}\r\n\r\n\t\tthis._container.innerHTML = prefixAndAttribs.join(' | ');\r\n\t},\r\n\r\n\t_onLayerAdd: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.addAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t},\r\n\r\n\t_onLayerRemove: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.removeAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tattributionControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.attributionControl) {\r\n\t\tthis.attributionControl = (new L.Control.Attribution()).addTo(this);\r\n\t}\r\n});\r\n\r\nL.control.attribution = function (options) {\r\n\treturn new L.Control.Attribution(options);\r\n};\r\n\n\n/*\n * L.Control.Scale is used for displaying metric/imperial scale on the map.\n */\n\nL.Control.Scale = L.Control.extend({\n\toptions: {\n\t\tposition: 'bottomleft',\n\t\tmaxWidth: 100,\n\t\tmetric: true,\n\t\timperial: true,\n\t\tupdateWhenIdle: false\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tvar className = 'leaflet-control-scale',\n\t\t    container = L.DomUtil.create('div', className),\n\t\t    options = this.options;\n\n\t\tthis._addScales(options, className, container);\n\n\t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t\tmap.whenReady(this._update, this);\n\n\t\treturn container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t},\n\n\t_addScales: function (options, className, container) {\n\t\tif (options.metric) {\n\t\t\tthis._mScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t\tif (options.imperial) {\n\t\t\tthis._iScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tvar bounds = this._map.getBounds(),\n\t\t    centerLat = bounds.getCenter().lat,\n\t\t    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),\n\t\t    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,\n\n\t\t    size = this._map.getSize(),\n\t\t    options = this.options,\n\t\t    maxMeters = 0;\n\n\t\tif (size.x > 0) {\n\t\t\tmaxMeters = dist * (options.maxWidth / size.x);\n\t\t}\n\n\t\tthis._updateScales(options, maxMeters);\n\t},\n\n\t_updateScales: function (options, maxMeters) {\n\t\tif (options.metric && maxMeters) {\n\t\t\tthis._updateMetric(maxMeters);\n\t\t}\n\n\t\tif (options.imperial && maxMeters) {\n\t\t\tthis._updateImperial(maxMeters);\n\t\t}\n\t},\n\n\t_updateMetric: function (maxMeters) {\n\t\tvar meters = this._getRoundNum(maxMeters);\n\n\t\tthis._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';\n\t\tthis._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\t},\n\n\t_updateImperial: function (maxMeters) {\n\t\tvar maxFeet = maxMeters * 3.2808399,\n\t\t    scale = this._iScale,\n\t\t    maxMiles, miles, feet;\n\n\t\tif (maxFeet > 5280) {\n\t\t\tmaxMiles = maxFeet / 5280;\n\t\t\tmiles = this._getRoundNum(maxMiles);\n\n\t\t\tscale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';\n\t\t\tscale.innerHTML = miles + ' mi';\n\n\t\t} else {\n\t\t\tfeet = this._getRoundNum(maxFeet);\n\n\t\t\tscale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';\n\t\t\tscale.innerHTML = feet + ' ft';\n\t\t}\n\t},\n\n\t_getScaleWidth: function (ratio) {\n\t\treturn Math.round(this.options.maxWidth * ratio) - 10;\n\t},\n\n\t_getRoundNum: function (num) {\n\t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n\t\t    d = num / pow10;\n\n\t\td = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n\n\t\treturn pow10 * d;\n\t}\n});\n\nL.control.scale = function (options) {\n\treturn new L.Control.Scale(options);\n};\n\n\n/*\r\n * L.Control.Layers is a control to allow users to switch between different layers on the map.\r\n */\r\n\r\nL.Control.Layers = L.Control.extend({\r\n\toptions: {\r\n\t\tcollapsed: true,\r\n\t\tposition: 'topright',\r\n\t\tautoZIndex: true\r\n\t},\r\n\r\n\tinitialize: function (baseLayers, overlays, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._lastZIndex = 0;\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tfor (var i in baseLayers) {\r\n\t\t\tthis._addLayer(baseLayers[i], i);\r\n\t\t}\r\n\r\n\t\tfor (i in overlays) {\r\n\t\t\tthis._addLayer(overlays[i], i, true);\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._initLayout();\r\n\t\tthis._update();\r\n\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerChange, this)\r\n\t\t    .on('layerremove', this._onLayerChange, this);\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerChange, this)\r\n\t\t    .off('layerremove', this._onLayerChange, this);\r\n\t},\r\n\r\n\taddBaseLayer: function (layer, name) {\r\n\t\tthis._addLayer(layer, name);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOverlay: function (layer, name) {\r\n\t\tthis._addLayer(layer, name, true);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\t\tdelete this._layers[id];\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar className = 'leaflet-control-layers',\r\n\t\t    container = this._container = L.DomUtil.create('div', className);\r\n\r\n\t\t//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released\r\n\t\tcontainer.setAttribute('aria-haspopup', true);\r\n\r\n\t\tif (!L.Browser.touch) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.disableClickPropagation(container)\r\n\t\t\t\t.disableScrollPropagation(container);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);\r\n\t\t}\r\n\r\n\t\tvar form = this._form = L.DomUtil.create('form', className + '-list');\r\n\r\n\t\tif (this.options.collapsed) {\r\n\t\t\tif (!L.Browser.android) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(container, 'mouseover', this._expand, this)\r\n\t\t\t\t    .on(container, 'mouseout', this._collapse, this);\r\n\t\t\t}\r\n\t\t\tvar link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\r\n\t\t\tlink.href = '#';\r\n\t\t\tlink.title = 'Layers';\r\n\r\n\t\t\tif (L.Browser.touch) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(link, 'click', L.DomEvent.stop)\r\n\t\t\t\t    .on(link, 'click', this._expand, this);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tL.DomEvent.on(link, 'focus', this._expand, this);\r\n\t\t\t}\r\n\t\t\t//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033\r\n\t\t\tL.DomEvent.on(form, 'click', function () {\r\n\t\t\t\tsetTimeout(L.bind(this._onInputClick, this), 0);\r\n\t\t\t}, this);\r\n\r\n\t\t\tthis._map.on('click', this._collapse, this);\r\n\t\t\t// TODO keyboard accessibility\r\n\t\t} else {\r\n\t\t\tthis._expand();\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList = L.DomUtil.create('div', className + '-base', form);\r\n\t\tthis._separator = L.DomUtil.create('div', className + '-separator', form);\r\n\t\tthis._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\r\n\r\n\t\tcontainer.appendChild(form);\r\n\t},\r\n\r\n\t_addLayer: function (layer, name, overlay) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tthis._layers[id] = {\r\n\t\t\tlayer: layer,\r\n\t\t\tname: name,\r\n\t\t\toverlay: overlay\r\n\t\t};\r\n\r\n\t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n\t\t\tthis._lastZIndex++;\r\n\t\t\tlayer.setZIndex(this._lastZIndex);\r\n\t\t}\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._container) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList.innerHTML = '';\r\n\t\tthis._overlaysList.innerHTML = '';\r\n\r\n\t\tvar baseLayersPresent = false,\r\n\t\t    overlaysPresent = false,\r\n\t\t    i, obj;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tobj = this._layers[i];\r\n\t\t\tthis._addItem(obj);\r\n\t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n\t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n\t\t}\r\n\r\n\t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\t},\r\n\r\n\t_onLayerChange: function (e) {\r\n\t\tvar obj = this._layers[L.stamp(e.layer)];\r\n\r\n\t\tif (!obj) { return; }\r\n\r\n\t\tif (!this._handlingClick) {\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tvar type = obj.overlay ?\r\n\t\t\t(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :\r\n\t\t\t(e.type === 'layeradd' ? 'baselayerchange' : null);\r\n\r\n\t\tif (type) {\r\n\t\t\tthis._map.fire(type, obj);\r\n\t\t}\r\n\t},\r\n\r\n\t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\r\n\t_createRadioElement: function (name, checked) {\r\n\r\n\t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"';\r\n\t\tif (checked) {\r\n\t\t\tradioHtml += ' checked=\"checked\"';\r\n\t\t}\r\n\t\tradioHtml += '/>';\r\n\r\n\t\tvar radioFragment = document.createElement('div');\r\n\t\tradioFragment.innerHTML = radioHtml;\r\n\r\n\t\treturn radioFragment.firstChild;\r\n\t},\r\n\r\n\t_addItem: function (obj) {\r\n\t\tvar label = document.createElement('label'),\r\n\t\t    input,\r\n\t\t    checked = this._map.hasLayer(obj.layer);\r\n\r\n\t\tif (obj.overlay) {\r\n\t\t\tinput = document.createElement('input');\r\n\t\t\tinput.type = 'checkbox';\r\n\t\t\tinput.className = 'leaflet-control-layers-selector';\r\n\t\t\tinput.defaultChecked = checked;\r\n\t\t} else {\r\n\t\t\tinput = this._createRadioElement('leaflet-base-layers', checked);\r\n\t\t}\r\n\r\n\t\tinput.layerId = L.stamp(obj.layer);\r\n\r\n\t\tL.DomEvent.on(input, 'click', this._onInputClick, this);\r\n\r\n\t\tvar name = document.createElement('span');\r\n\t\tname.innerHTML = ' ' + obj.name;\r\n\r\n\t\tlabel.appendChild(input);\r\n\t\tlabel.appendChild(name);\r\n\r\n\t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n\t\tcontainer.appendChild(label);\r\n\r\n\t\treturn label;\r\n\t},\r\n\r\n\t_onInputClick: function () {\r\n\t\tvar i, input, obj,\r\n\t\t    inputs = this._form.getElementsByTagName('input'),\r\n\t\t    inputsLen = inputs.length;\r\n\r\n\t\tthis._handlingClick = true;\r\n\r\n\t\tfor (i = 0; i < inputsLen; i++) {\r\n\t\t\tinput = inputs[i];\r\n\t\t\tobj = this._layers[input.layerId];\r\n\r\n\t\t\tif (input.checked && !this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.addLayer(obj.layer);\r\n\r\n\t\t\t} else if (!input.checked && this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.removeLayer(obj.layer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tthis._refocusOnMap();\r\n\t},\r\n\r\n\t_expand: function () {\r\n\t\tL.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\r\n\t},\r\n\r\n\t_collapse: function () {\r\n\t\tthis._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');\r\n\t}\r\n});\r\n\r\nL.control.layers = function (baseLayers, overlays, options) {\r\n\treturn new L.Control.Layers(baseLayers, overlays, options);\r\n};\r\n\n\n/*\n * L.PosAnimation is used by Leaflet internally for pan animations.\n */\n\nL.PosAnimation = L.Class.extend({\n\tincludes: L.Mixin.Events,\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._newPos = newPos;\n\n\t\tthis.fire('start');\n\n\t\tel.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +\n\t\t        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';\n\n\t\tL.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\t\tL.DomUtil.setPosition(el, newPos);\n\n\t\t// toggle reflow, Chrome flickers for some reason if you don't do this\n\t\tL.Util.falseFn(el.offsetWidth);\n\n\t\t// there's no native way to track value updates of transitioned properties, so we imitate this\n\t\tthis._stepTimer = setInterval(L.bind(this._onStep, this), 50);\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\t// if we just removed the transition property, the element would jump to its final position,\n\t\t// so we need to make it stay at the current position\n\n\t\tL.DomUtil.setPosition(this._el, this._getPos());\n\t\tthis._onTransitionEnd();\n\t\tL.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation\n\t},\n\n\t_onStep: function () {\n\t\tvar stepPos = this._getPos();\n\t\tif (!stepPos) {\n\t\t\tthis._onTransitionEnd();\n\t\t\treturn;\n\t\t}\n\t\t// jshint camelcase: false\n\t\t// make L.DomUtil.getPosition return intermediate position value during animation\n\t\tthis._el._leaflet_pos = stepPos;\n\n\t\tthis.fire('step');\n\t},\n\n\t// you can't easily get intermediate values of properties animated with CSS3 Transitions,\n\t// we need to parse computed style (in case of transform it returns matrix string)\n\n\t_transformRe: /([-+]?(?:\\d*\\.)?\\d+)\\D*, ([-+]?(?:\\d*\\.)?\\d+)\\D*\\)/,\n\n\t_getPos: function () {\n\t\tvar left, top, matches,\n\t\t    el = this._el,\n\t\t    style = window.getComputedStyle(el);\n\n\t\tif (L.Browser.any3d) {\n\t\t\tmatches = style[L.DomUtil.TRANSFORM].match(this._transformRe);\n\t\t\tif (!matches) { return; }\n\t\t\tleft = parseFloat(matches[1]);\n\t\t\ttop  = parseFloat(matches[2]);\n\t\t} else {\n\t\t\tleft = parseFloat(style.left);\n\t\t\ttop  = parseFloat(style.top);\n\t\t}\n\n\t\treturn new L.Point(left, top, true);\n\t},\n\n\t_onTransitionEnd: function () {\n\t\tL.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\n\t\tif (!this._inProgress) { return; }\n\t\tthis._inProgress = false;\n\n\t\tthis._el.style[L.DomUtil.TRANSITION] = '';\n\n\t\t// jshint camelcase: false\n\t\t// make sure L.DomUtil.getPosition returns the final position value after animation\n\t\tthis._el._leaflet_pos = this._newPos;\n\n\t\tclearInterval(this._stepTimer);\n\n\t\tthis.fire('step').fire('end');\n\t}\n\n});\n\n\n/*\n * Extends L.Map to handle panning animations.\n */\n\nL.Map.include({\n\n\tsetView: function (center, zoom, options) {\n\n\t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n\t\tcenter = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n\t\toptions = options || {};\n\n\t\tif (this._panAnim) {\n\t\t\tthis._panAnim.stop();\n\t\t}\n\n\t\tif (this._loaded && !options.reset && options !== true) {\n\n\t\t\tif (options.animate !== undefined) {\n\t\t\t\toptions.zoom = L.extend({animate: options.animate}, options.zoom);\n\t\t\t\toptions.pan = L.extend({animate: options.animate}, options.pan);\n\t\t\t}\n\n\t\t\t// try animating pan or zoom\n\t\t\tvar animated = (this._zoom !== zoom) ?\n\t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\n\t\t\t\tthis._tryAnimatedPan(center, options.pan);\n\n\t\t\tif (animated) {\n\t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\n\t\t\t\tclearTimeout(this._sizeTimer);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// animation didn't start, just reset the map view\n\t\tthis._resetView(center, zoom);\n\n\t\treturn this;\n\t},\n\n\tpanBy: function (offset, options) {\n\t\toffset = L.point(offset).round();\n\t\toptions = options || {};\n\n\t\tif (!offset.x && !offset.y) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!this._panAnim) {\n\t\t\tthis._panAnim = new L.PosAnimation();\n\n\t\t\tthis._panAnim.on({\n\t\t\t\t'step': this._onPanTransitionStep,\n\t\t\t\t'end': this._onPanTransitionEnd\n\t\t\t}, this);\n\t\t}\n\n\t\t// don't fire movestart if animating inertia\n\t\tif (!options.noMoveStart) {\n\t\t\tthis.fire('movestart');\n\t\t}\n\n\t\t// animate pan unless animate: false specified\n\t\tif (options.animate !== false) {\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n\n\t\t\tvar newPos = this._getMapPanePos().subtract(offset);\n\t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n\t\t} else {\n\t\t\tthis._rawPanBy(offset);\n\t\t\tthis.fire('move').fire('moveend');\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_onPanTransitionStep: function () {\n\t\tthis.fire('move');\n\t},\n\n\t_onPanTransitionEnd: function () {\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n\t\tthis.fire('moveend');\n\t},\n\n\t_tryAnimatedPan: function (center, options) {\n\t\t// difference between the new and current centers in pixels\n\t\tvar offset = this._getCenterOffset(center)._floor();\n\n\t\t// don't animate too far unless animate: true specified in options\n\t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis.panBy(offset, options);\n\n\t\treturn true;\n\t}\n});\n\n\n/*\n * L.PosAnimation fallback implementation that powers Leaflet pan animations\n * in browsers that don't support CSS3 Transitions.\n */\n\nL.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._duration = duration || 0.25;\n\t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n\t\tthis._startPos = L.DomUtil.getPosition(el);\n\t\tthis._offset = newPos.subtract(this._startPos);\n\t\tthis._startTime = +new Date();\n\n\t\tthis.fire('start');\n\n\t\tthis._animate();\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\tthis._step();\n\t\tthis._complete();\n\t},\n\n\t_animate: function () {\n\t\t// animation loop\n\t\tthis._animId = L.Util.requestAnimFrame(this._animate, this);\n\t\tthis._step();\n\t},\n\n\t_step: function () {\n\t\tvar elapsed = (+new Date()) - this._startTime,\n\t\t    duration = this._duration * 1000;\n\n\t\tif (elapsed < duration) {\n\t\t\tthis._runFrame(this._easeOut(elapsed / duration));\n\t\t} else {\n\t\t\tthis._runFrame(1);\n\t\t\tthis._complete();\n\t\t}\n\t},\n\n\t_runFrame: function (progress) {\n\t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n\t\tL.DomUtil.setPosition(this._el, pos);\n\n\t\tthis.fire('step');\n\t},\n\n\t_complete: function () {\n\t\tL.Util.cancelAnimFrame(this._animId);\n\n\t\tthis._inProgress = false;\n\t\tthis.fire('end');\n\t},\n\n\t_easeOut: function (t) {\n\t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n\t}\n});\n\n\n/*\n * Extends L.Map to handle zoom animations.\n */\n\nL.Map.mergeOptions({\n\tzoomAnimation: true,\n\tzoomAnimationThreshold: 4\n});\n\nif (L.DomUtil.TRANSITION) {\n\n\tL.Map.addInitHook(function () {\n\t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\t\tthis._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&\n\t\t\t\tL.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;\n\n\t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\n\t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\t\tif (this._zoomAnimated) {\n\t\t\tL.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n\t\t}\n\t});\n}\n\nL.Map.include(!L.DomUtil.TRANSITION ? {} : {\n\n\t_catchTransitionEnd: function (e) {\n\t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n\t\t\tthis._onZoomTransitionEnd();\n\t\t}\n\t},\n\n\t_nothingToAnimate: function () {\n\t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n\t},\n\n\t_tryAnimatedZoom: function (center, zoom, options) {\n\n\t\tif (this._animatingZoom) { return true; }\n\n\t\toptions = options || {};\n\n\t\t// don't animate if disabled, not supported or zoom difference is too large\n\t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\n\t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\n\n\t\t// offset is the pixel coords of the zoom origin relative to the current center\n\t\tvar scale = this.getZoomScale(zoom),\n\t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),\n\t\t\torigin = this._getCenterLayerPoint()._add(offset);\n\n\t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis\n\t\t    .fire('movestart')\n\t\t    .fire('zoomstart');\n\n\t\tthis._animateZoom(center, zoom, origin, scale, null, true);\n\n\t\treturn true;\n\t},\n\n\t_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {\n\n\t\tif (!forTouchZoom) {\n\t\t\tthis._animatingZoom = true;\n\t\t}\n\n\t\t// put transform transition on all layers with leaflet-zoom-animated class\n\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\t// remember what center/zoom to set after animation\n\t\tthis._animateToCenter = center;\n\t\tthis._animateToZoom = zoom;\n\n\t\t// disable any dragging during animation\n\t\tif (L.Draggable) {\n\t\t\tL.Draggable._disabled = true;\n\t\t}\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis.fire('zoomanim', {\n\t\t\t\tcenter: center,\n\t\t\t\tzoom: zoom,\n\t\t\t\torigin: origin,\n\t\t\t\tscale: scale,\n\t\t\t\tdelta: delta,\n\t\t\t\tbackwards: backwards\n\t\t\t});\n\t\t\t// horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689\n\t\t\tsetTimeout(L.bind(this._onZoomTransitionEnd, this), 250);\n\t\t}, this);\n\t},\n\n\t_onZoomTransitionEnd: function () {\n\t\tif (!this._animatingZoom) { return; }\n\n\t\tthis._animatingZoom = false;\n\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis._resetView(this._animateToCenter, this._animateToZoom, true, true);\n\n\t\t\tif (L.Draggable) {\n\t\t\t\tL.Draggable._disabled = false;\n\t\t\t}\n\t\t}, this);\n\t}\n});\n\n\n/*\n\tZoom animation logic for L.TileLayer.\n*/\n\nL.TileLayer.include({\n\t_animateZoom: function (e) {\n\t\tif (!this._animating) {\n\t\t\tthis._animating = true;\n\t\t\tthis._prepareBgBuffer();\n\t\t}\n\n\t\tvar bg = this._bgBuffer,\n\t\t    transform = L.DomUtil.TRANSFORM,\n\t\t    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],\n\t\t    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);\n\n\t\tbg.style[transform] = e.backwards ?\n\t\t\t\tscaleStr + ' ' + initialTransform :\n\t\t\t\tinitialTransform + ' ' + scaleStr;\n\t},\n\n\t_endZoomAnim: function () {\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\tfront.style.visibility = '';\n\t\tfront.parentNode.appendChild(front); // Bring to fore\n\n\t\t// force reflow\n\t\tL.Util.falseFn(bg.offsetWidth);\n\n\t\tvar zoom = this._map.getZoom();\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t\t\tthis._clearBgBuffer();\n\t\t}\n\n\t\tthis._animating = false;\n\t},\n\n\t_clearBgBuffer: function () {\n\t\tvar map = this._map;\n\n\t\tif (map && !map._animatingZoom && !map.touchZoom._zooming) {\n\t\t\tthis._bgBuffer.innerHTML = '';\n\t\t\tthis._bgBuffer.style[L.DomUtil.TRANSFORM] = '';\n\t\t}\n\t},\n\n\t_prepareBgBuffer: function () {\n\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\t// if foreground layer doesn't have many tiles but bg layer does,\n\t\t// keep the existing bg layer and just zoom it some more\n\n\t\tvar bgLoaded = this._getLoadedTilesPercentage(bg),\n\t\t    frontLoaded = this._getLoadedTilesPercentage(front);\n\n\t\tif (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {\n\n\t\t\tfront.style.visibility = 'hidden';\n\t\t\tthis._stopLoadingImages(front);\n\t\t\treturn;\n\t\t}\n\n\t\t// prepare the buffer to become the front tile pane\n\t\tbg.style.visibility = 'hidden';\n\t\tbg.style[L.DomUtil.TRANSFORM] = '';\n\n\t\t// switch out the current layer to be the new bg layer (and vice-versa)\n\t\tthis._tileContainer = bg;\n\t\tbg = this._bgBuffer = front;\n\n\t\tthis._stopLoadingImages(bg);\n\n\t\t//prevent bg buffer from clearing right after zoom\n\t\tclearTimeout(this._clearBgBufferTimer);\n\t},\n\n\t_getLoadedTilesPercentage: function (container) {\n\t\tvar tiles = container.getElementsByTagName('img'),\n\t\t    i, len, count = 0;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\tif (tiles[i].complete) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count / len;\n\t},\n\n\t// stops loading all tiles in the background layer\n\t_stopLoadingImages: function (container) {\n\t\tvar tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),\n\t\t    i, len, tile;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\ttile = tiles[i];\n\n\t\t\tif (!tile.complete) {\n\t\t\t\ttile.onload = L.Util.falseFn;\n\t\t\t\ttile.onerror = L.Util.falseFn;\n\t\t\t\ttile.src = L.Util.emptyImageUrl;\n\n\t\t\t\ttile.parentNode.removeChild(tile);\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n/*\r\n * Provides L.Map with convenient shortcuts for using browser geolocation features.\r\n */\r\n\r\nL.Map.include({\r\n\t_defaultLocateOptions: {\r\n\t\twatch: false,\r\n\t\tsetView: false,\r\n\t\tmaxZoom: Infinity,\r\n\t\ttimeout: 10000,\r\n\t\tmaximumAge: 0,\r\n\t\tenableHighAccuracy: false\r\n\t},\r\n\r\n\tlocate: function (/*Object*/ options) {\r\n\r\n\t\toptions = this._locateOptions = L.extend(this._defaultLocateOptions, options);\r\n\r\n\t\tif (!navigator.geolocation) {\r\n\t\t\tthis._handleGeolocationError({\r\n\t\t\t\tcode: 0,\r\n\t\t\t\tmessage: 'Geolocation not supported.'\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar onResponse = L.bind(this._handleGeolocationResponse, this),\r\n\t\t\tonError = L.bind(this._handleGeolocationError, this);\r\n\r\n\t\tif (options.watch) {\r\n\t\t\tthis._locationWatchId =\r\n\t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n\t\t} else {\r\n\t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopLocate: function () {\r\n\t\tif (navigator.geolocation) {\r\n\t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n\t\t}\r\n\t\tif (this._locateOptions) {\r\n\t\t\tthis._locateOptions.setView = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_handleGeolocationError: function (error) {\r\n\t\tvar c = error.code,\r\n\t\t    message = error.message ||\r\n\t\t            (c === 1 ? 'permission denied' :\r\n\t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n\t\tif (this._locateOptions.setView && !this._loaded) {\r\n\t\t\tthis.fitWorld();\r\n\t\t}\r\n\r\n\t\tthis.fire('locationerror', {\r\n\t\t\tcode: c,\r\n\t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n\t\t});\r\n\t},\r\n\r\n\t_handleGeolocationResponse: function (pos) {\r\n\t\tvar lat = pos.coords.latitude,\r\n\t\t    lng = pos.coords.longitude,\r\n\t\t    latlng = new L.LatLng(lat, lng),\r\n\r\n\t\t    latAccuracy = 180 * pos.coords.accuracy / 40075017,\r\n\t\t    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),\r\n\r\n\t\t    bounds = L.latLngBounds(\r\n\t\t            [lat - latAccuracy, lng - lngAccuracy],\r\n\t\t            [lat + latAccuracy, lng + lngAccuracy]),\r\n\r\n\t\t    options = this._locateOptions;\r\n\r\n\t\tif (options.setView) {\r\n\t\t\tvar zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);\r\n\t\t\tthis.setView(latlng, zoom);\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tbounds: bounds,\r\n\t\t\ttimestamp: pos.timestamp\r\n\t\t};\r\n\r\n\t\tfor (var i in pos.coords) {\r\n\t\t\tif (typeof pos.coords[i] === 'number') {\r\n\t\t\t\tdata[i] = pos.coords[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.fire('locationfound', data);\r\n\t}\r\n});\r\n\n\n}(window, document));","/*!\nCopyright (c) 2016 Dominik Moritz\n\nThis file is part of the leaflet locate control. It is licensed under the MIT license.\nYou can find the project at: https://github.com/domoritz/leaflet-locatecontrol\n*/\n(function (factory, window) {\n     // see https://github.com/Leaflet/Leaflet/blob/master/PLUGIN-GUIDE.md#module-loaders\n     // for details on how to structure a leaflet plugin.\n\n    // define an AMD module that relies on 'leaflet'\n    if (typeof define === 'function' && define.amd) {\n        define(['leaflet'], factory);\n\n    // define a Common JS module that relies on 'leaflet'\n    } else if (typeof exports === 'object') {\n        if (typeof window !== 'undefined' && window.L) {\n            module.exports = factory(L);\n        } else {\n            module.exports = factory(require('leaflet'));\n        }\n    }\n\n    // attach your plugin to the global 'L' variable\n    if(typeof window !== 'undefined' && window.L){\n        window.L.Control.Locate = factory(L);\n    }\n} (function (L) {\n    var LocateControl = L.Control.extend({\n        options: {\n            /** Position of the control */\n            position: 'topleft',\n            /** The layer that the user's location should be drawn on. By default creates a new layer. */\n            layer: undefined,\n            /**\n             * Automatically sets the map view (zoom and pan) to the user's location as it updates.\n             * While the map is following the user's location, the control is in the `following` state,\n             * which changes the style of the control and the circle marker.\n             *\n             * Possible values:\n             *  - false: never updates the map view when location changes.\n             *  - 'once': set the view when the location is first determined\n             *  - 'always': always updates the map view when location changes.\n             *              The map view follows the users location.\n             *  - 'untilPan': (default) like 'always', except stops updating the\n             *                view if the user has manually panned the map.\n             *                The map view follows the users location until she pans.\n             */\n            setView: 'untilPan',\n            /** Keep the current map zoom level when setting the view and only pan. */\n            keepCurrentZoomLevel: false,\n            /**\n             * The user location can be inside and outside the current view when the user clicks on the\n             * control that is already active. Both cases can be configures separately.\n             * Possible values are:\n             *  - 'setView': zoom and pan to the current location\n             *  - 'stop': stop locating and remove the location marker\n             */\n            clickBehavior: {\n                /** What should happen if the user clicks on the control while the location is within the current view. */\n                inView: 'stop',\n                /** What should happen if the user clicks on the control while the location is outside the current view. */\n                outOfView: 'setView',\n            },\n            /** If set, a circle that shows the location accuracy is drawn. */\n            drawCircle: true,\n            /** If set, the marker at the users' location is drawn. */\n            drawMarker: true,\n            /** The class to be used to create the marker. For example L.CircleMarker or L.Marker */\n            markerClass: L.CircleMarker,\n            /** Accuracy circle style properties. */\n            circleStyle: {\n                color: '#136AEC',\n                fillColor: '#136AEC',\n                fillOpacity: 0.15,\n                weight: 2,\n                opacity: 0.5\n            },\n            /** Inner marker style properties. */\n            markerStyle: {\n                color: '#136AEC',\n                fillColor: '#2A93EE',\n                fillOpacity: 0.7,\n                weight: 2,\n                opacity: 0.9,\n                radius: 5\n            },\n            /**\n             * Changes to accuracy circle and inner marker while following.\n             * It is only necessary to provide the properties that should change.\n             */\n            followCircleStyle: {},\n            followMarkerStyle: {\n                // color: '#FFA500',\n                // fillColor: '#FFB000'\n            },\n            /** The CSS class for the icon. For example fa-location-arrow or fa-map-marker */\n            icon: 'fa fa-map-marker',\n            iconLoading: 'fa fa-spinner fa-spin',\n            /** The element to be created for icons. For example span or i */\n            iconElementTag: 'span',\n            /** Padding around the accuracy circle. */\n            circlePadding: [0, 0],\n            /** Use metric units. */\n            metric: true,\n            /** This event is called in case of any location error that is not a time out error. */\n            onLocationError: function(err, control) {\n                alert(err.message);\n            },\n            /**\n             * This even is called when the user's location is outside the bounds set on the map.\n             * The event is called repeatedly when the location changes.\n             */\n            onLocationOutsideMapBounds: function(control) {\n                control.stop();\n                alert(control.options.strings.outsideMapBoundsMsg);\n            },\n            /** Display a pop-up when the user click on the inner marker. */\n            showPopup: true,\n            strings: {\n                title: \"Show me where I am\",\n                metersUnit: \"meters\",\n                feetUnit: \"feet\",\n                popup: \"You are within {distance} {unit} from this point\",\n                outsideMapBoundsMsg: \"You seem located outside the boundaries of the map\"\n            },\n            /** The default options passed to leaflets locate method. */\n            locateOptions: {\n                maxZoom: Infinity,\n                watch: true,  // if you overwrite this, visualization cannot be updated\n                setView: false // have to set this to false because we have to\n                               // do setView manually\n            }\n        },\n\n        initialize: function (options) {\n            // set default options if nothing is set (merge one step deep)\n            for (var i in options) {\n                if (typeof this.options[i] === 'object') {\n                    L.extend(this.options[i], options[i]);\n                } else {\n                    this.options[i] = options[i];\n                }\n            }\n\n            // extend the follow marker style and circle from the normal style\n            this.options.followMarkerStyle = L.extend({}, this.options.markerStyle, this.options.followMarkerStyle);\n            this.options.followCircleStyle = L.extend({}, this.options.circleStyle, this.options.followCircleStyle);\n        },\n\n        /**\n         * Add control to map. Returns the container for the control.\n         */\n        onAdd: function (map) {\n            var container = L.DomUtil.create('div',\n                'leaflet-control-locate leaflet-bar leaflet-control');\n\n            this._layer = this.options.layer || new L.LayerGroup();\n            this._layer.addTo(map);\n            this._event = undefined;\n\n            this._link = L.DomUtil.create('a', 'leaflet-bar-part leaflet-bar-part-single', container);\n            this._link.href = '#';\n            this._link.title = this.options.strings.title;\n            this._icon = L.DomUtil.create(this.options.iconElementTag, this.options.icon, this._link);\n\n            L.DomEvent\n                .on(this._link, 'click', L.DomEvent.stopPropagation)\n                .on(this._link, 'click', L.DomEvent.preventDefault)\n                .on(this._link, 'click', this._onClick, this)\n                .on(this._link, 'dblclick', L.DomEvent.stopPropagation);\n\n            this._resetVariables();\n\n            this._map.on('unload', this._unload, this);\n\n            return container;\n        },\n\n        /**\n         * This method is called when the user clicks on the control.\n         */\n        _onClick: function() {\n            this._justClicked = true;\n            this._userPanned = false;\n\n            if (this._active && !this._event) {\n                // click while requesting\n                this.stop();\n            } else if (this._active && this._event !== undefined) {\n                var behavior = this._map.getBounds().contains(this._event.latlng) ?\n                    this.options.clickBehavior.inView : this.options.clickBehavior.outOfView;\n                switch (behavior) {\n                    case 'setView':\n                        this.setView();\n                        break;\n                    case 'stop':\n                        this.stop();\n                        break;\n                }\n            } else {\n                this.start();\n            }\n\n            this._updateContainerStyle();\n        },\n\n        /**\n         * Starts the plugin:\n         * - activates the engine\n         * - draws the marker (if coordinates available)\n         */\n        start: function() {\n            this._activate();\n\n            if (this._event) {\n                this._drawMarker(this._map);\n\n                // if we already have a location but the user clicked on the control\n                if (this.options.setView) {\n                    this.setView();\n                }\n            }\n            this._updateContainerStyle();\n        },\n\n        /**\n         * Stops the plugin:\n         * - deactivates the engine\n         * - reinitializes the button\n         * - removes the marker\n         */\n        stop: function() {\n            this._deactivate();\n\n            this._cleanClasses();\n            this._resetVariables();\n\n            this._removeMarker();\n        },\n\n        /**\n         * This method launches the location engine.\n         * It is called before the marker is updated,\n         * event if it does not mean that the event will be ready.\n         *\n         * Override it if you want to add more functionalities.\n         * It should set the this._active to true and do nothing if\n         * this._active is true.\n         */\n        _activate: function() {\n            if (!this._active) {\n                this._map.locate(this.options.locateOptions);\n                this._active = true;\n\n                // bind event listeners\n                this._map.on('locationfound', this._onLocationFound, this);\n                this._map.on('locationerror', this._onLocationError, this);\n                this._map.on('dragstart', this._onDrag, this);\n            }\n        },\n\n        /**\n         * Called to stop the location engine.\n         *\n         * Override it to shutdown any functionalities you added on start.\n         */\n        _deactivate: function() {\n            this._map.stopLocate();\n            this._active = false;\n\n            // unbind event listeners\n            this._map.off('locationfound', this._onLocationFound, this);\n            this._map.off('locationerror', this._onLocationError, this);\n            this._map.off('dragstart', this._onDrag, this);\n        },\n\n        /**\n         * Zoom (unless we should keep the zoom level) and an to the current view.\n         */\n        setView: function() {\n            if (this._isOutsideMapBounds()) {\n                this.options.onLocationOutsideMapBounds(this);\n            } else {\n                if (this.options.keepCurrentZoomLevel) {\n                    this._map.panTo([this._event.latitude, this._event.longitude]);\n                } else {\n                    this._map.fitBounds(this._event.bounds, {\n                        padding: this.options.circlePadding,\n                        maxZoom: this.options.locateOptions.maxZoom\n                    });\n                }\n            }\n            this._drawMarker();\n        },\n\n        /**\n         * Draw the marker and accuracy circle on the map.\n         *\n         * Uses the event retrieved from onLocationFound from the map.\n         */\n        _drawMarker: function() {\n            if (this._event.accuracy === undefined) {\n                this._event.accuracy = 0;\n            }\n\n            var radius = this._event.accuracy;\n            var latlng = this._event.latlng;\n\n            // circle with the radius of the location's accuracy\n            if (this.options.drawCircle) {\n                var style = this._isFollowing() ? this.options.followCircleStyle : this.options.circleStyle;\n\n                if (!this._circle) {\n                    this._circle = L.circle(latlng, radius, style).addTo(this._layer);\n                } else {\n                    this._circle.setLatLng(latlng).setRadius(radius).setStyle(style);\n                }\n            }\n\n            var distance, unit;\n            if (this.options.metric) {\n                distance = radius.toFixed(0);\n                unit =  this.options.strings.metersUnit;\n            } else {\n                distance = (radius * 3.2808399).toFixed(0);\n                unit = this.options.strings.feetUnit;\n            }\n\n            // small inner marker\n            if (this.options.drawMarker) {\n                var mStyle = this._isFollowing() ? this.options.followMarkerStyle : this.options.markerStyle;\n\n                if (!this._marker) {\n                    this._marker = new this.options.markerClass(latlng, mStyle).addTo(this._layer);\n                } else {\n                    this._marker.setLatLng(latlng).setStyle(mStyle);\n                }\n            }\n\n            var t = this.options.strings.popup;\n            if (this.options.showPopup && t && this._marker) {\n                this._marker\n                    .bindPopup(L.Util.template(t, {distance: distance, unit: unit}))\n                    ._popup.setLatLng(latlng);\n            }\n        },\n\n        /**\n         * Remove the marker from map.\n         */\n        _removeMarker: function() {\n            this._layer.clearLayers();\n            this._marker = undefined;\n            this._circle = undefined;\n        },\n\n        /**\n         * Unload the plugin and all event listeners.\n         * Kind of the opposite of onAdd.\n         */\n        _unload: function() {\n            this.stop();\n            this._map.off('unload', this._unload, this);\n        },\n\n        /**\n         * Calls deactivate and dispatches an error.\n         */\n        _onLocationError: function(err) {\n            // ignore time out error if the location is watched\n            if (err.code == 3 && this.options.locateOptions.watch) {\n                return;\n            }\n\n            this.stop();\n            this.options.onLocationError(err, this);\n        },\n\n        /**\n         * Stores the received event and updates the marker.\n         */\n        _onLocationFound: function(e) {\n            // no need to do anything if the location has not changed\n            if (this._event &&\n                (this._event.latlng.lat === e.latlng.lat &&\n                 this._event.latlng.lng === e.latlng.lng &&\n                     this._event.accuracy === e.accuracy)) {\n                return;\n            }\n\n            if (!this._active) {\n                // we may have a stray event\n                return;\n            }\n\n            this._event = e;\n\n            this._drawMarker();\n            this._updateContainerStyle();\n\n            switch (this.options.setView) {\n                case 'once':\n                    if (this._justClicked) {\n                        this.setView();\n                    }\n                    break;\n                case 'untilPan':\n                    if (!this._userPanned) {\n                        this.setView();\n                    }\n                    break;\n                case 'always':\n                    this.setView();\n                    break;\n                case false:\n                    // don't set the view\n                    break;\n            }\n\n            this._justClicked = false;\n        },\n\n        /**\n         * When the user drags. Need a separate even so we can bind and unbind even listeners.\n         */\n        _onDrag: function() {\n            // only react to drags once we have a location\n            if (this._event) {\n                this._userPanned = true;\n                this._updateContainerStyle();\n                this._drawMarker();\n            }\n        },\n\n        /**\n         * Compute whether the map is following the user location with pan and zoom.\n         */\n        _isFollowing: function() {\n            if (!this._active) {\n                return false;\n            }\n\n            if (this.options.setView === 'always') {\n                return true;\n            } else if (this.options.setView === 'untilPan') {\n                return !this._userPanned;\n            }\n        },\n\n        /**\n         * Check if location is in map bounds\n         */\n        _isOutsideMapBounds: function() {\n            if (this._event === undefined) {\n                return false;\n            }\n            return this._map.options.maxBounds &&\n                !this._map.options.maxBounds.contains(this._event.latlng);\n        },\n\n        /**\n         * Toggles button class between following and active.\n         */\n        _updateContainerStyle: function() {\n            if (!this._container) {\n                return;\n            }\n\n            if (this._active && !this._event) {\n                // active but don't have a location yet\n                this._setClasses('requesting');\n            } else if (this._isFollowing()) {\n                this._setClasses('following');\n            } else if (this._active) {\n                this._setClasses('active');\n            } else {\n                this._cleanClasses();\n            }\n        },\n\n        /**\n         * Sets the CSS classes for the state.\n         */\n        _setClasses: function(state) {\n            if (state == 'requesting') {\n                L.DomUtil.removeClasses(this._container, \"active following\");\n                L.DomUtil.addClasses(this._container, \"requesting\");\n\n                L.DomUtil.removeClasses(this._icon, this.options.icon);\n                L.DomUtil.addClasses(this._icon, this.options.iconLoading);\n            } else if (state == 'active') {\n                L.DomUtil.removeClasses(this._container, \"requesting following\");\n                L.DomUtil.addClasses(this._container, \"active\");\n\n                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);\n                L.DomUtil.addClasses(this._icon, this.options.icon);\n            } else if (state == 'following') {\n                L.DomUtil.removeClasses(this._container, \"requesting\");\n                L.DomUtil.addClasses(this._container, \"active following\");\n\n                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);\n                L.DomUtil.addClasses(this._icon, this.options.icon);\n            }\n        },\n\n        /**\n         * Removes all classes from button.\n         */\n        _cleanClasses: function() {\n            L.DomUtil.removeClass(this._container, \"requesting\");\n            L.DomUtil.removeClass(this._container, \"active\");\n            L.DomUtil.removeClass(this._container, \"following\");\n\n            L.DomUtil.removeClasses(this._icon, this.options.iconLoading);\n            L.DomUtil.addClasses(this._icon, this.options.icon);\n        },\n\n        /**\n         * Reinitializes state variables.\n         */\n        _resetVariables: function() {\n            // whether locate is active or not\n            this._active = false;\n\n            // true if the control was clicked for the first time\n            // we need this so we can pan and zoom once we have the location\n            this._justClicked = false;\n\n            // true if the user has panned the map after clicking the control\n            this._userPanned = false;\n        }\n    });\n\n    L.control.locate = function (options) {\n        return new L.Control.Locate(options);\n    };\n\n    (function(){\n      // leaflet.js raises bug when trying to addClass / removeClass multiple classes at once\n      // Let's create a wrapper on it which fixes it.\n      var LDomUtilApplyClassesMethod = function(method, element, classNames) {\n        classNames = classNames.split(' ');\n        classNames.forEach(function(className) {\n            L.DomUtil[method].call(this, element, className);\n        });\n      };\n\n      L.DomUtil.addClasses = function(el, names) { LDomUtilApplyClassesMethod('addClass', el, names); };\n      L.DomUtil.removeClasses = function(el, names) { LDomUtilApplyClassesMethod('removeClass', el, names); };\n    })();\n\n    return LocateControl;\n}, window));\n","/*\n Leaflet 1.0.0-beta.2 (55fe462), a JS library for interactive maps. http://leafletjs.com\n (c) 2010-2015 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n*/\n(function (window, document, undefined) {\r\nvar L = {\r\n\tversion: '1.0.0-beta.2'\r\n};\r\n\r\nfunction expose() {\r\n\tvar oldL = window.L;\r\n\r\n\tL.noConflict = function () {\r\n\t\twindow.L = oldL;\r\n\t\treturn this;\r\n\t};\r\n\r\n\twindow.L = L;\r\n}\r\n\r\n// define Leaflet for Node module pattern loaders, including Browserify\r\nif (typeof module === 'object' && typeof module.exports === 'object') {\r\n\tmodule.exports = L;\r\n\r\n// define Leaflet as an AMD module\r\n} else if (typeof define === 'function' && define.amd) {\r\n\tdefine(L);\r\n}\r\n\r\n// define Leaflet as a global L variable, saving the original L to restore later if needed\r\nif (typeof window !== 'undefined') {\r\n\texpose();\r\n}\r\n\n\n\n/*\r\n * L.Util contains various utility functions used throughout Leaflet code.\r\n */\r\n\r\nL.Util = {\r\n\t// extend an object with properties of one or more other objects\r\n\textend: function (dest) {\r\n\t\tvar i, j, len, src;\r\n\r\n\t\tfor (j = 1, len = arguments.length; j < len; j++) {\r\n\t\t\tsrc = arguments[j];\r\n\t\t\tfor (i in src) {\r\n\t\t\t\tdest[i] = src[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dest;\r\n\t},\r\n\r\n\t// create an object from a given prototype\r\n\tcreate: Object.create || (function () {\r\n\t\tfunction F() {}\r\n\t\treturn function (proto) {\r\n\t\t\tF.prototype = proto;\r\n\t\t\treturn new F();\r\n\t\t};\r\n\t})(),\r\n\r\n\t// bind a function to be called with a given context\r\n\tbind: function (fn, obj) {\r\n\t\tvar slice = Array.prototype.slice;\r\n\r\n\t\tif (fn.bind) {\r\n\t\t\treturn fn.bind.apply(fn, slice.call(arguments, 1));\r\n\t\t}\r\n\r\n\t\tvar args = slice.call(arguments, 2);\r\n\r\n\t\treturn function () {\r\n\t\t\treturn fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\r\n\t\t};\r\n\t},\r\n\r\n\t// return unique ID of an object\r\n\tstamp: function (obj) {\r\n\t\t/*eslint-disable */\r\n\t\tobj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;\r\n\t\treturn obj._leaflet_id;\r\n\t\t/*eslint-enable */\r\n\t},\r\n\r\n\tlastId: 0,\r\n\r\n\t// return a function that won't be called more often than the given interval\r\n\tthrottle: function (fn, time, context) {\r\n\t\tvar lock, args, wrapperFn, later;\r\n\r\n\t\tlater = function () {\r\n\t\t\t// reset lock and call if queued\r\n\t\t\tlock = false;\r\n\t\t\tif (args) {\r\n\t\t\t\twrapperFn.apply(context, args);\r\n\t\t\t\targs = false;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\twrapperFn = function () {\r\n\t\t\tif (lock) {\r\n\t\t\t\t// called too soon, queue to call later\r\n\t\t\t\targs = arguments;\r\n\r\n\t\t\t} else {\r\n\t\t\t\t// call and lock until later\r\n\t\t\t\tfn.apply(context, arguments);\r\n\t\t\t\tsetTimeout(later, time);\r\n\t\t\t\tlock = true;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\treturn wrapperFn;\r\n\t},\r\n\r\n\t// wrap the given number to lie within a certain range (used for wrapping longitude)\r\n\twrapNum: function (x, range, includeMax) {\r\n\t\tvar max = range[1],\r\n\t\t    min = range[0],\r\n\t\t    d = max - min;\r\n\t\treturn x === max && includeMax ? x : ((x - min) % d + d) % d + min;\r\n\t},\r\n\r\n\t// do nothing (used as a noop throughout the code)\r\n\tfalseFn: function () { return false; },\r\n\r\n\t// round a given number to a given precision\r\n\tformatNum: function (num, digits) {\r\n\t\tvar pow = Math.pow(10, digits || 5);\r\n\t\treturn Math.round(num * pow) / pow;\r\n\t},\r\n\r\n\t// trim whitespace from both sides of a string\r\n\ttrim: function (str) {\r\n\t\treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n\t},\r\n\r\n\t// split a string into words\r\n\tsplitWords: function (str) {\r\n\t\treturn L.Util.trim(str).split(/\\s+/);\r\n\t},\r\n\r\n\t// set options to an object, inheriting parent's options as well\r\n\tsetOptions: function (obj, options) {\r\n\t\tif (!obj.hasOwnProperty('options')) {\r\n\t\t\tobj.options = obj.options ? L.Util.create(obj.options) : {};\r\n\t\t}\r\n\t\tfor (var i in options) {\r\n\t\t\tobj.options[i] = options[i];\r\n\t\t}\r\n\t\treturn obj.options;\r\n\t},\r\n\r\n\t// make a URL with GET parameters out of a set of properties/values\r\n\tgetParamString: function (obj, existingUrl, uppercase) {\r\n\t\tvar params = [];\r\n\t\tfor (var i in obj) {\r\n\t\t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n\t\t}\r\n\t\treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n\t},\r\n\r\n\t// super-simple templating facility, used for TileLayer URLs\r\n\ttemplate: function (str, data) {\r\n\t\treturn str.replace(L.Util.templateRe, function (str, key) {\r\n\t\t\tvar value = data[key];\r\n\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tthrow new Error('No value provided for variable ' + str);\r\n\r\n\t\t\t} else if (typeof value === 'function') {\r\n\t\t\t\tvalue = value(data);\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t});\r\n\t},\r\n\r\n\ttemplateRe: /\\{ *([\\w_]+) *\\}/g,\r\n\r\n\tisArray: Array.isArray || function (obj) {\r\n\t\treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n\t},\r\n\r\n\tindexOf: function (array, el) {\r\n\t\tfor (var i = 0; i < array.length; i++) {\r\n\t\t\tif (array[i] === el) { return i; }\r\n\t\t}\r\n\t\treturn -1;\r\n\t},\r\n\r\n\t// minimal image URI, set to an image when disposing to flush memory\r\n\temptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\r\n};\r\n\r\n(function () {\r\n\t// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n\tfunction getPrefixed(name) {\r\n\t\treturn window['webkit' + name] || window['moz' + name] || window['ms' + name];\r\n\t}\r\n\r\n\tvar lastTime = 0;\r\n\r\n\t// fallback for IE 7-8\r\n\tfunction timeoutDefer(fn) {\r\n\t\tvar time = +new Date(),\r\n\t\t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n\t\tlastTime = time + timeToCall;\r\n\t\treturn window.setTimeout(fn, timeToCall);\r\n\t}\r\n\r\n\tvar requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,\r\n\t    cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||\r\n\t               getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };\r\n\r\n\r\n\tL.Util.requestAnimFrame = function (fn, context, immediate) {\r\n\t\tif (immediate && requestFn === timeoutDefer) {\r\n\t\t\tfn.call(context);\r\n\t\t} else {\r\n\t\t\treturn requestFn.call(window, L.bind(fn, context));\r\n\t\t}\r\n\t};\r\n\r\n\tL.Util.cancelAnimFrame = function (id) {\r\n\t\tif (id) {\r\n\t\t\tcancelFn.call(window, id);\r\n\t\t}\r\n\t};\r\n})();\r\n\r\n// shortcuts for most used utility functions\r\nL.extend = L.Util.extend;\r\nL.bind = L.Util.bind;\r\nL.stamp = L.Util.stamp;\r\nL.setOptions = L.Util.setOptions;\r\n\n\n\n/*\r\n * L.Class powers the OOP facilities of the library.\r\n * Thanks to John Resig and Dean Edwards for inspiration!\r\n */\r\n\r\nL.Class = function () {};\r\n\r\nL.Class.extend = function (props) {\r\n\r\n\t// extended class with the new prototype\r\n\tvar NewClass = function () {\r\n\r\n\t\t// call the constructor\r\n\t\tif (this.initialize) {\r\n\t\t\tthis.initialize.apply(this, arguments);\r\n\t\t}\r\n\r\n\t\t// call all constructor hooks\r\n\t\tthis.callInitHooks();\r\n\t};\r\n\r\n\tvar parentProto = NewClass.__super__ = this.prototype;\r\n\r\n\tvar proto = L.Util.create(parentProto);\r\n\tproto.constructor = NewClass;\r\n\r\n\tNewClass.prototype = proto;\r\n\r\n\t// inherit parent's statics\r\n\tfor (var i in this) {\r\n\t\tif (this.hasOwnProperty(i) && i !== 'prototype') {\r\n\t\t\tNewClass[i] = this[i];\r\n\t\t}\r\n\t}\r\n\r\n\t// mix static properties into the class\r\n\tif (props.statics) {\r\n\t\tL.extend(NewClass, props.statics);\r\n\t\tdelete props.statics;\r\n\t}\r\n\r\n\t// mix includes into the prototype\r\n\tif (props.includes) {\r\n\t\tL.Util.extend.apply(null, [proto].concat(props.includes));\r\n\t\tdelete props.includes;\r\n\t}\r\n\r\n\t// merge options\r\n\tif (proto.options) {\r\n\t\tprops.options = L.Util.extend(L.Util.create(proto.options), props.options);\r\n\t}\r\n\r\n\t// mix given properties into the prototype\r\n\tL.extend(proto, props);\r\n\r\n\tproto._initHooks = [];\r\n\r\n\t// add method for calling all hooks\r\n\tproto.callInitHooks = function () {\r\n\r\n\t\tif (this._initHooksCalled) { return; }\r\n\r\n\t\tif (parentProto.callInitHooks) {\r\n\t\t\tparentProto.callInitHooks.call(this);\r\n\t\t}\r\n\r\n\t\tthis._initHooksCalled = true;\r\n\r\n\t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n\t\t\tproto._initHooks[i].call(this);\r\n\t\t}\r\n\t};\r\n\r\n\treturn NewClass;\r\n};\r\n\r\n\r\n// method for adding properties to prototype\r\nL.Class.include = function (props) {\r\n\tL.extend(this.prototype, props);\r\n};\r\n\r\n// merge new default options to the Class\r\nL.Class.mergeOptions = function (options) {\r\n\tL.extend(this.prototype.options, options);\r\n};\r\n\r\n// add a constructor hook\r\nL.Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n\tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n\tvar init = typeof fn === 'function' ? fn : function () {\r\n\t\tthis[fn].apply(this, args);\r\n\t};\r\n\r\n\tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n\tthis.prototype._initHooks.push(init);\r\n};\r\n\n\n\n/*\r\n * L.Evented is a base class that Leaflet classes inherit from to handle custom events.\r\n */\r\n\r\nL.Evented = L.Class.extend({\r\n\r\n\ton: function (types, fn, context) {\r\n\r\n\t\t// types can be a map of types/handlers\r\n\t\tif (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\t// we don't process space-separated events here for performance;\r\n\t\t\t\t// it's a hot path since Layer uses the on(obj) syntax\r\n\t\t\t\tthis._on(type, types[type], fn);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\t// types can be a string of space-separated words\r\n\t\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\tthis._on(types[i], fn, context);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\toff: function (types, fn, context) {\r\n\r\n\t\tif (!types) {\r\n\t\t\t// clear all listeners if called without arguments\r\n\t\t\tdelete this._events;\r\n\r\n\t\t} else if (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\tthis._off(type, types[type], fn);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\tthis._off(types[i], fn, context);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// attach listener (without syntactic sugar now)\r\n\t_on: function (type, fn, context) {\r\n\r\n\t\tvar events = this._events = this._events || {},\r\n\t\t    contextId = context && context !== this && L.stamp(context);\r\n\r\n\t\tif (contextId) {\r\n\t\t\t// store listeners with custom context in a separate hash (if it has an id);\r\n\t\t\t// gives a major performance boost when firing and removing events (e.g. on map object)\r\n\r\n\t\t\tvar indexKey = type + '_idx',\r\n\t\t\t    indexLenKey = type + '_len',\r\n\t\t\t    typeIndex = events[indexKey] = events[indexKey] || {},\r\n\t\t\t    id = L.stamp(fn) + '_' + contextId;\r\n\r\n\t\t\tif (!typeIndex[id]) {\r\n\t\t\t\ttypeIndex[id] = {fn: fn, ctx: context};\r\n\r\n\t\t\t\t// keep track of the number of keys in the index to quickly check if it's empty\r\n\t\t\t\tevents[indexLenKey] = (events[indexLenKey] || 0) + 1;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\t// individual layers mostly use \"this\" for context and don't fire listeners too often\r\n\t\t\t// so simple array makes the memory footprint better while not degrading performance\r\n\r\n\t\t\tevents[type] = events[type] || [];\r\n\t\t\tevents[type].push({fn: fn});\r\n\t\t}\r\n\t},\r\n\r\n\t_off: function (type, fn, context) {\r\n\t\tvar events = this._events,\r\n\t\t    indexKey = type + '_idx',\r\n\t\t    indexLenKey = type + '_len';\r\n\r\n\t\tif (!events) { return; }\r\n\r\n\t\tif (!fn) {\r\n\t\t\t// clear all listeners for a type if function isn't specified\r\n\t\t\tdelete events[type];\r\n\t\t\tdelete events[indexKey];\r\n\t\t\tdelete events[indexLenKey];\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar contextId = context && context !== this && L.stamp(context),\r\n\t\t    listeners, i, len, listener, id;\r\n\r\n\t\tif (contextId) {\r\n\t\t\tid = L.stamp(fn) + '_' + contextId;\r\n\t\t\tlisteners = events[indexKey];\r\n\r\n\t\t\tif (listeners && listeners[id]) {\r\n\t\t\t\tlistener = listeners[id];\r\n\t\t\t\tdelete listeners[id];\r\n\t\t\t\tevents[indexLenKey]--;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tlisteners = events[type];\r\n\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tif (listeners[i].fn === fn) {\r\n\t\t\t\t\t\tlistener = listeners[i];\r\n\t\t\t\t\t\tlisteners.splice(i, 1);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// set the removed listener to noop so that's not called if remove happens in fire\r\n\t\tif (listener) {\r\n\t\t\tlistener.fn = L.Util.falseFn;\r\n\t\t}\r\n\t},\r\n\r\n\tfire: function (type, data, propagate) {\r\n\t\tif (!this.listens(type, propagate)) { return this; }\r\n\r\n\t\tvar event = L.Util.extend({}, data, {type: type, target: this}),\r\n\t\t    events = this._events;\r\n\r\n\t\tif (events) {\r\n\t\t\tvar typeIndex = events[type + '_idx'],\r\n\t\t\t    i, len, listeners, id;\r\n\r\n\t\t\tif (events[type]) {\r\n\t\t\t\t// make sure adding/removing listeners inside other listeners won't cause infinite loop\r\n\t\t\t\tlisteners = events[type].slice();\r\n\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tlisteners[i].fn.call(this, event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// fire event for the context-indexed listeners as well\r\n\t\t\tfor (id in typeIndex) {\r\n\t\t\t\ttypeIndex[id].fn.call(typeIndex[id].ctx, event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (propagate) {\r\n\t\t\t// propagate the event to parents (set with addEventParent)\r\n\t\t\tthis._propagateEvent(event);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tlistens: function (type, propagate) {\r\n\t\tvar events = this._events;\r\n\r\n\t\tif (events && (events[type] || events[type + '_len'])) { return true; }\r\n\r\n\t\tif (propagate) {\r\n\t\t\t// also check parents for listeners if event propagates\r\n\t\t\tfor (var id in this._eventParents) {\r\n\t\t\t\tif (this._eventParents[id].listens(type, propagate)) { return true; }\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tonce: function (types, fn, context) {\r\n\r\n\t\tif (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\tthis.once(type, types[type], fn);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar handler = L.bind(function () {\r\n\t\t\tthis\r\n\t\t\t    .off(types, fn, context)\r\n\t\t\t    .off(types, handler, context);\r\n\t\t}, this);\r\n\r\n\t\t// add a listener that's executed once and removed after that\r\n\t\treturn this\r\n\t\t    .on(types, fn, context)\r\n\t\t    .on(types, handler, context);\r\n\t},\r\n\r\n\t// adds a parent to propagate events to (when you fire with true as a 3rd argument)\r\n\taddEventParent: function (obj) {\r\n\t\tthis._eventParents = this._eventParents || {};\r\n\t\tthis._eventParents[L.stamp(obj)] = obj;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveEventParent: function (obj) {\r\n\t\tif (this._eventParents) {\r\n\t\t\tdelete this._eventParents[L.stamp(obj)];\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_propagateEvent: function (e) {\r\n\t\tfor (var id in this._eventParents) {\r\n\t\t\tthis._eventParents[id].fire(e.type, L.extend({layer: e.target}, e), true);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar proto = L.Evented.prototype;\r\n\r\n// aliases; we should ditch those eventually\r\nproto.addEventListener = proto.on;\r\nproto.removeEventListener = proto.clearAllEventListeners = proto.off;\r\nproto.addOneTimeEventListener = proto.once;\r\nproto.fireEvent = proto.fire;\r\nproto.hasEventListeners = proto.listens;\r\n\r\nL.Mixin = {Events: proto};\r\n\n\n\n/*\r\n * L.Browser handles different browser and feature detections for internal Leaflet use.\r\n */\r\n\r\n(function () {\r\n\r\n\tvar ua = navigator.userAgent.toLowerCase(),\r\n\t    doc = document.documentElement,\r\n\r\n\t    ie = 'ActiveXObject' in window,\r\n\r\n\t    webkit    = ua.indexOf('webkit') !== -1,\r\n\t    phantomjs = ua.indexOf('phantom') !== -1,\r\n\t    android23 = ua.search('android [23]') !== -1,\r\n\t    chrome    = ua.indexOf('chrome') !== -1,\r\n\t    gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,\r\n\r\n\t    mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,\r\n\t    msPointer = !window.PointerEvent && window.MSPointerEvent,\r\n\t    pointer = (window.PointerEvent && navigator.pointerEnabled) || msPointer,\r\n\r\n\t    ie3d = ie && ('transition' in doc.style),\r\n\t    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,\r\n\t    gecko3d = 'MozPerspective' in doc.style,\r\n\t    opera12 = 'OTransition' in doc.style;\r\n\r\n\tvar touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||\r\n\t\t\t(window.DocumentTouch && document instanceof window.DocumentTouch));\r\n\r\n\tL.Browser = {\r\n\t\tie: ie,\r\n\t\tielt9: ie && !document.addEventListener,\r\n\t\twebkit: webkit,\r\n\t\tgecko: gecko,\r\n\t\tandroid: ua.indexOf('android') !== -1,\r\n\t\tandroid23: android23,\r\n\t\tchrome: chrome,\r\n\t\tsafari: !chrome && ua.indexOf('safari') !== -1,\r\n\r\n\t\tie3d: ie3d,\r\n\t\twebkit3d: webkit3d,\r\n\t\tgecko3d: gecko3d,\r\n\t\topera12: opera12,\r\n\t\tany3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,\r\n\r\n\t\tmobile: mobile,\r\n\t\tmobileWebkit: mobile && webkit,\r\n\t\tmobileWebkit3d: mobile && webkit3d,\r\n\t\tmobileOpera: mobile && window.opera,\r\n\t\tmobileGecko: mobile && gecko,\r\n\r\n\t\ttouch: !!touch,\r\n\t\tmsPointer: !!msPointer,\r\n\t\tpointer: !!pointer,\r\n\r\n\t\tretina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1\r\n\t};\r\n\r\n}());\r\n\n\n\n/*\r\n * L.Point represents a point with x and y coordinates.\r\n */\r\n\r\nL.Point = function (x, y, round) {\r\n\tthis.x = (round ? Math.round(x) : x);\r\n\tthis.y = (round ? Math.round(y) : y);\r\n};\r\n\r\nL.Point.prototype = {\r\n\r\n\tclone: function () {\r\n\t\treturn new L.Point(this.x, this.y);\r\n\t},\r\n\r\n\t// non-destructive, returns a new point\r\n\tadd: function (point) {\r\n\t\treturn this.clone()._add(L.point(point));\r\n\t},\r\n\r\n\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n\t_add: function (point) {\r\n\t\tthis.x += point.x;\r\n\t\tthis.y += point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsubtract: function (point) {\r\n\t\treturn this.clone()._subtract(L.point(point));\r\n\t},\r\n\r\n\t_subtract: function (point) {\r\n\t\tthis.x -= point.x;\r\n\t\tthis.y -= point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdivideBy: function (num) {\r\n\t\treturn this.clone()._divideBy(num);\r\n\t},\r\n\r\n\t_divideBy: function (num) {\r\n\t\tthis.x /= num;\r\n\t\tthis.y /= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tmultiplyBy: function (num) {\r\n\t\treturn this.clone()._multiplyBy(num);\r\n\t},\r\n\r\n\t_multiplyBy: function (num) {\r\n\t\tthis.x *= num;\r\n\t\tthis.y *= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tscaleBy: function (point) {\r\n\t\treturn new L.Point(this.x * point.x, this.y * point.y);\r\n\t},\r\n\r\n\tunscaleBy: function (point) {\r\n\t\treturn new L.Point(this.x / point.x, this.y / point.y);\r\n\t},\r\n\r\n\tround: function () {\r\n\t\treturn this.clone()._round();\r\n\t},\r\n\r\n\t_round: function () {\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfloor: function () {\r\n\t\treturn this.clone()._floor();\r\n\t},\r\n\r\n\t_floor: function () {\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tceil: function () {\r\n\t\treturn this.clone()._ceil();\r\n\t},\r\n\r\n\t_ceil: function () {\r\n\t\tthis.x = Math.ceil(this.x);\r\n\t\tthis.y = Math.ceil(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdistanceTo: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tvar x = point.x - this.x,\r\n\t\t    y = point.y - this.y;\r\n\r\n\t\treturn Math.sqrt(x * x + y * y);\r\n\t},\r\n\r\n\tequals: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn point.x === this.x &&\r\n\t\t       point.y === this.y;\r\n\t},\r\n\r\n\tcontains: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n\t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn 'Point(' +\r\n\t\t        L.Util.formatNum(this.x) + ', ' +\r\n\t\t        L.Util.formatNum(this.y) + ')';\r\n\t}\r\n};\r\n\r\nL.point = function (x, y, round) {\r\n\tif (x instanceof L.Point) {\r\n\t\treturn x;\r\n\t}\r\n\tif (L.Util.isArray(x)) {\r\n\t\treturn new L.Point(x[0], x[1]);\r\n\t}\r\n\tif (x === undefined || x === null) {\r\n\t\treturn x;\r\n\t}\r\n\treturn new L.Point(x, y, round);\r\n};\r\n\n\n\n/*\r\n * L.Bounds represents a rectangular area on the screen in pixel coordinates.\r\n */\r\n\r\nL.Bounds = function (a, b) { // (Point, Point) or Point[]\r\n\tif (!a) { return; }\r\n\r\n\tvar points = b ? [a, b] : a;\r\n\r\n\tfor (var i = 0, len = points.length; i < len; i++) {\r\n\t\tthis.extend(points[i]);\r\n\t}\r\n};\r\n\r\nL.Bounds.prototype = {\r\n\t// extend the bounds to contain the given point\r\n\textend: function (point) { // (Point)\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tif (!this.min && !this.max) {\r\n\t\t\tthis.min = point.clone();\r\n\t\t\tthis.max = point.clone();\r\n\t\t} else {\r\n\t\t\tthis.min.x = Math.min(point.x, this.min.x);\r\n\t\t\tthis.max.x = Math.max(point.x, this.max.x);\r\n\t\t\tthis.min.y = Math.min(point.y, this.min.y);\r\n\t\t\tthis.max.y = Math.max(point.y, this.max.y);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetCenter: function (round) { // (Boolean) -> Point\r\n\t\treturn new L.Point(\r\n\t\t        (this.min.x + this.max.x) / 2,\r\n\t\t        (this.min.y + this.max.y) / 2, round);\r\n\t},\r\n\r\n\tgetBottomLeft: function () { // -> Point\r\n\t\treturn new L.Point(this.min.x, this.max.y);\r\n\t},\r\n\r\n\tgetTopRight: function () { // -> Point\r\n\t\treturn new L.Point(this.max.x, this.min.y);\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\treturn this.max.subtract(this.min);\r\n\t},\r\n\r\n\tcontains: function (obj) { // (Bounds) or (Point) -> Boolean\r\n\t\tvar min, max;\r\n\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.Point) {\r\n\t\t\tobj = L.point(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.bounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.Bounds) {\r\n\t\t\tmin = obj.min;\r\n\t\t\tmax = obj.max;\r\n\t\t} else {\r\n\t\t\tmin = max = obj;\r\n\t\t}\r\n\r\n\t\treturn (min.x >= this.min.x) &&\r\n\t\t       (max.x <= this.max.x) &&\r\n\t\t       (min.y >= this.min.y) &&\r\n\t\t       (max.y <= this.max.y);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (Bounds) -> Boolean\r\n\t\tbounds = L.bounds(bounds);\r\n\r\n\t\tvar min = this.min,\r\n\t\t    max = this.max,\r\n\t\t    min2 = bounds.min,\r\n\t\t    max2 = bounds.max,\r\n\t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n\t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n\t\treturn xIntersects && yIntersects;\r\n\t},\r\n\r\n\toverlaps: function (bounds) { // (Bounds) -> Boolean\r\n\t\tbounds = L.bounds(bounds);\r\n\r\n\t\tvar min = this.min,\r\n\t\t    max = this.max,\r\n\t\t    min2 = bounds.min,\r\n\t\t    max2 = bounds.max,\r\n\t\t    xOverlaps = (max2.x > min.x) && (min2.x < max.x),\r\n\t\t    yOverlaps = (max2.y > min.y) && (min2.y < max.y);\r\n\r\n\t\treturn xOverlaps && yOverlaps;\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this.min && this.max);\r\n\t}\r\n};\r\n\r\nL.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])\r\n\tif (!a || a instanceof L.Bounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.Bounds(a, b);\r\n};\r\n\n\n\n/*\r\n * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\r\n */\r\n\r\nL.Transformation = function (a, b, c, d) {\r\n\tthis._a = a;\r\n\tthis._b = b;\r\n\tthis._c = c;\r\n\tthis._d = d;\r\n};\r\n\r\nL.Transformation.prototype = {\r\n\ttransform: function (point, scale) { // (Point, Number) -> Point\r\n\t\treturn this._transform(point.clone(), scale);\r\n\t},\r\n\r\n\t// destructive transform (faster)\r\n\t_transform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\tpoint.x = scale * (this._a * point.x + this._b);\r\n\t\tpoint.y = scale * (this._c * point.y + this._d);\r\n\t\treturn point;\r\n\t},\r\n\r\n\tuntransform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\treturn new L.Point(\r\n\t\t        (point.x / scale - this._b) / this._a,\r\n\t\t        (point.y / scale - this._d) / this._c);\r\n\t}\r\n};\r\n\n\n\n/*\r\n * L.DomUtil contains various utility functions for working with DOM.\r\n */\r\n\r\nL.DomUtil = {\r\n\tget: function (id) {\r\n\t\treturn typeof id === 'string' ? document.getElementById(id) : id;\r\n\t},\r\n\r\n\tgetStyle: function (el, style) {\r\n\r\n\t\tvar value = el.style[style] || (el.currentStyle && el.currentStyle[style]);\r\n\r\n\t\tif ((!value || value === 'auto') && document.defaultView) {\r\n\t\t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n\t\t\tvalue = css ? css[style] : null;\r\n\t\t}\r\n\r\n\t\treturn value === 'auto' ? null : value;\r\n\t},\r\n\r\n\tcreate: function (tagName, className, container) {\r\n\r\n\t\tvar el = document.createElement(tagName);\r\n\t\tel.className = className;\r\n\r\n\t\tif (container) {\r\n\t\t\tcontainer.appendChild(el);\r\n\t\t}\r\n\r\n\t\treturn el;\r\n\t},\r\n\r\n\tremove: function (el) {\r\n\t\tvar parent = el.parentNode;\r\n\t\tif (parent) {\r\n\t\t\tparent.removeChild(el);\r\n\t\t}\r\n\t},\r\n\r\n\tempty: function (el) {\r\n\t\twhile (el.firstChild) {\r\n\t\t\tel.removeChild(el.firstChild);\r\n\t\t}\r\n\t},\r\n\r\n\ttoFront: function (el) {\r\n\t\tel.parentNode.appendChild(el);\r\n\t},\r\n\r\n\ttoBack: function (el) {\r\n\t\tvar parent = el.parentNode;\r\n\t\tparent.insertBefore(el, parent.firstChild);\r\n\t},\r\n\r\n\thasClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\treturn el.classList.contains(name);\r\n\t\t}\r\n\t\tvar className = L.DomUtil.getClass(el);\r\n\t\treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n\t},\r\n\r\n\taddClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tvar classes = L.Util.splitWords(name);\r\n\t\t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n\t\t\t\tel.classList.add(classes[i]);\r\n\t\t\t}\r\n\t\t} else if (!L.DomUtil.hasClass(el, name)) {\r\n\t\t\tvar className = L.DomUtil.getClass(el);\r\n\t\t\tL.DomUtil.setClass(el, (className ? className + ' ' : '') + name);\r\n\t\t}\r\n\t},\r\n\r\n\tremoveClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tel.classList.remove(name);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n\t\t}\r\n\t},\r\n\r\n\tsetClass: function (el, name) {\r\n\t\tif (el.className.baseVal === undefined) {\r\n\t\t\tel.className = name;\r\n\t\t} else {\r\n\t\t\t// in case of SVG element\r\n\t\t\tel.className.baseVal = name;\r\n\t\t}\r\n\t},\r\n\r\n\tgetClass: function (el) {\r\n\t\treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n\t},\r\n\r\n\tsetOpacity: function (el, value) {\r\n\r\n\t\tif ('opacity' in el.style) {\r\n\t\t\tel.style.opacity = value;\r\n\r\n\t\t} else if ('filter' in el.style) {\r\n\t\t\tL.DomUtil._setOpacityIE(el, value);\r\n\t\t}\r\n\t},\r\n\r\n\t_setOpacityIE: function (el, value) {\r\n\t\tvar filter = false,\r\n\t\t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n\t\t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n\t\ttry {\r\n\t\t\tfilter = el.filters.item(filterName);\r\n\t\t} catch (e) {\r\n\t\t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n\t\t\t// it isn't needed and breaks transparent pngs.\r\n\t\t\tif (value === 1) { return; }\r\n\t\t}\r\n\r\n\t\tvalue = Math.round(value * 100);\r\n\r\n\t\tif (filter) {\r\n\t\t\tfilter.Enabled = (value !== 100);\r\n\t\t\tfilter.Opacity = value;\r\n\t\t} else {\r\n\t\t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n\t\t}\r\n\t},\r\n\r\n\ttestProp: function (props) {\r\n\r\n\t\tvar style = document.documentElement.style;\r\n\r\n\t\tfor (var i = 0; i < props.length; i++) {\r\n\t\t\tif (props[i] in style) {\r\n\t\t\t\treturn props[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tsetTransform: function (el, offset, scale) {\r\n\t\tvar pos = offset || new L.Point(0, 0);\r\n\r\n\t\tel.style[L.DomUtil.TRANSFORM] =\r\n\t\t\t(L.Browser.ie3d ?\r\n\t\t\t\t'translate(' + pos.x + 'px,' + pos.y + 'px)' :\r\n\t\t\t\t'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +\r\n\t\t\t(scale ? ' scale(' + scale + ')' : '');\r\n\t},\r\n\r\n\tsetPosition: function (el, point) { // (HTMLElement, Point[, Boolean])\r\n\r\n\t\t/*eslint-disable */\r\n\t\tel._leaflet_pos = point;\r\n\t\t/*eslint-enable */\r\n\r\n\t\tif (L.Browser.any3d) {\r\n\t\t\tL.DomUtil.setTransform(el, point);\r\n\t\t} else {\r\n\t\t\tel.style.left = point.x + 'px';\r\n\t\t\tel.style.top = point.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\tgetPosition: function (el) {\r\n\t\t// this method is only used for elements previously positioned using setPosition,\r\n\t\t// so it's safe to cache the position for performance\r\n\r\n\t\treturn el._leaflet_pos;\r\n\t}\r\n};\r\n\r\n\r\n(function () {\r\n\t// prefix style property names\r\n\r\n\tL.DomUtil.TRANSFORM = L.DomUtil.testProp(\r\n\t\t\t['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n\r\n\t// webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n\t// the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\n\tvar transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(\r\n\t\t\t['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\n\tL.DomUtil.TRANSITION_END =\r\n\t\t\ttransition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';\r\n\r\n\r\n\tif ('onselectstart' in document) {\r\n\t\tL.DomUtil.disableTextSelection = function () {\r\n\t\t\tL.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\r\n\t\t};\r\n\t\tL.DomUtil.enableTextSelection = function () {\r\n\t\t\tL.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\r\n\t\t};\r\n\r\n\t} else {\r\n\t\tvar userSelectProperty = L.DomUtil.testProp(\r\n\t\t\t['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n\t\tL.DomUtil.disableTextSelection = function () {\r\n\t\t\tif (userSelectProperty) {\r\n\t\t\t\tvar style = document.documentElement.style;\r\n\t\t\t\tthis._userSelect = style[userSelectProperty];\r\n\t\t\t\tstyle[userSelectProperty] = 'none';\r\n\t\t\t}\r\n\t\t};\r\n\t\tL.DomUtil.enableTextSelection = function () {\r\n\t\t\tif (userSelectProperty) {\r\n\t\t\t\tdocument.documentElement.style[userSelectProperty] = this._userSelect;\r\n\t\t\t\tdelete this._userSelect;\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tL.DomUtil.disableImageDrag = function () {\r\n\t\tL.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t};\r\n\tL.DomUtil.enableImageDrag = function () {\r\n\t\tL.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t};\r\n\r\n\tL.DomUtil.preventOutline = function (element) {\r\n\t\twhile (element.tabIndex === -1) {\r\n\t\t\telement = element.parentNode;\r\n\t\t}\r\n\t\tif (!element || !element.style) { return; }\r\n\t\tL.DomUtil.restoreOutline();\r\n\t\tthis._outlineElement = element;\r\n\t\tthis._outlineStyle = element.style.outline;\r\n\t\telement.style.outline = 'none';\r\n\t\tL.DomEvent.on(window, 'keydown', L.DomUtil.restoreOutline, this);\r\n\t};\r\n\tL.DomUtil.restoreOutline = function () {\r\n\t\tif (!this._outlineElement) { return; }\r\n\t\tthis._outlineElement.style.outline = this._outlineStyle;\r\n\t\tdelete this._outlineElement;\r\n\t\tdelete this._outlineStyle;\r\n\t\tL.DomEvent.off(window, 'keydown', L.DomUtil.restoreOutline, this);\r\n\t};\r\n})();\r\n\n\n\n/*\r\n * L.LatLng represents a geographical point with latitude and longitude coordinates.\r\n */\r\n\r\nL.LatLng = function (lat, lng, alt) {\r\n\tif (isNaN(lat) || isNaN(lng)) {\r\n\t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n\t}\r\n\r\n\tthis.lat = +lat;\r\n\tthis.lng = +lng;\r\n\r\n\tif (alt !== undefined) {\r\n\t\tthis.alt = +alt;\r\n\t}\r\n};\r\n\r\nL.LatLng.prototype = {\r\n\tequals: function (obj, maxMargin) {\r\n\t\tif (!obj) { return false; }\r\n\r\n\t\tobj = L.latLng(obj);\r\n\r\n\t\tvar margin = Math.max(\r\n\t\t        Math.abs(this.lat - obj.lat),\r\n\t\t        Math.abs(this.lng - obj.lng));\r\n\r\n\t\treturn margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\r\n\t},\r\n\r\n\ttoString: function (precision) {\r\n\t\treturn 'LatLng(' +\r\n\t\t        L.Util.formatNum(this.lat, precision) + ', ' +\r\n\t\t        L.Util.formatNum(this.lng, precision) + ')';\r\n\t},\r\n\r\n\tdistanceTo: function (other) {\r\n\t\treturn L.CRS.Earth.distance(this, L.latLng(other));\r\n\t},\r\n\r\n\twrap: function () {\r\n\t\treturn L.CRS.Earth.wrapLatLng(this);\r\n\t},\r\n\r\n\ttoBounds: function (sizeInMeters) {\r\n\t\tvar latAccuracy = 180 * sizeInMeters / 40075017,\r\n\t\t    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);\r\n\r\n\t\treturn L.latLngBounds(\r\n\t\t        [this.lat - latAccuracy, this.lng - lngAccuracy],\r\n\t\t        [this.lat + latAccuracy, this.lng + lngAccuracy]);\r\n\t},\r\n\r\n\tclone: function () {\r\n\t\treturn new L.LatLng(this.lat, this.lng, this.alt);\r\n\t}\r\n};\r\n\r\n\r\n// constructs LatLng with different signatures\r\n// (LatLng) or ([Number, Number]) or (Number, Number) or (Object)\r\n\r\nL.latLng = function (a, b, c) {\r\n\tif (a instanceof L.LatLng) {\r\n\t\treturn a;\r\n\t}\r\n\tif (L.Util.isArray(a) && typeof a[0] !== 'object') {\r\n\t\tif (a.length === 3) {\r\n\t\t\treturn new L.LatLng(a[0], a[1], a[2]);\r\n\t\t}\r\n\t\tif (a.length === 2) {\r\n\t\t\treturn new L.LatLng(a[0], a[1]);\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\tif (a === undefined || a === null) {\r\n\t\treturn a;\r\n\t}\r\n\tif (typeof a === 'object' && 'lat' in a) {\r\n\t\treturn new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\r\n\t}\r\n\tif (b === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\treturn new L.LatLng(a, b, c);\r\n};\r\n\n\n\n/*\r\n * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\r\n */\r\n\r\nL.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])\r\n\tif (!southWest) { return; }\r\n\r\n\tvar latlngs = northEast ? [southWest, northEast] : southWest;\r\n\r\n\tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n\t\tthis.extend(latlngs[i]);\r\n\t}\r\n};\r\n\r\nL.LatLngBounds.prototype = {\r\n\r\n\t// extend the bounds to contain the given point or bounds\r\n\textend: function (obj) { // (LatLng) or (LatLngBounds)\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2, ne2;\r\n\r\n\t\tif (obj instanceof L.LatLng) {\r\n\t\t\tsw2 = obj;\r\n\t\t\tne2 = obj;\r\n\r\n\t\t} else if (obj instanceof L.LatLngBounds) {\r\n\t\t\tsw2 = obj._southWest;\r\n\t\t\tne2 = obj._northEast;\r\n\r\n\t\t\tif (!sw2 || !ne2) { return this; }\r\n\r\n\t\t} else {\r\n\t\t\treturn obj ? this.extend(L.latLng(obj) || L.latLngBounds(obj)) : this;\r\n\t\t}\r\n\r\n\t\tif (!sw && !ne) {\r\n\t\t\tthis._southWest = new L.LatLng(sw2.lat, sw2.lng);\r\n\t\t\tthis._northEast = new L.LatLng(ne2.lat, ne2.lng);\r\n\t\t} else {\r\n\t\t\tsw.lat = Math.min(sw2.lat, sw.lat);\r\n\t\t\tsw.lng = Math.min(sw2.lng, sw.lng);\r\n\t\t\tne.lat = Math.max(ne2.lat, ne.lat);\r\n\t\t\tne.lng = Math.max(ne2.lng, ne.lng);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// extend the bounds by a percentage\r\n\tpad: function (bufferRatio) { // (Number) -> LatLngBounds\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n\t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n\t\t        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n\t},\r\n\r\n\tgetCenter: function () { // -> LatLng\r\n\t\treturn new L.LatLng(\r\n\t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n\t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n\t},\r\n\r\n\tgetSouthWest: function () {\r\n\t\treturn this._southWest;\r\n\t},\r\n\r\n\tgetNorthEast: function () {\r\n\t\treturn this._northEast;\r\n\t},\r\n\r\n\tgetNorthWest: function () {\r\n\t\treturn new L.LatLng(this.getNorth(), this.getWest());\r\n\t},\r\n\r\n\tgetSouthEast: function () {\r\n\t\treturn new L.LatLng(this.getSouth(), this.getEast());\r\n\t},\r\n\r\n\tgetWest: function () {\r\n\t\treturn this._southWest.lng;\r\n\t},\r\n\r\n\tgetSouth: function () {\r\n\t\treturn this._southWest.lat;\r\n\t},\r\n\r\n\tgetEast: function () {\r\n\t\treturn this._northEast.lng;\r\n\t},\r\n\r\n\tgetNorth: function () {\r\n\t\treturn this._northEast.lat;\r\n\t},\r\n\r\n\tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\r\n\t\t\tobj = L.latLng(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2, ne2;\r\n\r\n\t\tif (obj instanceof L.LatLngBounds) {\r\n\t\t\tsw2 = obj.getSouthWest();\r\n\t\t\tne2 = obj.getNorthEast();\r\n\t\t} else {\r\n\t\t\tsw2 = ne2 = obj;\r\n\t\t}\r\n\r\n\t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n\t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (LatLngBounds) -> Boolean\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2 = bounds.getSouthWest(),\r\n\t\t    ne2 = bounds.getNorthEast(),\r\n\r\n\t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n\t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n\t\treturn latIntersects && lngIntersects;\r\n\t},\r\n\r\n\toverlaps: function (bounds) { // (LatLngBounds) -> Boolean\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2 = bounds.getSouthWest(),\r\n\t\t    ne2 = bounds.getNorthEast(),\r\n\r\n\t\t    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),\r\n\t\t    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);\r\n\r\n\t\treturn latOverlaps && lngOverlaps;\r\n\t},\r\n\r\n\ttoBBoxString: function () {\r\n\t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n\t},\r\n\r\n\tequals: function (bounds) { // (LatLngBounds)\r\n\t\tif (!bounds) { return false; }\r\n\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\treturn this._southWest.equals(bounds.getSouthWest()) &&\r\n\t\t       this._northEast.equals(bounds.getNorthEast());\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this._southWest && this._northEast);\r\n\t}\r\n};\r\n\r\n// TODO International date line?\r\n\r\nL.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)\r\n\tif (!a || a instanceof L.LatLngBounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.LatLngBounds(a, b);\r\n};\r\n\n\n\n/*\r\n * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\r\n */\r\n\r\nL.Projection = {};\r\n\r\nL.Projection.LonLat = {\r\n\tproject: function (latlng) {\r\n\t\treturn new L.Point(latlng.lng, latlng.lat);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\treturn new L.LatLng(point.y, point.x);\r\n\t},\r\n\r\n\tbounds: L.bounds([-180, -90], [180, 90])\r\n};\r\n\n\n\n/*\r\n * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\r\n */\r\n\r\nL.Projection.SphericalMercator = {\r\n\r\n\tR: 6378137,\r\n\tMAX_LATITUDE: 85.0511287798,\r\n\r\n\tproject: function (latlng) {\r\n\t\tvar d = Math.PI / 180,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    sin = Math.sin(lat * d);\r\n\r\n\t\treturn new L.Point(\r\n\t\t\t\tthis.R * latlng.lng * d,\r\n\t\t\t\tthis.R * Math.log((1 + sin) / (1 - sin)) / 2);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\tvar d = 180 / Math.PI;\r\n\r\n\t\treturn new L.LatLng(\r\n\t\t\t(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,\r\n\t\t\tpoint.x * d / this.R);\r\n\t},\r\n\r\n\tbounds: (function () {\r\n\t\tvar d = 6378137 * Math.PI;\r\n\t\treturn L.bounds([-d, -d], [d, d]);\r\n\t})()\r\n};\r\n\n\n\n/*\r\n * L.CRS is the base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\r\n */\r\n\r\nL.CRS = {\r\n\t// converts geo coords to pixel ones\r\n\tlatLngToPoint: function (latlng, zoom) {\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    scale = this.scale(zoom);\r\n\r\n\t\treturn this.transformation._transform(projectedPoint, scale);\r\n\t},\r\n\r\n\t// converts pixel coords to geo coords\r\n\tpointToLatLng: function (point, zoom) {\r\n\t\tvar scale = this.scale(zoom),\r\n\t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n\t\treturn this.projection.unproject(untransformedPoint);\r\n\t},\r\n\r\n\t// converts geo coords to projection-specific coords (e.g. in meters)\r\n\tproject: function (latlng) {\r\n\t\treturn this.projection.project(latlng);\r\n\t},\r\n\r\n\t// converts projected coords to geo coords\r\n\tunproject: function (point) {\r\n\t\treturn this.projection.unproject(point);\r\n\t},\r\n\r\n\t// defines how the world scales with zoom\r\n\tscale: function (zoom) {\r\n\t\treturn 256 * Math.pow(2, zoom);\r\n\t},\r\n\r\n\tzoom: function (scale) {\r\n\t\treturn Math.log(scale / 256) / Math.LN2;\r\n\t},\r\n\r\n\t// returns the bounds of the world in projected coords if applicable\r\n\tgetProjectedBounds: function (zoom) {\r\n\t\tif (this.infinite) { return null; }\r\n\r\n\t\tvar b = this.projection.bounds,\r\n\t\t    s = this.scale(zoom),\r\n\t\t    min = this.transformation.transform(b.min, s),\r\n\t\t    max = this.transformation.transform(b.max, s);\r\n\r\n\t\treturn L.bounds(min, max);\r\n\t},\r\n\r\n\t// whether a coordinate axis wraps in a given range (e.g. longitude from -180 to 180); depends on CRS\r\n\t// wrapLng: [min, max],\r\n\t// wrapLat: [min, max],\r\n\r\n\t// if true, the coordinate space will be unbounded (infinite in all directions)\r\n\t// infinite: false,\r\n\r\n\t// wraps geo coords in certain ranges if applicable\r\n\twrapLatLng: function (latlng) {\r\n\t\tvar lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\r\n\t\t    lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\r\n\t\t    alt = latlng.alt;\r\n\r\n\t\treturn L.latLng(lat, lng, alt);\r\n\t}\r\n};\r\n\n\n\n/*\n * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n */\n\nL.CRS.Simple = L.extend({}, L.CRS, {\n\tprojection: L.Projection.LonLat,\n\ttransformation: new L.Transformation(1, 0, -1, 0),\n\n\tscale: function (zoom) {\n\t\treturn Math.pow(2, zoom);\n\t},\n\n\tzoom: function (scale) {\n\t\treturn Math.log(scale) / Math.LN2;\n\t},\n\n\tdistance: function (latlng1, latlng2) {\n\t\tvar dx = latlng2.lng - latlng1.lng,\n\t\t    dy = latlng2.lat - latlng1.lat;\n\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t},\n\n\tinfinite: true\n});\n\n\n\n/*\n * L.CRS.Earth is the base class for all CRS representing Earth.\n */\n\nL.CRS.Earth = L.extend({}, L.CRS, {\n\twrapLng: [-180, 180],\n\n\tR: 6378137,\n\n\t// distance between two geographical points using spherical law of cosines approximation\n\tdistance: function (latlng1, latlng2) {\n\t\tvar rad = Math.PI / 180,\n\t\t    lat1 = latlng1.lat * rad,\n\t\t    lat2 = latlng2.lat * rad,\n\t\t    a = Math.sin(lat1) * Math.sin(lat2) +\n\t\t        Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);\n\n\t\treturn this.R * Math.acos(Math.min(a, 1));\n\t}\n});\n\n\n\n/*\r\n * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping and is used by Leaflet by default.\r\n */\r\n\r\nL.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {\r\n\tcode: 'EPSG:3857',\r\n\tprojection: L.Projection.SphericalMercator,\r\n\r\n\ttransformation: (function () {\r\n\t\tvar scale = 0.5 / (Math.PI * L.Projection.SphericalMercator.R);\r\n\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\r\n\t}())\r\n});\r\n\r\nL.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\r\n\tcode: 'EPSG:900913'\r\n});\r\n\n\n\n/*\r\n * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\r\n */\r\n\r\nL.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {\r\n\tcode: 'EPSG:4326',\r\n\tprojection: L.Projection.LonLat,\r\n\ttransformation: new L.Transformation(1 / 180, 1, -1 / 180, 0.5)\r\n});\r\n\n\n\n/*\r\n * L.Map is the central class of the API - it is used to create a map.\r\n */\r\n\r\nL.Map = L.Evented.extend({\r\n\r\n\toptions: {\r\n\t\tcrs: L.CRS.EPSG3857,\r\n\r\n\t\t/*\r\n\t\tcenter: LatLng,\r\n\t\tzoom: Number,\r\n\t\tlayers: Array,\r\n\t\t*/\r\n\r\n\t\tfadeAnimation: true,\r\n\t\ttrackResize: true,\r\n\t\tmarkerZoomAnimation: true,\r\n\t\tmaxBoundsViscosity: 0.0,\r\n\t\ttransform3DLimit: 8388608 // Precision limit of a 32-bit float\r\n\t},\r\n\r\n\tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\tthis._initContainer(id);\r\n\t\tthis._initLayout();\r\n\r\n\t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n\t\tthis._onResize = L.bind(this._onResize, this);\r\n\r\n\t\tthis._initEvents();\r\n\r\n\t\tif (options.maxBounds) {\r\n\t\t\tthis.setMaxBounds(options.maxBounds);\r\n\t\t}\r\n\r\n\t\tif (options.zoom !== undefined) {\r\n\t\t\tthis._zoom = this._limitZoom(options.zoom);\r\n\t\t}\r\n\r\n\t\tif (options.center && options.zoom !== undefined) {\r\n\t\t\tthis.setView(L.latLng(options.center), options.zoom, {reset: true});\r\n\t\t}\r\n\r\n\t\tthis._handlers = [];\r\n\t\tthis._layers = {};\r\n\t\tthis._zoomBoundLayers = {};\r\n\t\tthis._sizeChanged = true;\r\n\r\n\t\tthis.callInitHooks();\r\n\r\n\t\tthis._addLayers(this.options.layers);\r\n\t},\r\n\r\n\r\n\t// public methods that modify map state\r\n\r\n\t// replaced by animation-powered implementation in Map.PanAnimation.js\r\n\tsetView: function (center, zoom) {\r\n\t\tzoom = zoom === undefined ? this.getZoom() : zoom;\r\n\t\tthis._resetView(L.latLng(center), zoom);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZoom: function (zoom, options) {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthis._zoom = zoom;\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n\t},\r\n\r\n\tzoomIn: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom + (delta || 1), options);\r\n\t},\r\n\r\n\tzoomOut: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom - (delta || 1), options);\r\n\t},\r\n\r\n\tsetZoomAround: function (latlng, zoom, options) {\r\n\t\tvar scale = this.getZoomScale(zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n\t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n\t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n\t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n\t},\r\n\r\n\t_getBoundsCenterZoom: function (bounds, options) {\r\n\r\n\t\toptions = options || {};\r\n\t\tbounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\r\n\r\n\t\tvar paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n\t\t    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n\t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\r\n\t\tzoom = options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n\t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n\t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n\t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n\t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n\t\treturn {\r\n\t\t\tcenter: center,\r\n\t\t\tzoom: zoom\r\n\t\t};\r\n\t},\r\n\r\n\tfitBounds: function (bounds, options) {\r\n\t\tvar target = this._getBoundsCenterZoom(bounds, options);\r\n\t\treturn this.setView(target.center, target.zoom, options);\r\n\t},\r\n\r\n\tfitWorld: function (options) {\r\n\t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n\t},\r\n\r\n\tpanTo: function (center, options) { // (LatLng)\r\n\t\treturn this.setView(center, this._zoom, {pan: options});\r\n\t},\r\n\r\n\tpanBy: function (offset) { // (Point)\r\n\t\t// replaced with animated panBy in Map.PanAnimation.js\r\n\t\tthis.fire('movestart');\r\n\r\n\t\tthis._rawPanBy(L.point(offset));\r\n\r\n\t\tthis.fire('move');\r\n\t\treturn this.fire('moveend');\r\n\t},\r\n\r\n\tsetMaxBounds: function (bounds) {\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tif (!bounds) {\r\n\t\t\treturn this.off('moveend', this._panInsideMaxBounds);\r\n\t\t} else if (this.options.maxBounds) {\r\n\t\t\tthis.off('moveend', this._panInsideMaxBounds);\r\n\t\t}\r\n\r\n\t\tthis.options.maxBounds = bounds;\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._panInsideMaxBounds();\r\n\t\t}\r\n\r\n\t\treturn this.on('moveend', this._panInsideMaxBounds);\r\n\t},\r\n\r\n\tsetMinZoom: function (zoom) {\r\n\t\tthis.options.minZoom = zoom;\r\n\r\n\t\tif (this._loaded && this.getZoom() < this.options.minZoom) {\r\n\t\t\treturn this.setZoom(zoom);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetMaxZoom: function (zoom) {\r\n\t\tthis.options.maxZoom = zoom;\r\n\r\n\t\tif (this._loaded && (this.getZoom() > this.options.maxZoom)) {\r\n\t\t\treturn this.setZoom(zoom);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tpanInsideBounds: function (bounds, options) {\r\n\t\tthis._enforcingBounds = true;\r\n\t\tvar center = this.getCenter(),\r\n\t\t    newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));\r\n\r\n\t\tif (center.equals(newCenter)) { return this; }\r\n\r\n\t\tthis.panTo(newCenter, options);\r\n\t\tthis._enforcingBounds = false;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvalidateSize: function (options) {\r\n\t\tif (!this._loaded) { return this; }\r\n\r\n\t\toptions = L.extend({\r\n\t\t\tanimate: false,\r\n\t\t\tpan: true\r\n\t\t}, options === true ? {animate: true} : options);\r\n\r\n\t\tvar oldSize = this.getSize();\r\n\t\tthis._sizeChanged = true;\r\n\t\tthis._lastCenter = null;\r\n\r\n\t\tvar newSize = this.getSize(),\r\n\t\t    oldCenter = oldSize.divideBy(2).round(),\r\n\t\t    newCenter = newSize.divideBy(2).round(),\r\n\t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n\t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n\t\tif (options.animate && options.pan) {\r\n\t\t\tthis.panBy(offset);\r\n\r\n\t\t} else {\r\n\t\t\tif (options.pan) {\r\n\t\t\t\tthis._rawPanBy(offset);\r\n\t\t\t}\r\n\r\n\t\t\tthis.fire('move');\r\n\r\n\t\t\tif (options.debounceMoveend) {\r\n\t\t\t\tclearTimeout(this._sizeTimer);\r\n\t\t\t\tthis._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\r\n\t\t\t} else {\r\n\t\t\t\tthis.fire('moveend');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.fire('resize', {\r\n\t\t\toldSize: oldSize,\r\n\t\t\tnewSize: newSize\r\n\t\t});\r\n\t},\r\n\r\n\tstop: function () {\r\n\t\tL.Util.cancelAnimFrame(this._flyToFrame);\r\n\t\tif (this._panAnim) {\r\n\t\t\tthis._panAnim.stop();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// TODO handler.addTo\r\n\taddHandler: function (name, HandlerClass) {\r\n\t\tif (!HandlerClass) { return this; }\r\n\r\n\t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n\t\tthis._handlers.push(handler);\r\n\r\n\t\tif (this.options[name]) {\r\n\t\t\thandler.enable();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremove: function () {\r\n\r\n\t\tthis._initEvents(true);\r\n\r\n\t\ttry {\r\n\t\t\t// throws error in IE6-8\r\n\t\t\tdelete this._container._leaflet;\r\n\t\t} catch (e) {\r\n\t\t\tthis._container._leaflet = undefined;\r\n\t\t}\r\n\r\n\t\tL.DomUtil.remove(this._mapPane);\r\n\r\n\t\tif (this._clearControlPos) {\r\n\t\t\tthis._clearControlPos();\r\n\t\t}\r\n\r\n\t\tthis._clearHandlers();\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('unload');\r\n\t\t}\r\n\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tthis._layers[i].remove();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tcreatePane: function (name, container) {\r\n\t\tvar className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\r\n\t\t    pane = L.DomUtil.create('div', className, container || this._mapPane);\r\n\r\n\t\tif (name) {\r\n\t\t\tthis._panes[name] = pane;\r\n\t\t}\r\n\t\treturn pane;\r\n\t},\r\n\r\n\r\n\t// public methods for getting map state\r\n\r\n\tgetCenter: function () { // (Boolean) -> LatLng\r\n\t\tthis._checkIfLoaded();\r\n\r\n\t\tif (this._lastCenter && !this._moved()) {\r\n\t\t\treturn this._lastCenter;\r\n\t\t}\r\n\t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\tgetZoom: function () {\r\n\t\treturn this._zoom;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = this.getPixelBounds(),\r\n\t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n\t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n\t\treturn new L.LatLngBounds(sw, ne);\r\n\t},\r\n\r\n\tgetMinZoom: function () {\r\n\t\treturn this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\r\n\t},\r\n\r\n\tgetMaxZoom: function () {\r\n\t\treturn this.options.maxZoom === undefined ?\r\n\t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n\t\t\tthis.options.maxZoom;\r\n\t},\r\n\r\n\tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar zoom = this.getMinZoom() - (inside ? 1 : 0),\r\n\t\t    maxZoom = this.getMaxZoom(),\r\n\t\t    size = this.getSize(),\r\n\r\n\t\t    nw = bounds.getNorthWest(),\r\n\t\t    se = bounds.getSouthEast(),\r\n\r\n\t\t    zoomNotFound = true,\r\n\t\t    boundsSize;\r\n\r\n\t\tpadding = L.point(padding || [0, 0]);\r\n\r\n\t\tdo {\r\n\t\t\tzoom++;\r\n\t\t\tboundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding).floor();\r\n\t\t\tzoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\r\n\r\n\t\t} while (zoomNotFound && zoom <= maxZoom);\r\n\r\n\t\tif (zoomNotFound && inside) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn inside ? zoom : zoom - 1;\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\tif (!this._size || this._sizeChanged) {\r\n\t\t\tthis._size = new L.Point(\r\n\t\t\t\tthis._container.clientWidth,\r\n\t\t\t\tthis._container.clientHeight);\r\n\r\n\t\t\tthis._sizeChanged = false;\r\n\t\t}\r\n\t\treturn this._size.clone();\r\n\t},\r\n\r\n\tgetPixelBounds: function (center, zoom) {\r\n\t\tvar topLeftPoint = this._getTopLeftPoint(center, zoom);\r\n\t\treturn new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n\t},\r\n\r\n\tgetPixelOrigin: function () {\r\n\t\tthis._checkIfLoaded();\r\n\t\treturn this._pixelOrigin;\r\n\t},\r\n\r\n\tgetPixelWorldBounds: function (zoom) {\r\n\t\treturn this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\r\n\t},\r\n\r\n\tgetPane: function (pane) {\r\n\t\treturn typeof pane === 'string' ? this._panes[pane] : pane;\r\n\t},\r\n\r\n\tgetPanes: function () {\r\n\t\treturn this._panes;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\r\n\t// TODO replace with universal implementation after refactoring projections\r\n\r\n\tgetZoomScale: function (toZoom, fromZoom) {\r\n\t\tvar crs = this.options.crs;\r\n\t\tfromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n\t\treturn crs.scale(toZoom) / crs.scale(fromZoom);\r\n\t},\r\n\r\n\tgetScaleZoom: function (scale, fromZoom) {\r\n\t\tvar crs = this.options.crs;\r\n\t\tfromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n\t\treturn crs.zoom(scale * crs.scale(fromZoom));\r\n\t},\r\n\r\n\t// conversion methods\r\n\r\n\tproject: function (latlng, zoom) { // (LatLng[, Number]) -> Point\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\r\n\t},\r\n\r\n\tunproject: function (point, zoom) { // (Point[, Number]) -> LatLng\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.pointToLatLng(L.point(point), zoom);\r\n\t},\r\n\r\n\tlayerPointToLatLng: function (point) { // (Point)\r\n\t\tvar projectedPoint = L.point(point).add(this.getPixelOrigin());\r\n\t\treturn this.unproject(projectedPoint);\r\n\t},\r\n\r\n\tlatLngToLayerPoint: function (latlng) { // (LatLng)\r\n\t\tvar projectedPoint = this.project(L.latLng(latlng))._round();\r\n\t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n\t},\r\n\r\n\twrapLatLng: function (latlng) {\r\n\t\treturn this.options.crs.wrapLatLng(L.latLng(latlng));\r\n\t},\r\n\r\n\tdistance: function (latlng1, latlng2) {\r\n\t\treturn this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2));\r\n\t},\r\n\r\n\tcontainerPointToLayerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\tlayerPointToContainerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).add(this._getMapPanePos());\r\n\t},\r\n\r\n\tcontainerPointToLatLng: function (point) {\r\n\t\tvar layerPoint = this.containerPointToLayerPoint(L.point(point));\r\n\t\treturn this.layerPointToLatLng(layerPoint);\r\n\t},\r\n\r\n\tlatLngToContainerPoint: function (latlng) {\r\n\t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\r\n\t},\r\n\r\n\tmouseEventToContainerPoint: function (e) { // (MouseEvent)\r\n\t\treturn L.DomEvent.getMousePosition(e, this._container);\r\n\t},\r\n\r\n\tmouseEventToLayerPoint: function (e) { // (MouseEvent)\r\n\t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n\t},\r\n\r\n\tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n\t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n\t},\r\n\r\n\r\n\t// map initialization methods\r\n\r\n\t_initContainer: function (id) {\r\n\t\tvar container = this._container = L.DomUtil.get(id);\r\n\r\n\t\tif (!container) {\r\n\t\t\tthrow new Error('Map container not found.');\r\n\t\t} else if (container._leaflet) {\r\n\t\t\tthrow new Error('Map container is already initialized.');\r\n\t\t}\r\n\r\n\t\tL.DomEvent.addListener(container, 'scroll', this._onScroll, this);\r\n\t\tcontainer._leaflet = true;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar container = this._container;\r\n\r\n\t\tthis._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-container' +\r\n\t\t\t(L.Browser.touch ? ' leaflet-touch' : '') +\r\n\t\t\t(L.Browser.retina ? ' leaflet-retina' : '') +\r\n\t\t\t(L.Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n\t\t\t(L.Browser.safari ? ' leaflet-safari' : '') +\r\n\t\t\t(this._fadeAnimated ? ' leaflet-fade-anim' : ''));\r\n\r\n\t\tvar position = L.DomUtil.getStyle(container, 'position');\r\n\r\n\t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n\t\t\tcontainer.style.position = 'relative';\r\n\t\t}\r\n\r\n\t\tthis._initPanes();\r\n\r\n\t\tif (this._initControlPos) {\r\n\t\t\tthis._initControlPos();\r\n\t\t}\r\n\t},\r\n\r\n\t_initPanes: function () {\r\n\t\tvar panes = this._panes = {};\r\n\t\tthis._paneRenderers = {};\r\n\r\n\t\tthis._mapPane = this.createPane('mapPane', this._container);\r\n\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\r\n\t\tthis.createPane('tilePane');\r\n\t\tthis.createPane('shadowPane');\r\n\t\tthis.createPane('overlayPane');\r\n\t\tthis.createPane('markerPane');\r\n\t\tthis.createPane('popupPane');\r\n\r\n\t\tif (!this.options.markerZoomAnimation) {\r\n\t\t\tL.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');\r\n\t\t\tL.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// private methods that modify map state\r\n\r\n\t_resetView: function (center, zoom) {\r\n\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\r\n\t\tvar loading = !this._loaded;\r\n\t\tthis._loaded = true;\r\n\t\tzoom = this._limitZoom(zoom);\r\n\r\n\t\tvar zoomChanged = this._zoom !== zoom;\r\n\t\tthis\r\n\t\t\t._moveStart(zoomChanged)\r\n\t\t\t._move(center, zoom)\r\n\t\t\t._moveEnd(zoomChanged);\r\n\r\n\t\tthis.fire('viewreset');\r\n\r\n\t\tif (loading) {\r\n\t\t\tthis.fire('load');\r\n\t\t}\r\n\t},\r\n\r\n\t_moveStart: function (zoomChanged) {\r\n\t\tif (zoomChanged) {\r\n\t\t\tthis.fire('zoomstart');\r\n\t\t}\r\n\t\treturn this.fire('movestart');\r\n\t},\r\n\r\n\t_move: function (center, zoom, data) {\r\n\t\tif (zoom === undefined) {\r\n\t\t\tzoom = this._zoom;\r\n\t\t}\r\n\r\n\t\tvar zoomChanged = this._zoom !== zoom;\r\n\r\n\t\tthis._zoom = zoom;\r\n\t\tthis._lastCenter = center;\r\n\t\tthis._pixelOrigin = this._getNewPixelOrigin(center);\r\n\r\n\t\tif (zoomChanged) {\r\n\t\t\tthis.fire('zoom', data);\r\n\t\t}\r\n\t\treturn this.fire('move', data);\r\n\t},\r\n\r\n\t_moveEnd: function (zoomChanged) {\r\n\t\tif (zoomChanged) {\r\n\t\t\tthis.fire('zoomend');\r\n\t\t}\r\n\t\treturn this.fire('moveend');\r\n\t},\r\n\r\n\t_rawPanBy: function (offset) {\r\n\t\tL.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n\t},\r\n\r\n\t_getZoomSpan: function () {\r\n\t\treturn this.getMaxZoom() - this.getMinZoom();\r\n\t},\r\n\r\n\t_panInsideMaxBounds: function () {\r\n\t\tif (!this._enforcingBounds) {\r\n\t\t\tthis.panInsideBounds(this.options.maxBounds);\r\n\t\t}\r\n\t},\r\n\r\n\t_checkIfLoaded: function () {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthrow new Error('Set map center and zoom first.');\r\n\t\t}\r\n\t},\r\n\r\n\t// DOM event handling\r\n\r\n\t_initEvents: function (remove) {\r\n\t\tif (!L.DomEvent) { return; }\r\n\r\n\t\tthis._targets = {};\r\n\t\tthis._targets[L.stamp(this._container)] = this;\r\n\r\n\t\tvar onOff = remove ? 'off' : 'on';\r\n\r\n\t\tL.DomEvent[onOff](this._container, 'click dblclick mousedown mouseup ' +\r\n\t\t\t'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);\r\n\r\n\t\tif (this.options.trackResize) {\r\n\t\t\tL.DomEvent[onOff](window, 'resize', this._onResize, this);\r\n\t\t}\r\n\r\n\t\tif (L.Browser.any3d && this.options.transform3DLimit) {\r\n\t\t\tthis[onOff]('moveend', this._onMoveEnd);\r\n\t\t}\r\n\t},\r\n\r\n\t_onResize: function () {\r\n\t\tL.Util.cancelAnimFrame(this._resizeRequest);\r\n\t\tthis._resizeRequest = L.Util.requestAnimFrame(\r\n\t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this);\r\n\t},\r\n\r\n\t_onScroll: function () {\r\n\t\tthis._container.scrollTop  = 0;\r\n\t\tthis._container.scrollLeft = 0;\r\n\t},\r\n\r\n\t_onMoveEnd: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\tif (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\r\n\t\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\r\n\t\t\t// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/\r\n\t\t\tthis._resetView(this.getCenter(), this.getZoom());\r\n\t\t}\r\n\t},\r\n\r\n\t_findEventTargets: function (e, type) {\r\n\t\tvar targets = [],\r\n\t\t    target,\r\n\t\t    isHover = type === 'mouseout' || type === 'mouseover',\r\n\t\t    src = e.target || e.srcElement;\r\n\r\n\t\twhile (src) {\r\n\t\t\ttarget = this._targets[L.stamp(src)];\r\n\t\t\tif (target && target.listens(type, true)) {\r\n\t\t\t\tif (isHover && !L.DomEvent._isExternalTarget(src, e)) { break; }\r\n\t\t\t\ttargets.push(target);\r\n\t\t\t\tif (isHover) { break; }\r\n\t\t\t}\r\n\t\t\tif (src === this._container) { break; }\r\n\t\t\tsrc = src.parentNode;\r\n\t\t}\r\n\t\tif (!targets.length && !isHover && L.DomEvent._isExternalTarget(src, e)) {\r\n\t\t\ttargets = [this];\r\n\t\t}\r\n\t\treturn targets;\r\n\t},\r\n\r\n\t_handleDOMEvent: function (e) {\r\n\t\tif (!this._loaded || L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\t// find the layer the event is propagating from and its parents\r\n\t\tvar type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;\r\n\r\n\t\tif (e.type === 'click') {\r\n\t\t\t// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\r\n\t\t\tvar synth = L.Util.extend({}, e);\r\n\t\t\tsynth.type = 'preclick';\r\n\t\t\tthis._handleDOMEvent(synth);\r\n\t\t}\r\n\r\n\t\tif (type === 'mousedown') {\r\n\t\t\t// prevents outline when clicking on keyboard-focusable element\r\n\t\t\tL.DomUtil.preventOutline(e.target || e.srcElement);\r\n\t\t}\r\n\r\n\t\tthis._fireDOMEvent(e, type);\r\n\t},\r\n\r\n\t_fireDOMEvent: function (e, type, targets) {\r\n\r\n\t\tif (e._stopped) { return; }\r\n\r\n\t\ttargets = (targets || []).concat(this._findEventTargets(e, type));\r\n\r\n\t\tif (!targets.length) { return; }\r\n\r\n\t\tvar target = targets[0];\r\n\t\tif (type === 'contextmenu' && target.listens(type, true)) {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\r\n\t\t// prevents firing click after you just dragged an object\r\n\t\tif ((e.type === 'click' || e.type === 'preclick') && !e._simulated && this._draggableMoved(target)) { return; }\r\n\r\n\t\tvar data = {\r\n\t\t\toriginalEvent: e\r\n\t\t};\r\n\r\n\t\tif (e.type !== 'keypress') {\r\n\t\t\tvar isMarker = target instanceof L.Marker;\r\n\t\t\tdata.containerPoint = isMarker ?\r\n\t\t\t\t\tthis.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\r\n\t\t\tdata.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\r\n\t\t\tdata.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < targets.length; i++) {\r\n\t\t\ttargets[i].fire(type, data, true);\r\n\t\t\tif (data.originalEvent._stopped ||\r\n\t\t\t\t(targets[i].options.nonBubblingEvents && L.Util.indexOf(targets[i].options.nonBubblingEvents, type) !== -1)) { return; }\r\n\t\t}\r\n\t},\r\n\r\n\t_draggableMoved: function (obj) {\r\n\t\tobj = obj.options.draggable ? obj : this;\r\n\t\treturn (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());\r\n\t},\r\n\r\n\t_clearHandlers: function () {\r\n\t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n\t\t\tthis._handlers[i].disable();\r\n\t\t}\r\n\t},\r\n\r\n\twhenReady: function (callback, context) {\r\n\t\tif (this._loaded) {\r\n\t\t\tcallback.call(context || this, {target: this});\r\n\t\t} else {\r\n\t\t\tthis.on('load', callback, context);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\r\n\t// private methods for getting map state\r\n\r\n\t_getMapPanePos: function () {\r\n\t\treturn L.DomUtil.getPosition(this._mapPane) || new L.Point(0, 0);\r\n\t},\r\n\r\n\t_moved: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\treturn pos && !pos.equals([0, 0]);\r\n\t},\r\n\r\n\t_getTopLeftPoint: function (center, zoom) {\r\n\t\tvar pixelOrigin = center && zoom !== undefined ?\r\n\t\t\tthis._getNewPixelOrigin(center, zoom) :\r\n\t\t\tthis.getPixelOrigin();\r\n\t\treturn pixelOrigin.subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\t_getNewPixelOrigin: function (center, zoom) {\r\n\t\tvar viewHalf = this.getSize()._divideBy(2);\r\n\t\treturn this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\r\n\t},\r\n\r\n\t_latLngToNewLayerPoint: function (latlng, zoom, center) {\r\n\t\tvar topLeft = this._getNewPixelOrigin(center, zoom);\r\n\t\treturn this.project(latlng, zoom)._subtract(topLeft);\r\n\t},\r\n\r\n\t// layer point of the current center\r\n\t_getCenterLayerPoint: function () {\r\n\t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n\t},\r\n\r\n\t// offset of the specified place to the current center in pixels\r\n\t_getCenterOffset: function (latlng) {\r\n\t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\t// adjust center for view to get inside bounds\r\n\t_limitCenter: function (center, zoom, bounds) {\r\n\r\n\t\tif (!bounds) { return center; }\r\n\r\n\t\tvar centerPoint = this.project(center, zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n\t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n\t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n\t},\r\n\r\n\t// adjust offset for view to get inside bounds\r\n\t_limitOffset: function (offset, bounds) {\r\n\t\tif (!bounds) { return offset; }\r\n\r\n\t\tvar viewBounds = this.getPixelBounds(),\r\n\t\t    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n\t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n\t},\r\n\r\n\t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n\t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n\t\tvar nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\r\n\t\t    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\r\n\r\n\t\t    dx = this._rebound(nwOffset.x, -seOffset.x),\r\n\t\t    dy = this._rebound(nwOffset.y, -seOffset.y);\r\n\r\n\t\treturn new L.Point(dx, dy);\r\n\t},\r\n\r\n\t_rebound: function (left, right) {\r\n\t\treturn left + right > 0 ?\r\n\t\t\tMath.round(left - right) / 2 :\r\n\t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n\t},\r\n\r\n\t_limitZoom: function (zoom) {\r\n\t\tvar min = this.getMinZoom(),\r\n\t\t    max = this.getMaxZoom();\r\n\t\tif (!L.Browser.any3d) { zoom = Math.round(zoom); }\r\n\r\n\t\treturn Math.max(min, Math.min(max, zoom));\r\n\t}\r\n});\r\n\r\nL.map = function (id, options) {\r\n\treturn new L.Map(id, options);\r\n};\r\n\n\n\n\nL.Layer = L.Evented.extend({\n\n\toptions: {\n\t\tpane: 'overlayPane',\n\t\tnonBubblingEvents: []  // Array of events that should not be bubbled to DOM parents (like the map)\n\t},\n\n\taddTo: function (map) {\n\t\tmap.addLayer(this);\n\t\treturn this;\n\t},\n\n\tremove: function () {\n\t\treturn this.removeFrom(this._map || this._mapToAdd);\n\t},\n\n\tremoveFrom: function (obj) {\n\t\tif (obj) {\n\t\t\tobj.removeLayer(this);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetPane: function (name) {\n\t\treturn this._map.getPane(name ? (this.options[name] || name) : this.options.pane);\n\t},\n\n\taddInteractiveTarget: function (targetEl) {\n\t\tthis._map._targets[L.stamp(targetEl)] = this;\n\t\treturn this;\n\t},\n\n\tremoveInteractiveTarget: function (targetEl) {\n\t\tdelete this._map._targets[L.stamp(targetEl)];\n\t\treturn this;\n\t},\n\n\t_layerAdd: function (e) {\n\t\tvar map = e.target;\n\n\t\t// check in case layer gets added and then removed before the map is ready\n\t\tif (!map.hasLayer(this)) { return; }\n\n\t\tthis._map = map;\n\t\tthis._zoomAnimated = map._zoomAnimated;\n\n\t\tif (this.getEvents) {\n\t\t\tmap.on(this.getEvents(), this);\n\t\t}\n\n\t\tthis.onAdd(map);\n\n\t\tif (this.getAttribution && this._map.attributionControl) {\n\t\t\tthis._map.attributionControl.addAttribution(this.getAttribution());\n\t\t}\n\n\t\tthis.fire('add');\n\t\tmap.fire('layeradd', {layer: this});\n\t}\n});\n\n\nL.Map.include({\n\taddLayer: function (layer) {\n\t\tvar id = L.stamp(layer);\n\t\tif (this._layers[id]) { return layer; }\n\t\tthis._layers[id] = layer;\n\n\t\tlayer._mapToAdd = this;\n\n\t\tif (layer.beforeAdd) {\n\t\t\tlayer.beforeAdd(this);\n\t\t}\n\n\t\tthis.whenReady(layer._layerAdd, layer);\n\n\t\treturn this;\n\t},\n\n\tremoveLayer: function (layer) {\n\t\tvar id = L.stamp(layer);\n\n\t\tif (!this._layers[id]) { return this; }\n\n\t\tif (this._loaded) {\n\t\t\tlayer.onRemove(this);\n\t\t}\n\n\t\tif (layer.getAttribution && this.attributionControl) {\n\t\t\tthis.attributionControl.removeAttribution(layer.getAttribution());\n\t\t}\n\n\t\tif (layer.getEvents) {\n\t\t\tthis.off(layer.getEvents(), layer);\n\t\t}\n\n\t\tdelete this._layers[id];\n\n\t\tif (this._loaded) {\n\t\t\tthis.fire('layerremove', {layer: layer});\n\t\t\tlayer.fire('remove');\n\t\t}\n\n\t\tlayer._map = layer._mapToAdd = null;\n\n\t\treturn this;\n\t},\n\n\thasLayer: function (layer) {\n\t\treturn !!layer && (L.stamp(layer) in this._layers);\n\t},\n\n\teachLayer: function (method, context) {\n\t\tfor (var i in this._layers) {\n\t\t\tmethod.call(context, this._layers[i]);\n\t\t}\n\t\treturn this;\n\t},\n\n\t_addLayers: function (layers) {\n\t\tlayers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];\n\n\t\tfor (var i = 0, len = layers.length; i < len; i++) {\n\t\t\tthis.addLayer(layers[i]);\n\t\t}\n\t},\n\n\t_addZoomLimit: function (layer) {\n\t\tif (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n\t\t\tthis._zoomBoundLayers[L.stamp(layer)] = layer;\n\t\t\tthis._updateZoomLevels();\n\t\t}\n\t},\n\n\t_removeZoomLimit: function (layer) {\n\t\tvar id = L.stamp(layer);\n\n\t\tif (this._zoomBoundLayers[id]) {\n\t\t\tdelete this._zoomBoundLayers[id];\n\t\t\tthis._updateZoomLevels();\n\t\t}\n\t},\n\n\t_updateZoomLevels: function () {\n\t\tvar minZoom = Infinity,\n\t\t    maxZoom = -Infinity,\n\t\t    oldZoomSpan = this._getZoomSpan();\n\n\t\tfor (var i in this._zoomBoundLayers) {\n\t\t\tvar options = this._zoomBoundLayers[i].options;\n\n\t\t\tminZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n\t\t\tmaxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n\t\t}\n\n\t\tthis._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n\t\tthis._layersMinZoom = minZoom === Infinity ? undefined : minZoom;\n\n\t\tif (oldZoomSpan !== this._getZoomSpan()) {\n\t\t\tthis.fire('zoomlevelschange');\n\t\t}\n\t}\n});\n\n\n\n/*\r\n * Mercator projection that takes into account that the Earth is not a perfect sphere.\r\n * Less popular than spherical mercator; used by projections like EPSG:3395.\r\n */\r\n\r\nL.Projection.Mercator = {\r\n\tR: 6378137,\r\n\tR_MINOR: 6356752.314245179,\r\n\r\n\tbounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\r\n\r\n\tproject: function (latlng) {\r\n\t\tvar d = Math.PI / 180,\r\n\t\t    r = this.R,\r\n\t\t    y = latlng.lat * d,\r\n\t\t    tmp = this.R_MINOR / r,\r\n\t\t    e = Math.sqrt(1 - tmp * tmp),\r\n\t\t    con = e * Math.sin(y);\r\n\r\n\t\tvar ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\r\n\t\ty = -r * Math.log(Math.max(ts, 1E-10));\r\n\r\n\t\treturn new L.Point(latlng.lng * d * r, y);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\tvar d = 180 / Math.PI,\r\n\t\t    r = this.R,\r\n\t\t    tmp = this.R_MINOR / r,\r\n\t\t    e = Math.sqrt(1 - tmp * tmp),\r\n\t\t    ts = Math.exp(-point.y / r),\r\n\t\t    phi = Math.PI / 2 - 2 * Math.atan(ts);\r\n\r\n\t\tfor (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\r\n\t\t\tcon = e * Math.sin(phi);\r\n\t\t\tcon = Math.pow((1 - con) / (1 + con), e / 2);\r\n\t\t\tdphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\r\n\t\t\tphi += dphi;\r\n\t\t}\r\n\r\n\t\treturn new L.LatLng(phi * d, point.x * d / r);\r\n\t}\r\n};\r\n\n\n\n/*\r\n * L.CRS.EPSG3857 (World Mercator) CRS implementation.\r\n */\r\n\r\nL.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {\r\n\tcode: 'EPSG:3395',\r\n\tprojection: L.Projection.Mercator,\r\n\r\n\ttransformation: (function () {\r\n\t\tvar scale = 0.5 / (Math.PI * L.Projection.Mercator.R);\r\n\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\r\n\t}())\r\n});\r\n\n\n\n/*\n * L.GridLayer is used as base class for grid-like layers like TileLayer.\n */\n\nL.GridLayer = L.Layer.extend({\n\n\toptions: {\n\t\tpane: 'tilePane',\n\n\t\ttileSize: 256,\n\t\topacity: 1,\n\t\tzIndex: 1,\n\n\t\tupdateWhenIdle: L.Browser.mobile,\n\t\tupdateInterval: 200,\n\n\t\tattribution: null,\n\t\tbounds: null,\n\n\t\tminZoom: 0\n\t\t// maxZoom: <Number>\n\t\t// noWrap: false\n\t},\n\n\tinitialize: function (options) {\n\t\toptions = L.setOptions(this, options);\n\t},\n\n\tonAdd: function () {\n\t\tthis._initContainer();\n\n\t\tthis._levels = {};\n\t\tthis._tiles = {};\n\n\t\tthis._resetView();\n\t\tthis._update();\n\t},\n\n\tbeforeAdd: function (map) {\n\t\tmap._addZoomLimit(this);\n\t},\n\n\tonRemove: function (map) {\n\t\tL.DomUtil.remove(this._container);\n\t\tmap._removeZoomLimit(this);\n\t\tthis._container = null;\n\t\tthis._tileZoom = null;\n\t},\n\n\tbringToFront: function () {\n\t\tif (this._map) {\n\t\t\tL.DomUtil.toFront(this._container);\n\t\t\tthis._setAutoZIndex(Math.max);\n\t\t}\n\t\treturn this;\n\t},\n\n\tbringToBack: function () {\n\t\tif (this._map) {\n\t\t\tL.DomUtil.toBack(this._container);\n\t\t\tthis._setAutoZIndex(Math.min);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetAttribution: function () {\n\t\treturn this.options.attribution;\n\t},\n\n\tgetContainer: function () {\n\t\treturn this._container;\n\t},\n\n\tsetOpacity: function (opacity) {\n\t\tthis.options.opacity = opacity;\n\t\tthis._updateOpacity();\n\t\treturn this;\n\t},\n\n\tsetZIndex: function (zIndex) {\n\t\tthis.options.zIndex = zIndex;\n\t\tthis._updateZIndex();\n\n\t\treturn this;\n\t},\n\n\tisLoading: function () {\n\t\treturn this._loading;\n\t},\n\n\tredraw: function () {\n\t\tif (this._map) {\n\t\t\tthis._removeAllTiles();\n\t\t\tthis._update();\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetEvents: function () {\n\t\tvar events = {\n\t\t\tviewreset: this._resetAll,\n\t\t\tzoom: this._resetView,\n\t\t\tmoveend: this._onMoveEnd\n\t\t};\n\n\t\tif (!this.options.updateWhenIdle) {\n\t\t\t// update tiles on move, but not more often than once per given interval\n\t\t\tif (!this._onMove) {\n\t\t\t\tthis._onMove = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);\n\t\t\t}\n\n\t\t\tevents.move = this._onMove;\n\t\t}\n\n\t\tif (this._zoomAnimated) {\n\t\t\tevents.zoomanim = this._animateZoom;\n\t\t}\n\n\t\treturn events;\n\t},\n\n\tcreateTile: function () {\n\t\treturn document.createElement('div');\n\t},\n\n\tgetTileSize: function () {\n\t\tvar s = this.options.tileSize;\n\t\treturn s instanceof L.Point ? s : new L.Point(s, s);\n\t},\n\n\t_updateZIndex: function () {\n\t\tif (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n\t\t\tthis._container.style.zIndex = this.options.zIndex;\n\t\t}\n\t},\n\n\t_setAutoZIndex: function (compare) {\n\t\t// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n\n\t\tvar layers = this.getPane().children,\n\t\t    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n\t\tfor (var i = 0, len = layers.length, zIndex; i < len; i++) {\n\n\t\t\tzIndex = layers[i].style.zIndex;\n\n\t\t\tif (layers[i] !== this._container && zIndex) {\n\t\t\t\tedgeZIndex = compare(edgeZIndex, +zIndex);\n\t\t\t}\n\t\t}\n\n\t\tif (isFinite(edgeZIndex)) {\n\t\t\tthis.options.zIndex = edgeZIndex + compare(-1, 1);\n\t\t\tthis._updateZIndex();\n\t\t}\n\t},\n\n\t_updateOpacity: function () {\n\t\tif (!this._map) { return; }\n\n\t\t// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n\t\tif (L.Browser.ielt9 || !this._map._fadeAnimated) {\n\t\t\treturn;\n\t\t}\n\n\t\tL.DomUtil.setOpacity(this._container, this.options.opacity);\n\n\t\tvar now = +new Date(),\n\t\t    nextFrame = false,\n\t\t    willPrune = false;\n\n\t\tfor (var key in this._tiles) {\n\t\t\tvar tile = this._tiles[key];\n\t\t\tif (!tile.current || !tile.loaded) { continue; }\n\n\t\t\tvar fade = Math.min(1, (now - tile.loaded) / 200);\n\n\t\t\tL.DomUtil.setOpacity(tile.el, fade);\n\t\t\tif (fade < 1) {\n\t\t\t\tnextFrame = true;\n\t\t\t} else {\n\t\t\t\tif (tile.active) { willPrune = true; }\n\t\t\t\ttile.active = true;\n\t\t\t}\n\t\t}\n\n\t\tif (willPrune && !this._noPrune) { this._pruneTiles(); }\n\n\t\tif (nextFrame) {\n\t\t\tL.Util.cancelAnimFrame(this._fadeFrame);\n\t\t\tthis._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);\n\t\t}\n\t},\n\n\t_initContainer: function () {\n\t\tif (this._container) { return; }\n\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-layer');\n\t\tthis._updateZIndex();\n\n\t\tif (this.options.opacity < 1) {\n\t\t\tthis._updateOpacity();\n\t\t}\n\n\t\tthis.getPane().appendChild(this._container);\n\t},\n\n\t_updateLevels: function () {\n\n\t\tvar zoom = this._tileZoom,\n\t\t    maxZoom = this.options.maxZoom;\n\n\t\tfor (var z in this._levels) {\n\t\t\tif (this._levels[z].el.children.length || z === zoom) {\n\t\t\t\tthis._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n\t\t\t} else {\n\t\t\t\tL.DomUtil.remove(this._levels[z].el);\n\t\t\t\tdelete this._levels[z];\n\t\t\t}\n\t\t}\n\n\t\tvar level = this._levels[zoom],\n\t\t    map = this._map;\n\n\t\tif (!level) {\n\t\t\tlevel = this._levels[zoom] = {};\n\n\t\t\tlevel.el = L.DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n\t\t\tlevel.el.style.zIndex = maxZoom;\n\n\t\t\tlevel.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n\t\t\tlevel.zoom = zoom;\n\n\t\t\tthis._setZoomTransform(level, map.getCenter(), map.getZoom());\n\n\t\t\t// force the browser to consider the newly added element for transition\n\t\t\tL.Util.falseFn(level.el.offsetWidth);\n\t\t}\n\n\t\tthis._level = level;\n\n\t\treturn level;\n\t},\n\n\t_pruneTiles: function () {\n\t\tvar key, tile;\n\n\t\tvar zoom = this._map.getZoom();\n\t\tif (zoom > this.options.maxZoom ||\n\t\t\tzoom < this.options.minZoom) { return this._removeAllTiles(); }\n\n\t\tfor (key in this._tiles) {\n\t\t\ttile = this._tiles[key];\n\t\t\ttile.retain = tile.current;\n\t\t}\n\n\t\tfor (key in this._tiles) {\n\t\t\ttile = this._tiles[key];\n\t\t\tif (tile.current && !tile.active) {\n\t\t\t\tvar coords = tile.coords;\n\t\t\t\tif (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n\t\t\t\t\tthis._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (key in this._tiles) {\n\t\t\tif (!this._tiles[key].retain) {\n\t\t\t\tthis._removeTile(key);\n\t\t\t}\n\t\t}\n\t},\n\n\t_removeAllTiles: function () {\n\t\tfor (var key in this._tiles) {\n\t\t\tthis._removeTile(key);\n\t\t}\n\t},\n\n\t_resetAll: function () {\n\t\tfor (var z in this._levels) {\n\t\t\tL.DomUtil.remove(this._levels[z].el);\n\t\t\tdelete this._levels[z];\n\t\t}\n\t\tthis._removeAllTiles();\n\n\t\tthis._tileZoom = null;\n\t\tthis._resetView();\n\t},\n\n\t_retainParent: function (x, y, z, minZoom) {\n\t\tvar x2 = Math.floor(x / 2),\n\t\t    y2 = Math.floor(y / 2),\n\t\t    z2 = z - 1;\n\n\t\tvar key = x2 + ':' + y2 + ':' + z2,\n\t\t    tile = this._tiles[key];\n\n\t\tif (tile && tile.active) {\n\t\t\ttile.retain = true;\n\t\t\treturn true;\n\n\t\t} else if (tile && tile.loaded) {\n\t\t\ttile.retain = true;\n\t\t}\n\n\t\tif (z2 > minZoom) {\n\t\t\treturn this._retainParent(x2, y2, z2, minZoom);\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_retainChildren: function (x, y, z, maxZoom) {\n\n\t\tfor (var i = 2 * x; i < 2 * x + 2; i++) {\n\t\t\tfor (var j = 2 * y; j < 2 * y + 2; j++) {\n\n\t\t\t\tvar key = i + ':' + j + ':' + (z + 1),\n\t\t\t\t    tile = this._tiles[key];\n\n\t\t\t\tif (tile && tile.active) {\n\t\t\t\t\ttile.retain = true;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} else if (tile && tile.loaded) {\n\t\t\t\t\ttile.retain = true;\n\t\t\t\t}\n\n\t\t\t\tif (z + 1 < maxZoom) {\n\t\t\t\t\tthis._retainChildren(i, j, z + 1, maxZoom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_resetView: function (e) {\n\t\tvar animating = e && (e.pinch || e.flyTo);\n\t\tthis._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n\t},\n\n\t_animateZoom: function (e) {\n\t\tthis._setView(e.center, e.zoom, true, e.noUpdate);\n\t},\n\n\t_setView: function (center, zoom, noPrune, noUpdate) {\n\t\tvar tileZoom = Math.round(zoom);\n\t\tif ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||\n\t\t    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {\n\t\t\ttileZoom = undefined;\n\t\t}\n\n\t\tvar tileZoomChanged = (tileZoom !== this._tileZoom);\n\n\t\tif (!noUpdate || tileZoomChanged) {\n\n\t\t\tthis._tileZoom = tileZoom;\n\n\t\t\tif (this._abortLoading) {\n\t\t\t\tthis._abortLoading();\n\t\t\t}\n\n\t\t\tthis._updateLevels();\n\t\t\tthis._resetGrid();\n\n\t\t\tif (tileZoom !== undefined) {\n\t\t\t\tthis._update(center);\n\t\t\t}\n\n\t\t\tif (!noPrune) {\n\t\t\t\tthis._pruneTiles();\n\t\t\t}\n\n\t\t\t// Flag to prevent _updateOpacity from pruning tiles during\n\t\t\t// a zoom anim or a pinch gesture\n\t\t\tthis._noPrune = !!noPrune;\n\t\t}\n\n\t\tthis._setZoomTransforms(center, zoom);\n\t},\n\n\t_setZoomTransforms: function (center, zoom) {\n\t\tfor (var i in this._levels) {\n\t\t\tthis._setZoomTransform(this._levels[i], center, zoom);\n\t\t}\n\t},\n\n\t_setZoomTransform: function (level, center, zoom) {\n\t\tvar scale = this._map.getZoomScale(zoom, level.zoom),\n\t\t    translate = level.origin.multiplyBy(scale)\n\t\t        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n\n\t\tif (L.Browser.any3d) {\n\t\t\tL.DomUtil.setTransform(level.el, translate, scale);\n\t\t} else {\n\t\t\tL.DomUtil.setPosition(level.el, translate);\n\t\t}\n\t},\n\n\t_resetGrid: function () {\n\t\tvar map = this._map,\n\t\t    crs = map.options.crs,\n\t\t    tileSize = this._tileSize = this.getTileSize(),\n\t\t    tileZoom = this._tileZoom;\n\n\t\tvar bounds = this._map.getPixelWorldBounds(this._tileZoom);\n\t\tif (bounds) {\n\t\t\tthis._globalTileRange = this._pxBoundsToTileRange(bounds);\n\t\t}\n\n\t\tthis._wrapX = crs.wrapLng && !this.options.noWrap && [\n\t\t\tMath.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),\n\t\t\tMath.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)\n\t\t];\n\t\tthis._wrapY = crs.wrapLat && !this.options.noWrap && [\n\t\t\tMath.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),\n\t\t\tMath.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)\n\t\t];\n\t},\n\n\t_onMoveEnd: function () {\n\t\tif (!this._map || this._map._animatingZoom) { return; }\n\n\t\tthis._resetView();\n\t},\n\n\t_getTiledPixelBounds: function (center, zoom, tileZoom) {\n\t\tvar map = this._map,\n\t\t    scale = map.getZoomScale(zoom, tileZoom),\n\t\t    pixelCenter = map.project(center, tileZoom).floor(),\n\t\t    halfSize = map.getSize().divideBy(scale * 2);\n\n\t\treturn new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n\t},\n\n\t// Private method to load tiles in the grid's active zoom level according to map bounds\n\t_update: function (center) {\n\t\tvar map = this._map;\n\t\tif (!map) { return; }\n\t\tvar zoom = map.getZoom();\n\n\t\tif (center === undefined) { center = map.getCenter(); }\n\t\tif (this._tileZoom === undefined) { return; }\t// if out of minzoom/maxzoom\n\n\t\tvar pixelBounds = this._getTiledPixelBounds(center, zoom, this._tileZoom),\n\t\t    tileRange = this._pxBoundsToTileRange(pixelBounds),\n\t\t    tileCenter = tileRange.getCenter(),\n\t\t    queue = [];\n\n\t\tfor (var key in this._tiles) {\n\t\t\tthis._tiles[key].current = false;\n\t\t}\n\n\t\t// _update just loads more tiles. If the tile zoom level differs too much\n\t\t// from the map's, let _setView reset levels and prune old tiles.\n\t\tif (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }\n\n\t\t// create a queue of coordinates to load tiles from\n\t\tfor (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n\t\t\tfor (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n\t\t\t\tvar coords = new L.Point(i, j);\n\t\t\t\tcoords.z = this._tileZoom;\n\n\t\t\t\tif (!this._isValidTile(coords)) { continue; }\n\n\t\t\t\tvar tile = this._tiles[this._tileCoordsToKey(coords)];\n\t\t\t\tif (tile) {\n\t\t\t\t\ttile.current = true;\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push(coords);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// sort tile queue to load tiles in order of their distance to center\n\t\tqueue.sort(function (a, b) {\n\t\t\treturn a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n\t\t});\n\n\t\tif (queue.length !== 0) {\n\t\t\t// if its the first batch of tiles to load\n\t\t\tif (!this._loading) {\n\t\t\t\tthis._loading = true;\n\t\t\t\tthis.fire('loading');\n\t\t\t}\n\n\t\t\t// create DOM fragment to append tiles in one batch\n\t\t\tvar fragment = document.createDocumentFragment();\n\n\t\t\tfor (i = 0; i < queue.length; i++) {\n\t\t\t\tthis._addTile(queue[i], fragment);\n\t\t\t}\n\n\t\t\tthis._level.el.appendChild(fragment);\n\t\t}\n\t},\n\n\t_isValidTile: function (coords) {\n\t\tvar crs = this._map.options.crs;\n\n\t\tif (!crs.infinite) {\n\t\t\t// don't load tile if it's out of bounds and not wrapped\n\t\t\tvar bounds = this._globalTileRange;\n\t\t\tif ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||\n\t\t\t    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }\n\t\t}\n\n\t\tif (!this.options.bounds) { return true; }\n\n\t\t// don't load tile if it doesn't intersect the bounds in options\n\t\tvar tileBounds = this._tileCoordsToBounds(coords);\n\t\treturn L.latLngBounds(this.options.bounds).overlaps(tileBounds);\n\t},\n\n\t_keyToBounds: function (key) {\n\t\treturn this._tileCoordsToBounds(this._keyToTileCoords(key));\n\t},\n\n\t// converts tile coordinates to its geographical bounds\n\t_tileCoordsToBounds: function (coords) {\n\n\t\tvar map = this._map,\n\t\t    tileSize = this.getTileSize(),\n\n\t\t    nwPoint = coords.scaleBy(tileSize),\n\t\t    sePoint = nwPoint.add(tileSize),\n\n\t\t    nw = map.wrapLatLng(map.unproject(nwPoint, coords.z)),\n\t\t    se = map.wrapLatLng(map.unproject(sePoint, coords.z));\n\n\t\treturn new L.LatLngBounds(nw, se);\n\t},\n\n\t// converts tile coordinates to key for the tile cache\n\t_tileCoordsToKey: function (coords) {\n\t\treturn coords.x + ':' + coords.y + ':' + coords.z;\n\t},\n\n\t// converts tile cache key to coordinates\n\t_keyToTileCoords: function (key) {\n\t\tvar k = key.split(':'),\n\t\t    coords = new L.Point(+k[0], +k[1]);\n\t\tcoords.z = +k[2];\n\t\treturn coords;\n\t},\n\n\t_removeTile: function (key) {\n\t\tvar tile = this._tiles[key];\n\t\tif (!tile) { return; }\n\n\t\tL.DomUtil.remove(tile.el);\n\n\t\tdelete this._tiles[key];\n\n\t\tthis.fire('tileunload', {\n\t\t\ttile: tile.el,\n\t\t\tcoords: this._keyToTileCoords(key)\n\t\t});\n\t},\n\n\t_initTile: function (tile) {\n\t\tL.DomUtil.addClass(tile, 'leaflet-tile');\n\n\t\tvar tileSize = this.getTileSize();\n\t\ttile.style.width = tileSize.x + 'px';\n\t\ttile.style.height = tileSize.y + 'px';\n\n\t\ttile.onselectstart = L.Util.falseFn;\n\t\ttile.onmousemove = L.Util.falseFn;\n\n\t\t// update opacity on tiles in IE7-8 because of filter inheritance problems\n\t\tif (L.Browser.ielt9 && this.options.opacity < 1) {\n\t\t\tL.DomUtil.setOpacity(tile, this.options.opacity);\n\t\t}\n\n\t\t// without this hack, tiles disappear after zoom on Chrome for Android\n\t\t// https://github.com/Leaflet/Leaflet/issues/2078\n\t\tif (L.Browser.android && !L.Browser.android23) {\n\t\t\ttile.style.WebkitBackfaceVisibility = 'hidden';\n\t\t}\n\t},\n\n\t_addTile: function (coords, container) {\n\t\tvar tilePos = this._getTilePos(coords),\n\t\t    key = this._tileCoordsToKey(coords);\n\n\t\tvar tile = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords));\n\n\t\tthis._initTile(tile);\n\n\t\t// if createTile is defined with a second argument (\"done\" callback),\n\t\t// we know that tile is async and will be ready later; otherwise\n\t\tif (this.createTile.length < 2) {\n\t\t\t// mark tile as ready, but delay one frame for opacity animation to happen\n\t\t\tL.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));\n\t\t}\n\n\t\tL.DomUtil.setPosition(tile, tilePos);\n\n\t\t// save tile in cache\n\t\tthis._tiles[key] = {\n\t\t\tel: tile,\n\t\t\tcoords: coords,\n\t\t\tcurrent: true\n\t\t};\n\n\t\tcontainer.appendChild(tile);\n\t\tthis.fire('tileloadstart', {\n\t\t\ttile: tile,\n\t\t\tcoords: coords\n\t\t});\n\t},\n\n\t_tileReady: function (coords, err, tile) {\n\t\tif (!this._map) { return; }\n\n\t\tif (err) {\n\t\t\tthis.fire('tileerror', {\n\t\t\t\terror: err,\n\t\t\t\ttile: tile,\n\t\t\t\tcoords: coords\n\t\t\t});\n\t\t}\n\n\t\tvar key = this._tileCoordsToKey(coords);\n\n\t\ttile = this._tiles[key];\n\t\tif (!tile) { return; }\n\n\t\ttile.loaded = +new Date();\n\t\tif (this._map._fadeAnimated) {\n\t\t\tL.DomUtil.setOpacity(tile.el, 0);\n\t\t\tL.Util.cancelAnimFrame(this._fadeFrame);\n\t\t\tthis._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);\n\t\t} else {\n\t\t\ttile.active = true;\n\t\t\tthis._pruneTiles();\n\t\t}\n\n\t\tL.DomUtil.addClass(tile.el, 'leaflet-tile-loaded');\n\n\t\tthis.fire('tileload', {\n\t\t\ttile: tile.el,\n\t\t\tcoords: coords\n\t\t});\n\n\t\tif (this._noTilesToLoad()) {\n\t\t\tthis._loading = false;\n\t\t\tthis.fire('load');\n\t\t}\n\t},\n\n\t_getTilePos: function (coords) {\n\t\treturn coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n\t},\n\n\t_wrapCoords: function (coords) {\n\t\tvar newCoords = new L.Point(\n\t\t\tthis._wrapX ? L.Util.wrapNum(coords.x, this._wrapX) : coords.x,\n\t\t\tthis._wrapY ? L.Util.wrapNum(coords.y, this._wrapY) : coords.y);\n\t\tnewCoords.z = coords.z;\n\t\treturn newCoords;\n\t},\n\n\t_pxBoundsToTileRange: function (bounds) {\n\t\tvar tileSize = this.getTileSize();\n\t\treturn new L.Bounds(\n\t\t\tbounds.min.unscaleBy(tileSize).floor(),\n\t\t\tbounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n\t},\n\n\t_noTilesToLoad: function () {\n\t\tfor (var key in this._tiles) {\n\t\t\tif (!this._tiles[key].loaded) { return false; }\n\t\t}\n\t\treturn true;\n\t}\n});\n\nL.gridLayer = function (options) {\n\treturn new L.GridLayer(options);\n};\n\n\n\n/*\r\n * L.TileLayer is used for standard xyz-numbered tile layers.\r\n */\r\n\r\nL.TileLayer = L.GridLayer.extend({\r\n\r\n\toptions: {\r\n\t\tmaxZoom: 18,\r\n\r\n\t\tsubdomains: 'abc',\r\n\t\terrorTileUrl: '',\r\n\t\tzoomOffset: 0,\r\n\r\n\t\tmaxNativeZoom: null, // Number\r\n\t\ttms: false,\r\n\t\tzoomReverse: false,\r\n\t\tdetectRetina: false,\r\n\t\tcrossOrigin: false\r\n\t},\r\n\r\n\tinitialize: function (url, options) {\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n\t\tif (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\r\n\r\n\t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\t\t\toptions.zoomOffset++;\r\n\r\n\t\t\toptions.minZoom = Math.max(0, options.minZoom);\r\n\t\t\toptions.maxZoom--;\r\n\t\t}\r\n\r\n\t\tif (typeof options.subdomains === 'string') {\r\n\t\t\toptions.subdomains = options.subdomains.split('');\r\n\t\t}\r\n\r\n\t\t// for https://github.com/Leaflet/Leaflet/issues/137\r\n\t\tif (!L.Browser.android) {\r\n\t\t\tthis.on('tileunload', this._onTileRemove);\r\n\t\t}\r\n\t},\r\n\r\n\tsetUrl: function (url, noRedraw) {\r\n\t\tthis._url = url;\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tcreateTile: function (coords, done) {\r\n\t\tvar tile = document.createElement('img');\r\n\r\n\t\tL.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile));\r\n\t\tL.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile));\r\n\r\n\t\tif (this.options.crossOrigin) {\r\n\t\t\ttile.crossOrigin = '';\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\r\n\t\t http://www.w3.org/TR/WCAG20-TECHS/H67\r\n\t\t*/\r\n\t\ttile.alt = '';\r\n\r\n\t\ttile.src = this.getTileUrl(coords);\r\n\r\n\t\treturn tile;\r\n\t},\r\n\r\n\tgetTileUrl: function (coords) {\r\n\t\treturn L.Util.template(this._url, L.extend({\r\n\t\t\tr: this.options.detectRetina && L.Browser.retina && this.options.maxZoom > 0 ? '@2x' : '',\r\n\t\t\ts: this._getSubdomain(coords),\r\n\t\t\tx: coords.x,\r\n\t\t\ty: this.options.tms ? this._globalTileRange.max.y - coords.y : coords.y,\r\n\t\t\tz: this._getZoomForUrl()\r\n\t\t}, this.options));\r\n\t},\r\n\r\n\t_tileOnLoad: function (done, tile) {\r\n\t\t// For https://github.com/Leaflet/Leaflet/issues/3332\r\n\t\tif (L.Browser.ielt9) {\r\n\t\t\tsetTimeout(L.bind(done, this, null, tile), 0);\r\n\t\t} else {\r\n\t\t\tdone(null, tile);\r\n\t\t}\r\n\t},\r\n\r\n\t_tileOnError: function (done, tile, e) {\r\n\t\tvar errorUrl = this.options.errorTileUrl;\r\n\t\tif (errorUrl) {\r\n\t\t\ttile.src = errorUrl;\r\n\t\t}\r\n\t\tdone(e, tile);\r\n\t},\r\n\r\n\tgetTileSize: function () {\r\n\t\tvar map = this._map,\r\n\t\t    tileSize = L.GridLayer.prototype.getTileSize.call(this),\r\n\t\t    zoom = this._tileZoom + this.options.zoomOffset,\r\n\t\t    zoomN = this.options.maxNativeZoom;\r\n\r\n\t\t// increase tile size when overscaling\r\n\t\treturn zoomN !== null && zoom > zoomN ?\r\n\t\t\t\ttileSize.divideBy(map.getZoomScale(zoomN, zoom)).round() :\r\n\t\t\t\ttileSize;\r\n\t},\r\n\r\n\t_onTileRemove: function (e) {\r\n\t\te.tile.onload = null;\r\n\t},\r\n\r\n\t_getZoomForUrl: function () {\r\n\r\n\t\tvar options = this.options,\r\n\t\t    zoom = this._tileZoom;\r\n\r\n\t\tif (options.zoomReverse) {\r\n\t\t\tzoom = options.maxZoom - zoom;\r\n\t\t}\r\n\r\n\t\tzoom += options.zoomOffset;\r\n\r\n\t\treturn options.maxNativeZoom !== null ? Math.min(zoom, options.maxNativeZoom) : zoom;\r\n\t},\r\n\r\n\t_getSubdomain: function (tilePoint) {\r\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n\t\treturn this.options.subdomains[index];\r\n\t},\r\n\r\n\t// stops loading all tiles in the background layer\r\n\t_abortLoading: function () {\r\n\t\tvar i, tile;\r\n\t\tfor (i in this._tiles) {\r\n\t\t\tif (this._tiles[i].coords.z !== this._tileZoom) {\r\n\t\t\t\ttile = this._tiles[i].el;\r\n\r\n\t\t\t\ttile.onload = L.Util.falseFn;\r\n\t\t\t\ttile.onerror = L.Util.falseFn;\r\n\r\n\t\t\t\tif (!tile.complete) {\r\n\t\t\t\t\ttile.src = L.Util.emptyImageUrl;\r\n\t\t\t\t\tL.DomUtil.remove(tile);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.tileLayer = function (url, options) {\r\n\treturn new L.TileLayer(url, options);\r\n};\r\n\n\n\n/*\r\n * L.TileLayer.WMS is used for WMS tile layers.\r\n */\r\n\r\nL.TileLayer.WMS = L.TileLayer.extend({\r\n\r\n\tdefaultWmsParams: {\r\n\t\tservice: 'WMS',\r\n\t\trequest: 'GetMap',\r\n\t\tversion: '1.1.1',\r\n\t\tlayers: '',\r\n\t\tstyles: '',\r\n\t\tformat: 'image/jpeg',\r\n\t\ttransparent: false\r\n\t},\r\n\r\n\toptions: {\r\n\t\tcrs: null,\r\n\t\tuppercase: false\r\n\t},\r\n\r\n\tinitialize: function (url, options) {\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar wmsParams = L.extend({}, this.defaultWmsParams);\r\n\r\n\t\t// all keys that are not TileLayer options go to WMS params\r\n\t\tfor (var i in options) {\r\n\t\t\tif (!(i in this.options)) {\r\n\t\t\t\twmsParams[i] = options[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\twmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);\r\n\r\n\t\tthis.wmsParams = wmsParams;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\r\n\t\tthis._crs = this.options.crs || map.options.crs;\r\n\t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n\t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n\t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\r\n\t\tL.TileLayer.prototype.onAdd.call(this, map);\r\n\t},\r\n\r\n\tgetTileUrl: function (coords) {\r\n\r\n\t\tvar tileBounds = this._tileCoordsToBounds(coords),\r\n\t\t    nw = this._crs.project(tileBounds.getNorthWest()),\r\n\t\t    se = this._crs.project(tileBounds.getSouthEast()),\r\n\r\n\t\t    bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?\r\n\t\t\t    [se.y, nw.x, nw.y, se.x] :\r\n\t\t\t    [nw.x, se.y, se.x, nw.y]).join(','),\r\n\r\n\t\t    url = L.TileLayer.prototype.getTileUrl.call(this, coords);\r\n\r\n\t\treturn url +\r\n\t\t\tL.Util.getParamString(this.wmsParams, url, this.options.uppercase) +\r\n\t\t\t(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\r\n\t},\r\n\r\n\tsetParams: function (params, noRedraw) {\r\n\r\n\t\tL.extend(this.wmsParams, params);\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.tileLayer.wms = function (url, options) {\r\n\treturn new L.TileLayer.WMS(url, options);\r\n};\r\n\n\n\n/*\r\n * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\r\n */\r\n\r\nL.ImageOverlay = L.Layer.extend({\r\n\r\n\toptions: {\r\n\t\topacity: 1,\r\n\t\talt: '',\r\n\t\tinteractive: false\r\n\r\n\t\t/*\r\n\t\tcrossOrigin: <Boolean>,\r\n\t\t*/\r\n\t},\r\n\r\n\tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n\t\tthis._url = url;\r\n\t\tthis._bounds = L.latLngBounds(bounds);\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function () {\r\n\t\tif (!this._image) {\r\n\t\t\tthis._initImage();\r\n\r\n\t\t\tif (this.options.opacity < 1) {\r\n\t\t\t\tthis._updateOpacity();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.options.interactive) {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-interactive');\r\n\t\t\tthis.addInteractiveTarget(this._image);\r\n\t\t}\r\n\r\n\t\tthis.getPane().appendChild(this._image);\r\n\t\tthis._reset();\r\n\t},\r\n\r\n\tonRemove: function () {\r\n\t\tL.DomUtil.remove(this._image);\r\n\t\tif (this.options.interactive) {\r\n\t\t\tthis.removeInteractiveTarget(this._image);\r\n\t\t}\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\r\n\t\tif (this._image) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (styleOpts) {\r\n\t\tif (styleOpts.opacity) {\r\n\t\t\tthis.setOpacity(styleOpts.opacity);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tif (this._map) {\r\n\t\t\tL.DomUtil.toFront(this._image);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tif (this._map) {\r\n\t\t\tL.DomUtil.toBack(this._image);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url) {\r\n\t\tthis._url = url;\r\n\r\n\t\tif (this._image) {\r\n\t\t\tthis._image.src = url;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetBounds: function (bounds) {\r\n\t\tthis._bounds = bounds;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\tgetEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tzoom: this._reset,\r\n\t\t\tviewreset: this._reset\r\n\t\t};\r\n\r\n\t\tif (this._zoomAnimated) {\r\n\t\t\tevents.zoomanim = this._animateZoom;\r\n\t\t}\r\n\r\n\t\treturn events;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\treturn this._bounds;\r\n\t},\r\n\r\n\tgetElement: function () {\r\n\t\treturn this._image;\r\n\t},\r\n\r\n\t_initImage: function () {\r\n\t\tvar img = this._image = L.DomUtil.create('img',\r\n\t\t\t\t'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));\r\n\r\n\t\timg.onselectstart = L.Util.falseFn;\r\n\t\timg.onmousemove = L.Util.falseFn;\r\n\r\n\t\timg.onload = L.bind(this.fire, this, 'load');\r\n\r\n\t\tif (this.options.crossOrigin) {\r\n\t\t\timg.crossOrigin = '';\r\n\t\t}\r\n\r\n\t\timg.src = this._url;\r\n\t\timg.alt = this.options.alt;\r\n\t},\r\n\r\n\t_animateZoom: function (e) {\r\n\t\tvar scale = this._map.getZoomScale(e.zoom),\r\n\t\t    offset = this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), e.zoom, e.center);\r\n\r\n\t\tL.DomUtil.setTransform(this._image, offset, scale);\r\n\t},\r\n\r\n\t_reset: function () {\r\n\t\tvar image = this._image,\r\n\t\t    bounds = new L.Bounds(\r\n\t\t        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n\t\t        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\r\n\t\t    size = bounds.getSize();\r\n\r\n\t\tL.DomUtil.setPosition(image, bounds.min);\r\n\r\n\t\timage.style.width  = size.x + 'px';\r\n\t\timage.style.height = size.y + 'px';\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._image, this.options.opacity);\r\n\t}\r\n});\r\n\r\nL.imageOverlay = function (url, bounds, options) {\r\n\treturn new L.ImageOverlay(url, bounds, options);\r\n};\r\n\n\n\n/*\r\n * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\r\n */\r\n\r\nL.Icon = L.Class.extend({\r\n\t/*\r\n\toptions: {\r\n\t\ticonUrl: (String) (required)\r\n\t\ticonRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\ticonSize: (Point) (can be set through CSS)\r\n\t\ticonAnchor: (Point) (centered by default, can be set in CSS with negative margins)\r\n\t\tpopupAnchor: (Point) (if not specified, popup opens in the anchor point)\r\n\t\tshadowUrl: (String) (no shadow by default)\r\n\t\tshadowRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\tshadowSize: (Point)\r\n\t\tshadowAnchor: (Point)\r\n\t\tclassName: (String)\r\n\t},\r\n\t*/\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tcreateIcon: function (oldIcon) {\r\n\t\treturn this._createIcon('icon', oldIcon);\r\n\t},\r\n\r\n\tcreateShadow: function (oldIcon) {\r\n\t\treturn this._createIcon('shadow', oldIcon);\r\n\t},\r\n\r\n\t_createIcon: function (name, oldIcon) {\r\n\t\tvar src = this._getIconUrl(name);\r\n\r\n\t\tif (!src) {\r\n\t\t\tif (name === 'icon') {\r\n\t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\r\n\t\tthis._setIconStyles(img, name);\r\n\r\n\t\treturn img;\r\n\t},\r\n\r\n\t_setIconStyles: function (img, name) {\r\n\t\tvar options = this.options,\r\n\t\t    size = L.point(options[name + 'Size']),\r\n\t\t    anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||\r\n\t\t            size && size.divideBy(2, true));\r\n\r\n\t\timg.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\r\n\r\n\t\tif (anchor) {\r\n\t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n\t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n\t\t}\r\n\r\n\t\tif (size) {\r\n\t\t\timg.style.width  = size.x + 'px';\r\n\t\t\timg.style.height = size.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\t_createImg: function (src, el) {\r\n\t\tel = el || document.createElement('img');\r\n\t\tel.src = src;\r\n\t\treturn el;\r\n\t},\r\n\r\n\t_getIconUrl: function (name) {\r\n\t\treturn L.Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\r\n\t}\r\n});\r\n\r\nL.icon = function (options) {\r\n\treturn new L.Icon(options);\r\n};\r\n\n\n\n/*\n * L.Icon.Default is the blue marker icon used by default in Leaflet.\n */\n\nL.Icon.Default = L.Icon.extend({\n\n\toptions: {\n\t\ticonSize:    [25, 41],\n\t\ticonAnchor:  [12, 41],\n\t\tpopupAnchor: [1, -34],\n\t\tshadowSize:  [41, 41]\n\t},\n\n\t_getIconUrl: function (name) {\n\t\tvar key = name + 'Url';\n\n\t\tif (this.options[key]) {\n\t\t\treturn this.options[key];\n\t\t}\n\n\t\tvar path = L.Icon.Default.imagePath;\n\n\t\tif (!path) {\n\t\t\tthrow new Error('Couldn\\'t autodetect L.Icon.Default.imagePath, set it manually.');\n\t\t}\n\n\t\treturn path + '/marker-' + name + (L.Browser.retina && name === 'icon' ? '-2x' : '') + '.png';\n\t}\n});\n\nL.Icon.Default.imagePath = (function () {\n\tvar scripts = document.getElementsByTagName('script'),\n\t    leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n\tvar i, len, src, path;\n\n\tfor (i = 0, len = scripts.length; i < len; i++) {\n\t\tsrc = scripts[i].src || '';\n\n\t\tif (src.match(leafletRe)) {\n\t\t\tpath = src.split(leafletRe)[0];\n\t\t\treturn (path ? path + '/' : '') + 'images';\n\t\t}\n\t}\n}());\n\n\n\n/*\r\n * L.Marker is used to display clickable/draggable icons on the map.\r\n */\r\n\r\nL.Marker = L.Layer.extend({\r\n\r\n\toptions: {\r\n\t\tpane: 'markerPane',\r\n\t\tnonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\r\n\r\n\t\ticon: new L.Icon.Default(),\r\n\t\t// title: '',\r\n\t\t// alt: '',\r\n\t\tinteractive: true,\r\n\t\t// draggable: false,\r\n\t\tkeyboard: true,\r\n\t\tzIndexOffset: 0,\r\n\t\topacity: 1,\r\n\t\t// riseOnHover: false,\r\n\t\triseOffset: 250\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.setOptions(this, options);\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\r\n\r\n\t\tthis._initIcon();\r\n\t\tthis.update();\r\n\t},\r\n\r\n\tonRemove: function () {\r\n\t\tif (this.dragging && this.dragging.enabled()) {\r\n\t\t\tthis.options.draggable = true;\r\n\t\t\tthis.dragging.removeHooks();\r\n\t\t}\r\n\r\n\t\tthis._removeIcon();\r\n\t\tthis._removeShadow();\r\n\t},\r\n\r\n\tgetEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tzoom: this.update,\r\n\t\t\tviewreset: this.update\r\n\t\t};\r\n\r\n\t\tif (this._zoomAnimated) {\r\n\t\t\tevents.zoomanim = this._animateZoom;\r\n\t\t}\r\n\r\n\t\treturn events;\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tvar oldLatLng = this._latlng;\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tthis.update();\r\n\t\treturn this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});\r\n\t},\r\n\r\n\tsetZIndexOffset: function (offset) {\r\n\t\tthis.options.zIndexOffset = offset;\r\n\t\treturn this.update();\r\n\t},\r\n\r\n\tsetIcon: function (icon) {\r\n\r\n\t\tthis.options.icon = icon;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._initIcon();\r\n\t\t\tthis.update();\r\n\t\t}\r\n\r\n\t\tif (this._popup) {\r\n\t\t\tthis.bindPopup(this._popup, this._popup.options);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetElement: function () {\r\n\t\treturn this._icon;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\r\n\t\tif (this._icon) {\r\n\t\t\tvar pos = this._map.latLngToLayerPoint(this._latlng).round();\r\n\t\t\tthis._setPos(pos);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initIcon: function () {\r\n\t\tvar options = this.options,\r\n\t\t    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\r\n\r\n\t\tvar icon = options.icon.createIcon(this._icon),\r\n\t\t    addIcon = false;\r\n\r\n\t\t// if we're not reusing the icon, remove the old one and init new one\r\n\t\tif (icon !== this._icon) {\r\n\t\t\tif (this._icon) {\r\n\t\t\t\tthis._removeIcon();\r\n\t\t\t}\r\n\t\t\taddIcon = true;\r\n\r\n\t\t\tif (options.title) {\r\n\t\t\t\ticon.title = options.title;\r\n\t\t\t}\r\n\t\t\tif (options.alt) {\r\n\t\t\t\ticon.alt = options.alt;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tL.DomUtil.addClass(icon, classToAdd);\r\n\r\n\t\tif (options.keyboard) {\r\n\t\t\ticon.tabIndex = '0';\r\n\t\t}\r\n\r\n\t\tthis._icon = icon;\r\n\r\n\t\tif (options.riseOnHover) {\r\n\t\t\tthis.on({\r\n\t\t\t\tmouseover: this._bringToFront,\r\n\t\t\t\tmouseout: this._resetZIndex\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n\t\t    addShadow = false;\r\n\r\n\t\tif (newShadow !== this._shadow) {\r\n\t\t\tthis._removeShadow();\r\n\t\t\taddShadow = true;\r\n\t\t}\r\n\r\n\t\tif (newShadow) {\r\n\t\t\tL.DomUtil.addClass(newShadow, classToAdd);\r\n\t\t}\r\n\t\tthis._shadow = newShadow;\r\n\r\n\r\n\t\tif (options.opacity < 1) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\r\n\t\tif (addIcon) {\r\n\t\t\tthis.getPane().appendChild(this._icon);\r\n\t\t\tthis._initInteraction();\r\n\t\t}\r\n\t\tif (newShadow && addShadow) {\r\n\t\t\tthis.getPane('shadowPane').appendChild(this._shadow);\r\n\t\t}\r\n\t},\r\n\r\n\t_removeIcon: function () {\r\n\t\tif (this.options.riseOnHover) {\r\n\t\t\tthis.off({\r\n\t\t\t\tmouseover: this._bringToFront,\r\n\t\t\t\tmouseout: this._resetZIndex\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tL.DomUtil.remove(this._icon);\r\n\t\tthis.removeInteractiveTarget(this._icon);\r\n\r\n\t\tthis._icon = null;\r\n\t},\r\n\r\n\t_removeShadow: function () {\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.remove(this._shadow);\r\n\t\t}\r\n\t\tthis._shadow = null;\r\n\t},\r\n\r\n\t_setPos: function (pos) {\r\n\t\tL.DomUtil.setPosition(this._icon, pos);\r\n\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setPosition(this._shadow, pos);\r\n\t\t}\r\n\r\n\t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n\t\tthis._resetZIndex();\r\n\t},\r\n\r\n\t_updateZIndex: function (offset) {\r\n\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n\t},\r\n\r\n\t_animateZoom: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n\t\tthis._setPos(pos);\r\n\t},\r\n\r\n\t_initInteraction: function () {\r\n\r\n\t\tif (!this.options.interactive) { return; }\r\n\r\n\t\tL.DomUtil.addClass(this._icon, 'leaflet-interactive');\r\n\r\n\t\tthis.addInteractiveTarget(this._icon);\r\n\r\n\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\tvar draggable = this.options.draggable;\r\n\t\t\tif (this.dragging) {\r\n\t\t\t\tdraggable = this.dragging.enabled();\r\n\t\t\t\tthis.dragging.disable();\r\n\t\t\t}\r\n\r\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n\t\t\tif (draggable) {\r\n\t\t\t\tthis.dragging.enable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tvar opacity = this.options.opacity;\r\n\r\n\t\tL.DomUtil.setOpacity(this._icon, opacity);\r\n\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setOpacity(this._shadow, opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_bringToFront: function () {\r\n\t\tthis._updateZIndex(this.options.riseOffset);\r\n\t},\r\n\r\n\t_resetZIndex: function () {\r\n\t\tthis._updateZIndex(0);\r\n\t}\r\n});\r\n\r\nL.marker = function (latlng, options) {\r\n\treturn new L.Marker(latlng, options);\r\n};\r\n\n\n\n/*\n * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n * to use with L.Marker.\n */\n\nL.DivIcon = L.Icon.extend({\n\toptions: {\n\t\ticonSize: [12, 12], // also can be set through CSS\n\t\t/*\n\t\ticonAnchor: (Point)\n\t\tpopupAnchor: (Point)\n\t\thtml: (String)\n\t\tbgPos: (Point)\n\t\t*/\n\t\tclassName: 'leaflet-div-icon',\n\t\thtml: false\n\t},\n\n\tcreateIcon: function (oldIcon) {\n\t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n\t\t    options = this.options;\n\n\t\tdiv.innerHTML = options.html !== false ? options.html : '';\n\n\t\tif (options.bgPos) {\n\t\t\tdiv.style.backgroundPosition = (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n\t\t}\n\t\tthis._setIconStyles(div, 'icon');\n\n\t\treturn div;\n\t},\n\n\tcreateShadow: function () {\n\t\treturn null;\n\t}\n});\n\nL.divIcon = function (options) {\n\treturn new L.DivIcon(options);\n};\n\n\n\n/*\r\n * L.Popup is used for displaying popups on the map.\r\n */\r\n\r\nL.Map.mergeOptions({\r\n\tclosePopupOnClick: true\r\n});\r\n\r\nL.Popup = L.Layer.extend({\r\n\r\n\toptions: {\r\n\t\tpane: 'popupPane',\r\n\r\n\t\tminWidth: 50,\r\n\t\tmaxWidth: 300,\r\n\t\t// maxHeight: <Number>,\r\n\t\toffset: [0, 7],\r\n\r\n\t\tautoPan: true,\r\n\t\tautoPanPadding: [5, 5],\r\n\t\t// autoPanPaddingTopLeft: <Point>,\r\n\t\t// autoPanPaddingBottomRight: <Point>,\r\n\r\n\t\tcloseButton: true,\r\n\t\tautoClose: true,\r\n\t\t// keepInView: false,\r\n\t\t// className: '',\r\n\t\tzoomAnimation: true\r\n\t},\r\n\r\n\tinitialize: function (options, source) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._source = source;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._zoomAnimated = this._zoomAnimated && this.options.zoomAnimation;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initLayout();\r\n\t\t}\r\n\r\n\t\tif (map._fadeAnimated) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\r\n\t\tclearTimeout(this._removeTimeout);\r\n\t\tthis.getPane().appendChild(this._container);\r\n\t\tthis.update();\r\n\r\n\t\tif (map._fadeAnimated) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 1);\r\n\t\t}\r\n\r\n\t\tmap.fire('popupopen', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupopen', {popup: this}, true);\r\n\t\t}\r\n\t},\r\n\r\n\topenOn: function (map) {\r\n\t\tmap.openPopup(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tif (map._fadeAnimated) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t\tthis._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.remove(this._container);\r\n\t\t}\r\n\r\n\t\tmap.fire('popupclose', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupclose', {popup: this}, true);\r\n\t\t}\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tif (this._map) {\r\n\t\t\tthis._updatePosition();\r\n\t\t\tthis._adjustPan();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContent: function () {\r\n\t\treturn this._content;\r\n\t},\r\n\r\n\tsetContent: function (content) {\r\n\t\tthis._content = content;\r\n\t\tthis.update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetElement: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._container.style.visibility = 'hidden';\r\n\r\n\t\tthis._updateContent();\r\n\t\tthis._updateLayout();\r\n\t\tthis._updatePosition();\r\n\r\n\t\tthis._container.style.visibility = '';\r\n\r\n\t\tthis._adjustPan();\r\n\t},\r\n\r\n\tgetEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tzoom: this._updatePosition,\r\n\t\t\tviewreset: this._updatePosition\r\n\t\t};\r\n\r\n\t\tif (this._zoomAnimated) {\r\n\t\t\tevents.zoomanim = this._animateZoom;\r\n\t\t}\r\n\t\tif ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n\t\t\tevents.preclick = this._close;\r\n\t\t}\r\n\t\tif (this.options.keepInView) {\r\n\t\t\tevents.moveend = this._adjustPan;\r\n\t\t}\r\n\t\treturn events;\r\n\t},\r\n\r\n\tisOpen: function () {\r\n\t\treturn !!this._map && this._map.hasLayer(this);\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tif (this._map) {\r\n\t\t\tL.DomUtil.toFront(this._container);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tif (this._map) {\r\n\t\t\tL.DomUtil.toBack(this._container);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_close: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.closePopup(this);\r\n\t\t}\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar prefix = 'leaflet-popup',\r\n\t\t    container = this._container = L.DomUtil.create('div',\r\n\t\t\tprefix + ' ' + (this.options.className || '') +\r\n\t\t\t' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide'));\r\n\r\n\t\tif (this.options.closeButton) {\r\n\t\t\tvar closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);\r\n\t\t\tcloseButton.href = '#close';\r\n\t\t\tcloseButton.innerHTML = '&#215;';\r\n\r\n\t\t\tL.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\r\n\t\t}\r\n\r\n\t\tvar wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);\r\n\t\tthis._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\r\n\r\n\t\tL.DomEvent\r\n\t\t\t.disableClickPropagation(wrapper)\r\n\t\t\t.disableScrollPropagation(this._contentNode)\r\n\t\t\t.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\r\n\r\n\t\tthis._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\r\n\t\tthis._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\r\n\t},\r\n\r\n\t_updateContent: function () {\r\n\t\tif (!this._content) { return; }\r\n\r\n\t\tvar node = this._contentNode;\r\n\t\tvar content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;\r\n\r\n\t\tif (typeof content === 'string') {\r\n\t\t\tnode.innerHTML = content;\r\n\t\t} else {\r\n\t\t\twhile (node.hasChildNodes()) {\r\n\t\t\t\tnode.removeChild(node.firstChild);\r\n\t\t\t}\r\n\t\t\tnode.appendChild(content);\r\n\t\t}\r\n\t\tthis.fire('contentupdate');\r\n\t},\r\n\r\n\t_updateLayout: function () {\r\n\t\tvar container = this._contentNode,\r\n\t\t    style = container.style;\r\n\r\n\t\tstyle.width = '';\r\n\t\tstyle.whiteSpace = 'nowrap';\r\n\r\n\t\tvar width = container.offsetWidth;\r\n\t\twidth = Math.min(width, this.options.maxWidth);\r\n\t\twidth = Math.max(width, this.options.minWidth);\r\n\r\n\t\tstyle.width = (width + 1) + 'px';\r\n\t\tstyle.whiteSpace = '';\r\n\r\n\t\tstyle.height = '';\r\n\r\n\t\tvar height = container.offsetHeight,\r\n\t\t    maxHeight = this.options.maxHeight,\r\n\t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n\t\tif (maxHeight && height > maxHeight) {\r\n\t\t\tstyle.height = maxHeight + 'px';\r\n\t\t\tL.DomUtil.addClass(container, scrolledClass);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.removeClass(container, scrolledClass);\r\n\t\t}\r\n\r\n\t\tthis._containerWidth = this._container.offsetWidth;\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n\t\t    offset = L.point(this.options.offset);\r\n\r\n\t\tif (this._zoomAnimated) {\r\n\t\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t\t} else {\r\n\t\t\toffset = offset.add(pos);\r\n\t\t}\r\n\r\n\t\tvar bottom = this._containerBottom = -offset.y,\r\n\t\t    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;\r\n\r\n\t\t// bottom position the popup in case the height of the popup changes (images loading etc)\r\n\t\tthis._container.style.bottom = bottom + 'px';\r\n\t\tthis._container.style.left = left + 'px';\r\n\t},\r\n\r\n\t_animateZoom: function (e) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\r\n\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t},\r\n\r\n\t_adjustPan: function () {\r\n\t\tif (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerHeight = this._container.offsetHeight,\r\n\t\t    containerWidth = this._containerWidth,\r\n\t\t    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n\t\tif (this._zoomAnimated) {\r\n\t\t\tlayerPos._add(L.DomUtil.getPosition(this._container));\r\n\t\t}\r\n\r\n\t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n\t\t    padding = L.point(this.options.autoPanPadding),\r\n\t\t    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\r\n\t\t    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\r\n\t\t    size = map.getSize(),\r\n\t\t    dx = 0,\r\n\t\t    dy = 0;\r\n\r\n\t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n\t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n\t\t}\r\n\t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n\t\t\tdx = containerPos.x - paddingTL.x;\r\n\t\t}\r\n\t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n\t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n\t\t}\r\n\t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n\t\t\tdy = containerPos.y - paddingTL.y;\r\n\t\t}\r\n\r\n\t\tif (dx || dy) {\r\n\t\t\tmap\r\n\t\t\t    .fire('autopanstart')\r\n\t\t\t    .panBy([dx, dy]);\r\n\t\t}\r\n\t},\r\n\r\n\t_onCloseButtonClick: function (e) {\r\n\t\tthis._close();\r\n\t\tL.DomEvent.stop(e);\r\n\t}\r\n});\r\n\r\nL.popup = function (options, source) {\r\n\treturn new L.Popup(options, source);\r\n};\r\n\r\n\r\nL.Map.include({\r\n\topenPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])\r\n\t\tif (!(popup instanceof L.Popup)) {\r\n\t\t\tpopup = new L.Popup(options).setContent(popup);\r\n\t\t}\r\n\r\n\t\tif (latlng) {\r\n\t\t\tpopup.setLatLng(latlng);\r\n\t\t}\r\n\r\n\t\tif (this.hasLayer(popup)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (this._popup && this._popup.options.autoClose) {\r\n\t\t\tthis.closePopup();\r\n\t\t}\r\n\r\n\t\tthis._popup = popup;\r\n\t\treturn this.addLayer(popup);\r\n\t},\r\n\r\n\tclosePopup: function (popup) {\r\n\t\tif (!popup || popup === this._popup) {\r\n\t\t\tpopup = this._popup;\r\n\t\t\tthis._popup = null;\r\n\t\t}\r\n\t\tif (popup) {\r\n\t\t\tthis.removeLayer(popup);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n\n/*\n * Adds popup-related methods to all layers.\n */\n\nL.Layer.include({\n\n\tbindPopup: function (content, options) {\n\n\t\tif (content instanceof L.Popup) {\n\t\t\tL.setOptions(content, options);\n\t\t\tthis._popup = content;\n\t\t\tcontent._source = this;\n\t\t} else {\n\t\t\tif (!this._popup || options) {\n\t\t\t\tthis._popup = new L.Popup(options, this);\n\t\t\t}\n\t\t\tthis._popup.setContent(content);\n\t\t}\n\n\t\tif (!this._popupHandlersAdded) {\n\t\t\tthis.on({\n\t\t\t\tclick: this._openPopup,\n\t\t\t\tremove: this.closePopup,\n\t\t\t\tmove: this._movePopup\n\t\t\t});\n\t\t\tthis._popupHandlersAdded = true;\n\t\t}\n\n\t\t// save the originally passed offset\n\t\tthis._originalPopupOffset = this._popup.options.offset;\n\n\t\treturn this;\n\t},\n\n\tunbindPopup: function () {\n\t\tif (this._popup) {\n\t\t\tthis.off({\n\t\t\t\tclick: this._openPopup,\n\t\t\t\tremove: this.closePopup,\n\t\t\t\tmove: this._movePopup\n\t\t\t});\n\t\t\tthis._popupHandlersAdded = false;\n\t\t\tthis._popup = null;\n\t\t}\n\t\treturn this;\n\t},\n\n\topenPopup: function (layer, latlng) {\n\t\tif (!(layer instanceof L.Layer)) {\n\t\t\tlatlng = layer;\n\t\t\tlayer = this;\n\t\t}\n\n\t\tif (layer instanceof L.FeatureGroup) {\n\t\t\tfor (var id in this._layers) {\n\t\t\t\tlayer = this._layers[id];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!latlng) {\n\t\t\tlatlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();\n\t\t}\n\n\t\tif (this._popup && this._map) {\n\t\t\t// set the popup offset for this layer\n\t\t\tthis._popup.options.offset = this._popupAnchor(layer);\n\n\t\t\t// set popup source to this layer\n\t\t\tthis._popup._source = layer;\n\n\t\t\t// update the popup (content, layout, ect...)\n\t\t\tthis._popup.update();\n\n\t\t\t// open the popup on the map\n\t\t\tthis._map.openPopup(this._popup, latlng);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclosePopup: function () {\n\t\tif (this._popup) {\n\t\t\tthis._popup._close();\n\t\t}\n\t\treturn this;\n\t},\n\n\ttogglePopup: function (target) {\n\t\tif (this._popup) {\n\t\t\tif (this._popup._map) {\n\t\t\t\tthis.closePopup();\n\t\t\t} else {\n\t\t\t\tthis.openPopup(target);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\tisPopupOpen: function () {\n\t\treturn this._popup.isOpen();\n\t},\n\n\tsetPopupContent: function (content) {\n\t\tif (this._popup) {\n\t\t\tthis._popup.setContent(content);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetPopup: function () {\n\t\treturn this._popup;\n\t},\n\n\t_openPopup: function (e) {\n\t\tvar layer = e.layer || e.target;\n\n\t\tif (!this._popup) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._map) {\n\t\t\treturn;\n\t\t}\n\n\t\t// if this inherits from Path its a vector and we can just\n\t\t// open the popup at the new location\n\t\tif (layer instanceof L.Path) {\n\t\t\tthis.openPopup(e.layer || e.target, e.latlng);\n\t\t\treturn;\n\t\t}\n\n\t\t// otherwise treat it like a marker and figure out\n\t\t// if we should toggle it open/closed\n\t\tif (this._map.hasLayer(this._popup) && this._popup._source === layer) {\n\t\t\tthis.closePopup();\n\t\t} else {\n\t\t\tthis.openPopup(layer, e.latlng);\n\t\t}\n\t},\n\n\t_popupAnchor: function (layer) {\n\t\t// where shold we anchor the popup on this layer?\n\t\tvar anchor = layer._getPopupAnchor ? layer._getPopupAnchor() : [0, 0];\n\n\t\t// add the users passed offset to that\n\t\tvar offsetToAdd = this._originalPopupOffset || L.Popup.prototype.options.offset;\n\n\t\t// return the final point to anchor the popup\n\t\treturn L.point(anchor).add(offsetToAdd);\n\t},\n\n\t_movePopup: function (e) {\n\t\tthis._popup.setLatLng(e.latlng);\n\t}\n});\n\n\n\n/*\r\n * Popup extension to L.Marker, adding popup-related methods.\r\n */\r\n\r\nL.Marker.include({\r\n\t_getPopupAnchor: function () {\r\n\t\treturn this.options.icon.options.popupAnchor || [0, 0];\r\n\t}\r\n});\r\n\n\n\n/*\r\n * L.LayerGroup is a class to combine several layers into one so that\r\n * you can manipulate the group (e.g. add/remove it) as one layer.\r\n */\r\n\r\nL.LayerGroup = L.Layer.extend({\r\n\r\n\tinitialize: function (layers) {\r\n\t\tthis._layers = {};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (layers) {\r\n\t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\t\t\t\tthis.addLayer(layers[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tvar id = this.getLayerId(layer);\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.addLayer(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n\t\tif (this._map && this._layers[id]) {\r\n\t\t\tthis._map.removeLayer(this._layers[id]);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\treturn !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);\r\n\t},\r\n\r\n\tclearLayers: function () {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tthis.removeLayer(this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvoke: function (methodName) {\r\n\t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, layer;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tlayer = this._layers[i];\r\n\r\n\t\t\tif (layer[methodName]) {\r\n\t\t\t\tlayer[methodName].apply(layer, args);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmap.addLayer(this._layers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmap.removeLayer(this._layers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetLayer: function (id) {\r\n\t\treturn this._layers[id];\r\n\t},\r\n\r\n\tgetLayers: function () {\r\n\t\tvar layers = [];\r\n\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tlayers.push(this._layers[i]);\r\n\t\t}\r\n\t\treturn layers;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\treturn this.invoke('setZIndex', zIndex);\r\n\t},\r\n\r\n\tgetLayerId: function (layer) {\r\n\t\treturn L.stamp(layer);\r\n\t}\r\n});\r\n\r\nL.layerGroup = function (layers) {\r\n\treturn new L.LayerGroup(layers);\r\n};\r\n\n\n\n/*\r\n * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\r\n * shared between a group of interactive layers (like vectors or markers).\r\n */\r\n\r\nL.FeatureGroup = L.LayerGroup.extend({\r\n\r\n\taddLayer: function (layer) {\r\n\t\tif (this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tlayer.addEventParent(this);\r\n\r\n\t\tL.LayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n\t\treturn this.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tif (!this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif (layer in this._layers) {\r\n\t\t\tlayer = this._layers[layer];\r\n\t\t}\r\n\r\n\t\tlayer.removeEventParent(this);\r\n\r\n\t\tL.LayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n\t\treturn this.fire('layerremove', {layer: layer});\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\treturn this.invoke('setStyle', style);\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\treturn this.invoke('bringToFront');\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\treturn this.invoke('bringToBack');\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = new L.LatLngBounds();\r\n\r\n\t\tfor (var id in this._layers) {\r\n\t\t\tvar layer = this._layers[id];\r\n\t\t\tbounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\r\n\t\t}\r\n\t\treturn bounds;\r\n\t}\r\n});\r\n\r\nL.featureGroup = function (layers) {\r\n\treturn new L.FeatureGroup(layers);\r\n};\r\n\n\n\n/*\n * L.Renderer is a base class for renderer implementations (SVG, Canvas);\n * handles renderer container, bounds and zoom animation.\n */\n\nL.Renderer = L.Layer.extend({\n\n\toptions: {\n\t\t// how much to extend the clip area around the map view (relative to its size)\n\t\t// e.g. 0.1 would be 10% of map view in each direction; defaults to clip with the map view\n\t\tpadding: 0.1\n\t},\n\n\tinitialize: function (options) {\n\t\tL.setOptions(this, options);\n\t\tL.stamp(this);\n\t},\n\n\tonAdd: function () {\n\t\tif (!this._container) {\n\t\t\tthis._initContainer(); // defined by renderer implementations\n\n\t\t\tif (this._zoomAnimated) {\n\t\t\t\tL.DomUtil.addClass(this._container, 'leaflet-zoom-animated');\n\t\t\t}\n\t\t}\n\n\t\tthis.getPane().appendChild(this._container);\n\t\tthis._update();\n\t},\n\n\tonRemove: function () {\n\t\tL.DomUtil.remove(this._container);\n\t},\n\n\tgetEvents: function () {\n\t\tvar events = {\n\t\t\tviewreset: this._reset,\n\t\t\tzoomstart: this._onZoomStart,\n\t\t\tzoom: this._onZoom,\n\t\t\tmoveend: this._update\n\t\t};\n\t\tif (this._zoomAnimated) {\n\t\t\tevents.zoomanim = this._onAnimZoom;\n\t\t}\n\t\treturn events;\n\t},\n\n\t_onAnimZoom: function (ev) {\n\t\tthis._updateTransform(ev.center, ev.zoom);\n\t},\n\n\t_onZoom: function () {\n\t\tthis._updateTransform(this._map.getCenter(), this._map.getZoom());\n\t},\n\n\t_onZoomStart: function () {\n\t\t// Drag-then-pinch interactions might mess up the center and zoom.\n\t\t// In this case, the easiest way to prevent this is re-do the renderer\n\t\t//   bounds and padding when the zooming starts.\n\t\tthis._update();\n\t},\n\n\t_updateTransform: function (center, zoom) {\n\t\tvar scale = this._map.getZoomScale(zoom, this._zoom),\n\t\t    position = L.DomUtil.getPosition(this._container),\n\t\t    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n\t\t    currentCenterPoint = this._map.project(this._center, zoom),\n\t\t    destCenterPoint = this._map.project(center, zoom),\n\t\t    centerOffset = destCenterPoint.subtract(currentCenterPoint),\n\n\t\t    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);\n\n\t\tL.DomUtil.setTransform(this._container, topLeftOffset, scale);\n\t},\n\n\t_reset: function () {\n\t\tthis._update();\n\t\tthis._updateTransform(this._center, this._zoom);\n\t},\n\n\t_update: function () {\n\t\t// update pixel bounds of renderer container (for positioning/sizing/clipping later)\n\t\tvar p = this.options.padding,\n\t\t    size = this._map.getSize(),\n\t\t    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n\t\tthis._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n\n\t\tthis._center = this._map.getCenter();\n\t\tthis._zoom = this._map.getZoom();\n\t}\n});\n\n\nL.Map.include({\n\t// used by each vector layer to decide which renderer to use\n\tgetRenderer: function (layer) {\n\t\tvar renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n\n\t\tif (!renderer) {\n\t\t\trenderer = this._renderer = (this.options.preferCanvas && L.canvas()) || L.svg();\n\t\t}\n\n\t\tif (!this.hasLayer(renderer)) {\n\t\t\tthis.addLayer(renderer);\n\t\t}\n\t\treturn renderer;\n\t},\n\n\t_getPaneRenderer: function (name) {\n\t\tif (name === 'overlayPane' || name === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar renderer = this._paneRenderers[name];\n\t\tif (renderer === undefined) {\n\t\t\trenderer = (L.SVG && L.svg({pane: name})) || (L.Canvas && L.canvas({pane: name}));\n\t\t\tthis._paneRenderers[name] = renderer;\n\t\t}\n\t\treturn renderer;\n\t}\n});\n\n\n\n/*\n * L.Path is the base class for all Leaflet vector layers like polygons and circles.\n */\n\nL.Path = L.Layer.extend({\n\n\toptions: {\n\t\tstroke: true,\n\t\tcolor: '#3388ff',\n\t\tweight: 3,\n\t\topacity: 1,\n\t\tlineCap: 'round',\n\t\tlineJoin: 'round',\n\t\t// dashArray: null\n\t\t// dashOffset: null\n\n\t\t// fill: false\n\t\t// fillColor: same as color by default\n\t\tfillOpacity: 0.2,\n\t\tfillRule: 'evenodd',\n\n\t\t// className: ''\n\t\tinteractive: true\n\t},\n\n\tbeforeAdd: function (map) {\n\t\t// Renderer is set here because we need to call renderer.getEvents\n\t\t// before this.getEvents.\n\t\tthis._renderer = map.getRenderer(this);\n\t},\n\n\tonAdd: function () {\n\t\tthis._renderer._initPath(this);\n\t\tthis._reset();\n\t\tthis._renderer._addPath(this);\n\t},\n\n\tonRemove: function () {\n\t\tthis._renderer._removePath(this);\n\t},\n\n\tgetEvents: function () {\n\t\treturn {\n\t\t\tzoomend: this._project,\n\t\t\tmoveend: this._update,\n\t\t\tviewreset: this._reset\n\t\t};\n\t},\n\n\tredraw: function () {\n\t\tif (this._map) {\n\t\t\tthis._renderer._updatePath(this);\n\t\t}\n\t\treturn this;\n\t},\n\n\tsetStyle: function (style) {\n\t\tL.setOptions(this, style);\n\t\tif (this._renderer) {\n\t\t\tthis._renderer._updateStyle(this);\n\t\t}\n\t\treturn this;\n\t},\n\n\tbringToFront: function () {\n\t\tif (this._renderer) {\n\t\t\tthis._renderer._bringToFront(this);\n\t\t}\n\t\treturn this;\n\t},\n\n\tbringToBack: function () {\n\t\tif (this._renderer) {\n\t\t\tthis._renderer._bringToBack(this);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetElement: function () {\n\t\treturn this._path;\n\t},\n\n\t_reset: function () {\n\t\t// defined in children classes\n\t\tthis._project();\n\t\tthis._update();\n\t},\n\n\t_clickTolerance: function () {\n\t\t// used when doing hit detection for Canvas layers\n\t\treturn (this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0);\n\t}\n});\n\n\n\n/*\r\n * L.LineUtil contains different utility functions for line segments\r\n * and polylines (clipping, simplification, distances, etc.)\r\n */\r\n\r\nL.LineUtil = {\r\n\r\n\t// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n\t// Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n\tsimplify: function (points, tolerance) {\r\n\t\tif (!tolerance || !points.length) {\r\n\t\t\treturn points.slice();\r\n\t\t}\r\n\r\n\t\tvar sqTolerance = tolerance * tolerance;\r\n\r\n\t\t// stage 1: vertex reduction\r\n\t\tpoints = this._reducePoints(points, sqTolerance);\r\n\r\n\t\t// stage 2: Douglas-Peucker simplification\r\n\t\tpoints = this._simplifyDP(points, sqTolerance);\r\n\r\n\t\treturn points;\r\n\t},\r\n\r\n\t// distance from a point to a segment between two points\r\n\tpointToSegmentDistance:  function (p, p1, p2) {\r\n\t\treturn Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\r\n\t},\r\n\r\n\tclosestPointOnSegment: function (p, p1, p2) {\r\n\t\treturn this._sqClosestPointOnSegment(p, p1, p2);\r\n\t},\r\n\r\n\t// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\n\t_simplifyDP: function (points, sqTolerance) {\r\n\r\n\t\tvar len = points.length,\r\n\t\t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n\t\t    markers = new ArrayConstructor(len);\r\n\r\n\t\tmarkers[0] = markers[len - 1] = 1;\r\n\r\n\t\tthis._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n\t\tvar i,\r\n\t\t    newPoints = [];\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (markers[i]) {\r\n\t\t\t\tnewPoints.push(points[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newPoints;\r\n\t},\r\n\r\n\t_simplifyDPStep: function (points, markers, sqTolerance, first, last) {\r\n\r\n\t\tvar maxSqDist = 0,\r\n\t\t    index, i, sqDist;\r\n\r\n\t\tfor (i = first + 1; i <= last - 1; i++) {\r\n\t\t\tsqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n\t\t\tif (sqDist > maxSqDist) {\r\n\t\t\t\tindex = i;\r\n\t\t\t\tmaxSqDist = sqDist;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (maxSqDist > sqTolerance) {\r\n\t\t\tmarkers[index] = 1;\r\n\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, first, index);\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, index, last);\r\n\t\t}\r\n\t},\r\n\r\n\t// reduce points that are too close to each other to a single point\r\n\t_reducePoints: function (points, sqTolerance) {\r\n\t\tvar reducedPoints = [points[0]];\r\n\r\n\t\tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n\t\t\tif (this._sqDist(points[i], points[prev]) > sqTolerance) {\r\n\t\t\t\treducedPoints.push(points[i]);\r\n\t\t\t\tprev = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (prev < len - 1) {\r\n\t\t\treducedPoints.push(points[len - 1]);\r\n\t\t}\r\n\t\treturn reducedPoints;\r\n\t},\r\n\r\n\t// Cohen-Sutherland line clipping algorithm.\r\n\t// Used to avoid rendering parts of a polyline that are not currently visible.\r\n\r\n\tclipSegment: function (a, b, bounds, useLastCode, round) {\r\n\t\tvar codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\r\n\t\t    codeB = this._getBitCode(b, bounds),\r\n\r\n\t\t    codeOut, p, newCode;\r\n\r\n\t\t// save 2nd code to avoid calculating it on the next segment\r\n\t\tthis._lastCode = codeB;\r\n\r\n\t\twhile (true) {\r\n\t\t\t// if a,b is inside the clip window (trivial accept)\r\n\t\t\tif (!(codeA | codeB)) { return [a, b]; }\r\n\r\n\t\t\t// if a,b is outside the clip window (trivial reject)\r\n\t\t\tif (codeA & codeB) { return false; }\r\n\r\n\t\t\t// other cases\r\n\t\t\tcodeOut = codeA || codeB;\r\n\t\t\tp = this._getEdgeIntersection(a, b, codeOut, bounds, round);\r\n\t\t\tnewCode = this._getBitCode(p, bounds);\r\n\r\n\t\t\tif (codeOut === codeA) {\r\n\t\t\t\ta = p;\r\n\t\t\t\tcodeA = newCode;\r\n\t\t\t} else {\r\n\t\t\t\tb = p;\r\n\t\t\t\tcodeB = newCode;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getEdgeIntersection: function (a, b, code, bounds, round) {\r\n\t\tvar dx = b.x - a.x,\r\n\t\t    dy = b.y - a.y,\r\n\t\t    min = bounds.min,\r\n\t\t    max = bounds.max,\r\n\t\t    x, y;\r\n\r\n\t\tif (code & 8) { // top\r\n\t\t\tx = a.x + dx * (max.y - a.y) / dy;\r\n\t\t\ty = max.y;\r\n\r\n\t\t} else if (code & 4) { // bottom\r\n\t\t\tx = a.x + dx * (min.y - a.y) / dy;\r\n\t\t\ty = min.y;\r\n\r\n\t\t} else if (code & 2) { // right\r\n\t\t\tx = max.x;\r\n\t\t\ty = a.y + dy * (max.x - a.x) / dx;\r\n\r\n\t\t} else if (code & 1) { // left\r\n\t\t\tx = min.x;\r\n\t\t\ty = a.y + dy * (min.x - a.x) / dx;\r\n\t\t}\r\n\r\n\t\treturn new L.Point(x, y, round);\r\n\t},\r\n\r\n\t_getBitCode: function (p, bounds) {\r\n\t\tvar code = 0;\r\n\r\n\t\tif (p.x < bounds.min.x) { // left\r\n\t\t\tcode |= 1;\r\n\t\t} else if (p.x > bounds.max.x) { // right\r\n\t\t\tcode |= 2;\r\n\t\t}\r\n\r\n\t\tif (p.y < bounds.min.y) { // bottom\r\n\t\t\tcode |= 4;\r\n\t\t} else if (p.y > bounds.max.y) { // top\r\n\t\t\tcode |= 8;\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\t},\r\n\r\n\t// square distance (to avoid unnecessary Math.sqrt calls)\r\n\t_sqDist: function (p1, p2) {\r\n\t\tvar dx = p2.x - p1.x,\r\n\t\t    dy = p2.y - p1.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\t},\r\n\r\n\t// return closest point on segment or distance to that point\r\n\t_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\r\n\t\tvar x = p1.x,\r\n\t\t    y = p1.y,\r\n\t\t    dx = p2.x - x,\r\n\t\t    dy = p2.y - y,\r\n\t\t    dot = dx * dx + dy * dy,\r\n\t\t    t;\r\n\r\n\t\tif (dot > 0) {\r\n\t\t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n\t\t\tif (t > 1) {\r\n\t\t\t\tx = p2.x;\r\n\t\t\t\ty = p2.y;\r\n\t\t\t} else if (t > 0) {\r\n\t\t\t\tx += dx * t;\r\n\t\t\t\ty += dy * t;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdx = p.x - x;\r\n\t\tdy = p.y - y;\r\n\r\n\t\treturn sqDist ? dx * dx + dy * dy : new L.Point(x, y);\r\n\t}\r\n};\r\n\n\n\n/*\n * L.Polyline implements polyline vector layer (a set of points connected with lines)\n */\n\nL.Polyline = L.Path.extend({\n\n\toptions: {\n\t\t// how much to simplify the polyline on each zoom level\n\t\t// more = better performance and smoother look, less = more accurate\n\t\tsmoothFactor: 1.0\n\t\t// noClip: false\n\t},\n\n\tinitialize: function (latlngs, options) {\n\t\tL.setOptions(this, options);\n\t\tthis._setLatLngs(latlngs);\n\t},\n\n\tgetLatLngs: function () {\n\t\treturn this._latlngs;\n\t},\n\n\tsetLatLngs: function (latlngs) {\n\t\tthis._setLatLngs(latlngs);\n\t\treturn this.redraw();\n\t},\n\n\tisEmpty: function () {\n\t\treturn !this._latlngs.length;\n\t},\n\n\tclosestLayerPoint: function (p) {\n\t\tvar minDistance = Infinity,\n\t\t    minPoint = null,\n\t\t    closest = L.LineUtil._sqClosestPointOnSegment,\n\t\t    p1, p2;\n\n\t\tfor (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n\t\t\tvar points = this._parts[j];\n\n\t\t\tfor (var i = 1, len = points.length; i < len; i++) {\n\t\t\t\tp1 = points[i - 1];\n\t\t\t\tp2 = points[i];\n\n\t\t\t\tvar sqDist = closest(p, p1, p2, true);\n\n\t\t\t\tif (sqDist < minDistance) {\n\t\t\t\t\tminDistance = sqDist;\n\t\t\t\t\tminPoint = closest(p, p1, p2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (minPoint) {\n\t\t\tminPoint.distance = Math.sqrt(minDistance);\n\t\t}\n\t\treturn minPoint;\n\t},\n\n\tgetCenter: function () {\n\t\tvar i, halfDist, segDist, dist, p1, p2, ratio,\n\t\t    points = this._rings[0],\n\t\t    len = points.length;\n\n\t\tif (!len) { return null; }\n\n\t\t// polyline centroid algorithm; only uses the first ring if there are multiple\n\n\t\tfor (i = 0, halfDist = 0; i < len - 1; i++) {\n\t\t\thalfDist += points[i].distanceTo(points[i + 1]) / 2;\n\t\t}\n\n\t\t// The line is so small in the current view that all points are on the same pixel.\n\t\tif (halfDist === 0) {\n\t\t\treturn this._map.layerPointToLatLng(points[0]);\n\t\t}\n\n\t\tfor (i = 0, dist = 0; i < len - 1; i++) {\n\t\t\tp1 = points[i];\n\t\t\tp2 = points[i + 1];\n\t\t\tsegDist = p1.distanceTo(p2);\n\t\t\tdist += segDist;\n\n\t\t\tif (dist > halfDist) {\n\t\t\t\tratio = (dist - halfDist) / segDist;\n\t\t\t\treturn this._map.layerPointToLatLng([\n\t\t\t\t\tp2.x - ratio * (p2.x - p1.x),\n\t\t\t\t\tp2.y - ratio * (p2.y - p1.y)\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetBounds: function () {\n\t\treturn this._bounds;\n\t},\n\n\taddLatLng: function (latlng, latlngs) {\n\t\tlatlngs = latlngs || this._defaultShape();\n\t\tlatlng = L.latLng(latlng);\n\t\tlatlngs.push(latlng);\n\t\tthis._bounds.extend(latlng);\n\t\treturn this.redraw();\n\t},\n\n\t_setLatLngs: function (latlngs) {\n\t\tthis._bounds = new L.LatLngBounds();\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\n\t},\n\n\t_defaultShape: function () {\n\t\treturn L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];\n\t},\n\n\t// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n\t_convertLatLngs: function (latlngs) {\n\t\tvar result = [],\n\t\t    flat = L.Polyline._flat(latlngs);\n\n\t\tfor (var i = 0, len = latlngs.length; i < len; i++) {\n\t\t\tif (flat) {\n\t\t\t\tresult[i] = L.latLng(latlngs[i]);\n\t\t\t\tthis._bounds.extend(result[i]);\n\t\t\t} else {\n\t\t\t\tresult[i] = this._convertLatLngs(latlngs[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t_project: function () {\n\t\tthis._rings = [];\n\t\tthis._projectLatlngs(this._latlngs, this._rings);\n\n\t\t// project bounds as well to use later for Canvas hit detection/etc.\n\t\tvar w = this._clickTolerance(),\n\t\t    p = new L.Point(w, -w);\n\n\t\tif (this._bounds.isValid()) {\n\t\t\tthis._pxBounds = new L.Bounds(\n\t\t\t\tthis._map.latLngToLayerPoint(this._bounds.getSouthWest())._subtract(p),\n\t\t\t\tthis._map.latLngToLayerPoint(this._bounds.getNorthEast())._add(p));\n\t\t}\n\t},\n\n\t// recursively turns latlngs into a set of rings with projected coordinates\n\t_projectLatlngs: function (latlngs, result) {\n\n\t\tvar flat = latlngs[0] instanceof L.LatLng,\n\t\t    len = latlngs.length,\n\t\t    i, ring;\n\n\t\tif (flat) {\n\t\t\tring = [];\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n\t\t\t}\n\t\t\tresult.push(ring);\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tthis._projectLatlngs(latlngs[i], result);\n\t\t\t}\n\t\t}\n\t},\n\n\t// clip polyline by renderer bounds so that we have less to render for performance\n\t_clipPoints: function () {\n\t\tvar bounds = this._renderer._bounds;\n\n\t\tthis._parts = [];\n\t\tif (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.options.noClip) {\n\t\t\tthis._parts = this._rings;\n\t\t\treturn;\n\t\t}\n\n\t\tvar parts = this._parts,\n\t\t    i, j, k, len, len2, segment, points;\n\n\t\tfor (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n\t\t\tpoints = this._rings[i];\n\n\t\t\tfor (j = 0, len2 = points.length; j < len2 - 1; j++) {\n\t\t\t\tsegment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);\n\n\t\t\t\tif (!segment) { continue; }\n\n\t\t\t\tparts[k] = parts[k] || [];\n\t\t\t\tparts[k].push(segment[0]);\n\n\t\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\n\t\t\t\tif ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {\n\t\t\t\t\tparts[k].push(segment[1]);\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// simplify each clipped part of the polyline for performance\n\t_simplifyPoints: function () {\n\t\tvar parts = this._parts,\n\t\t    tolerance = this.options.smoothFactor;\n\n\t\tfor (var i = 0, len = parts.length; i < len; i++) {\n\t\t\tparts[i] = L.LineUtil.simplify(parts[i], tolerance);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tif (!this._map) { return; }\n\n\t\tthis._clipPoints();\n\t\tthis._simplifyPoints();\n\t\tthis._updatePath();\n\t},\n\n\t_updatePath: function () {\n\t\tthis._renderer._updatePoly(this);\n\t}\n});\n\nL.polyline = function (latlngs, options) {\n\treturn new L.Polyline(latlngs, options);\n};\n\nL.Polyline._flat = function (latlngs) {\n\t// true if it's a flat array of latlngs; false if nested\n\treturn !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\n};\n\n\n\n/*\r\n * L.PolyUtil contains utility functions for polygons (clipping, etc.).\r\n */\r\n\r\nL.PolyUtil = {};\r\n\r\n/*\r\n * Sutherland-Hodgeman polygon clipping algorithm.\r\n * Used to avoid rendering parts of a polygon that are not currently visible.\r\n */\r\nL.PolyUtil.clipPolygon = function (points, bounds, round) {\r\n\tvar clippedPoints,\r\n\t    edges = [1, 4, 2, 8],\r\n\t    i, j, k,\r\n\t    a, b,\r\n\t    len, edge, p,\r\n\t    lu = L.LineUtil;\r\n\r\n\tfor (i = 0, len = points.length; i < len; i++) {\r\n\t\tpoints[i]._code = lu._getBitCode(points[i], bounds);\r\n\t}\r\n\r\n\t// for each edge (left, bottom, right, top)\r\n\tfor (k = 0; k < 4; k++) {\r\n\t\tedge = edges[k];\r\n\t\tclippedPoints = [];\r\n\r\n\t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n\t\t\ta = points[i];\r\n\t\t\tb = points[j];\r\n\r\n\t\t\t// if a is inside the clip window\r\n\t\t\tif (!(a._code & edge)) {\r\n\t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n\t\t\t\tif (b._code & edge) {\r\n\t\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds, round);\r\n\t\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\t\tclippedPoints.push(p);\r\n\t\t\t\t}\r\n\t\t\t\tclippedPoints.push(a);\r\n\r\n\t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n\t\t\t} else if (!(b._code & edge)) {\r\n\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds, round);\r\n\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\tclippedPoints.push(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpoints = clippedPoints;\r\n\t}\r\n\r\n\treturn points;\r\n};\r\n\n\n\n/*\n * L.Polygon implements polygon vector layer (closed polyline with a fill inside).\n */\n\nL.Polygon = L.Polyline.extend({\n\n\toptions: {\n\t\tfill: true\n\t},\n\n\tisEmpty: function () {\n\t\treturn !this._latlngs.length || !this._latlngs[0].length;\n\t},\n\n\tgetCenter: function () {\n\t\tvar i, j, p1, p2, f, area, x, y, center,\n\t\t    points = this._rings[0],\n\t\t    len = points.length;\n\n\t\tif (!len) { return null; }\n\n\t\t// polygon centroid algorithm; only uses the first ring if there are multiple\n\n\t\tarea = x = y = 0;\n\n\t\tfor (i = 0, j = len - 1; i < len; j = i++) {\n\t\t\tp1 = points[i];\n\t\t\tp2 = points[j];\n\n\t\t\tf = p1.y * p2.x - p2.y * p1.x;\n\t\t\tx += (p1.x + p2.x) * f;\n\t\t\ty += (p1.y + p2.y) * f;\n\t\t\tarea += f * 3;\n\t\t}\n\n\t\tif (area === 0) {\n\t\t\t// Polygon is so small that all points are on same pixel.\n\t\t\tcenter = points[0];\n\t\t} else {\n\t\t\tcenter = [x / area, y / area];\n\t\t}\n\t\treturn this._map.layerPointToLatLng(center);\n\t},\n\n\t_convertLatLngs: function (latlngs) {\n\t\tvar result = L.Polyline.prototype._convertLatLngs.call(this, latlngs),\n\t\t    len = result.length;\n\n\t\t// remove last point if it equals first one\n\t\tif (len >= 2 && result[0] instanceof L.LatLng && result[0].equals(result[len - 1])) {\n\t\t\tresult.pop();\n\t\t}\n\t\treturn result;\n\t},\n\n\t_setLatLngs: function (latlngs) {\n\t\tL.Polyline.prototype._setLatLngs.call(this, latlngs);\n\t\tif (L.Polyline._flat(this._latlngs)) {\n\t\t\tthis._latlngs = [this._latlngs];\n\t\t}\n\t},\n\n\t_defaultShape: function () {\n\t\treturn L.Polyline._flat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n\t},\n\n\t_clipPoints: function () {\n\t\t// polygons need a different clipping algorithm so we redefine that\n\n\t\tvar bounds = this._renderer._bounds,\n\t\t    w = this.options.weight,\n\t\t    p = new L.Point(w, w);\n\n\t\t// increase clip padding by stroke width to avoid stroke on clip edges\n\t\tbounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));\n\n\t\tthis._parts = [];\n\t\tif (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.options.noClip) {\n\t\t\tthis._parts = this._rings;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n\t\t\tclipped = L.PolyUtil.clipPolygon(this._rings[i], bounds, true);\n\t\t\tif (clipped.length) {\n\t\t\t\tthis._parts.push(clipped);\n\t\t\t}\n\t\t}\n\t},\n\n\t_updatePath: function () {\n\t\tthis._renderer._updatePoly(this, true);\n\t}\n});\n\nL.polygon = function (latlngs, options) {\n\treturn new L.Polygon(latlngs, options);\n};\n\n\n\n/*\n * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n */\n\nL.Rectangle = L.Polygon.extend({\n\tinitialize: function (latLngBounds, options) {\n\t\tL.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n\t},\n\n\tsetBounds: function (latLngBounds) {\n\t\treturn this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n\t},\n\n\t_boundsToLatLngs: function (latLngBounds) {\n\t\tlatLngBounds = L.latLngBounds(latLngBounds);\n\t\treturn [\n\t\t\tlatLngBounds.getSouthWest(),\n\t\t\tlatLngBounds.getNorthWest(),\n\t\t\tlatLngBounds.getNorthEast(),\n\t\t\tlatLngBounds.getSouthEast()\n\t\t];\n\t}\n});\n\nL.rectangle = function (latLngBounds, options) {\n\treturn new L.Rectangle(latLngBounds, options);\n};\n\n\n\n/*\n * L.CircleMarker is a circle overlay with a permanent pixel radius.\n */\n\nL.CircleMarker = L.Path.extend({\n\n\toptions: {\n\t\tfill: true,\n\t\tradius: 10\n\t},\n\n\tinitialize: function (latlng, options) {\n\t\tL.setOptions(this, options);\n\t\tthis._latlng = L.latLng(latlng);\n\t\tthis._radius = this.options.radius;\n\t},\n\n\tsetLatLng: function (latlng) {\n\t\tthis._latlng = L.latLng(latlng);\n\t\tthis.redraw();\n\t\treturn this.fire('move', {latlng: this._latlng});\n\t},\n\n\tgetLatLng: function () {\n\t\treturn this._latlng;\n\t},\n\n\tsetRadius: function (radius) {\n\t\tthis.options.radius = this._radius = radius;\n\t\treturn this.redraw();\n\t},\n\n\tgetRadius: function () {\n\t\treturn this._radius;\n\t},\n\n\tsetStyle : function (options) {\n\t\tvar radius = options && options.radius || this._radius;\n\t\tL.Path.prototype.setStyle.call(this, options);\n\t\tthis.setRadius(radius);\n\t\treturn this;\n\t},\n\n\t_project: function () {\n\t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\n\t\tthis._updateBounds();\n\t},\n\n\t_updateBounds: function () {\n\t\tvar r = this._radius,\n\t\t    r2 = this._radiusY || r,\n\t\t    w = this._clickTolerance(),\n\t\t    p = [r + w, r2 + w];\n\t\tthis._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));\n\t},\n\n\t_update: function () {\n\t\tif (this._map) {\n\t\t\tthis._updatePath();\n\t\t}\n\t},\n\n\t_updatePath: function () {\n\t\tthis._renderer._updateCircle(this);\n\t},\n\n\t_empty: function () {\n\t\treturn this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n\t}\n});\n\nL.circleMarker = function (latlng, options) {\n\treturn new L.CircleMarker(latlng, options);\n};\n\n\n\n/*\n * L.Circle is a circle overlay (with a certain radius in meters).\n * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion)\n */\n\nL.Circle = L.CircleMarker.extend({\n\n\tinitialize: function (latlng, options) {\n\t\tL.setOptions(this, options);\n\t\tthis._latlng = L.latLng(latlng);\n\t\tthis._mRadius = this.options.radius;\n\t},\n\n\tsetRadius: function (radius) {\n\t\tthis._mRadius = radius;\n\t\treturn this.redraw();\n\t},\n\n\tgetRadius: function () {\n\t\treturn this._mRadius;\n\t},\n\n\tgetBounds: function () {\n\t\tvar half = [this._radius, this._radiusY || this._radius];\n\n\t\treturn new L.LatLngBounds(\n\t\t\tthis._map.layerPointToLatLng(this._point.subtract(half)),\n\t\t\tthis._map.layerPointToLatLng(this._point.add(half)));\n\t},\n\n\tsetStyle: L.Path.prototype.setStyle,\n\n\t_project: function () {\n\n\t\tvar lng = this._latlng.lng,\n\t\t    lat = this._latlng.lat,\n\t\t    map = this._map,\n\t\t    crs = map.options.crs;\n\n\t\tif (crs.distance === L.CRS.Earth.distance) {\n\t\t\tvar d = Math.PI / 180,\n\t\t\t    latR = (this._mRadius / L.CRS.Earth.R) / d,\n\t\t\t    top = map.project([lat + latR, lng]),\n\t\t\t    bottom = map.project([lat - latR, lng]),\n\t\t\t    p = top.add(bottom).divideBy(2),\n\t\t\t    lat2 = map.unproject(p).lat,\n\t\t\t    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /\n\t\t\t            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n\n\t\t\tthis._point = p.subtract(map.getPixelOrigin());\n\t\t\tthis._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);\n\t\t\tthis._radiusY = Math.max(Math.round(p.y - top.y), 1);\n\n\t\t} else {\n\t\t\tvar latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n\n\t\t\tthis._point = map.latLngToLayerPoint(this._latlng);\n\t\t\tthis._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n\t\t}\n\n\t\tthis._updateBounds();\n\t}\n});\n\nL.circle = function (latlng, options, legacyOptions) {\n\tif (typeof options === 'number') {\n\t\t// Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n\t\toptions = L.extend({}, legacyOptions, {radius: options});\n\t}\n\treturn new L.Circle(latlng, options);\n};\n\n\n\n/*\n * L.SVG renders vector layers with SVG. All SVG-specific code goes here.\n */\n\nL.SVG = L.Renderer.extend({\n\n\t_initContainer: function () {\n\t\tthis._container = L.SVG.create('svg');\n\n\t\t// makes it possible to click through svg root; we'll reset it back in individual paths\n\t\tthis._container.setAttribute('pointer-events', 'none');\n\n\t\tthis._rootGroup = L.SVG.create('g');\n\t\tthis._container.appendChild(this._rootGroup);\n\t},\n\n\t_update: function () {\n\t\tif (this._map._animatingZoom && this._bounds) { return; }\n\n\t\tL.Renderer.prototype._update.call(this);\n\n\t\tvar b = this._bounds,\n\t\t    size = b.getSize(),\n\t\t    container = this._container;\n\n\t\t// set size of svg-container if changed\n\t\tif (!this._svgSize || !this._svgSize.equals(size)) {\n\t\t\tthis._svgSize = size;\n\t\t\tcontainer.setAttribute('width', size.x);\n\t\t\tcontainer.setAttribute('height', size.y);\n\t\t}\n\n\t\t// movement: update container viewBox so that we don't have to change coordinates of individual layers\n\t\tL.DomUtil.setPosition(container, b.min);\n\t\tcontainer.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n\t},\n\n\t// methods below are called by vector layers implementations\n\n\t_initPath: function (layer) {\n\t\tvar path = layer._path = L.SVG.create('path');\n\n\t\tif (layer.options.className) {\n\t\t\tL.DomUtil.addClass(path, layer.options.className);\n\t\t}\n\n\t\tif (layer.options.interactive) {\n\t\t\tL.DomUtil.addClass(path, 'leaflet-interactive');\n\t\t}\n\n\t\tthis._updateStyle(layer);\n\t},\n\n\t_addPath: function (layer) {\n\t\tthis._rootGroup.appendChild(layer._path);\n\t\tlayer.addInteractiveTarget(layer._path);\n\t},\n\n\t_removePath: function (layer) {\n\t\tL.DomUtil.remove(layer._path);\n\t\tlayer.removeInteractiveTarget(layer._path);\n\t},\n\n\t_updatePath: function (layer) {\n\t\tlayer._project();\n\t\tlayer._update();\n\t},\n\n\t_updateStyle: function (layer) {\n\t\tvar path = layer._path,\n\t\t    options = layer.options;\n\n\t\tif (!path) { return; }\n\n\t\tif (options.stroke) {\n\t\t\tpath.setAttribute('stroke', options.color);\n\t\t\tpath.setAttribute('stroke-opacity', options.opacity);\n\t\t\tpath.setAttribute('stroke-width', options.weight);\n\t\t\tpath.setAttribute('stroke-linecap', options.lineCap);\n\t\t\tpath.setAttribute('stroke-linejoin', options.lineJoin);\n\n\t\t\tif (options.dashArray) {\n\t\t\t\tpath.setAttribute('stroke-dasharray', options.dashArray);\n\t\t\t} else {\n\t\t\t\tpath.removeAttribute('stroke-dasharray');\n\t\t\t}\n\n\t\t\tif (options.dashOffset) {\n\t\t\t\tpath.setAttribute('stroke-dashoffset', options.dashOffset);\n\t\t\t} else {\n\t\t\t\tpath.removeAttribute('stroke-dashoffset');\n\t\t\t}\n\t\t} else {\n\t\t\tpath.setAttribute('stroke', 'none');\n\t\t}\n\n\t\tif (options.fill) {\n\t\t\tpath.setAttribute('fill', options.fillColor || options.color);\n\t\t\tpath.setAttribute('fill-opacity', options.fillOpacity);\n\t\t\tpath.setAttribute('fill-rule', options.fillRule || 'evenodd');\n\t\t} else {\n\t\t\tpath.setAttribute('fill', 'none');\n\t\t}\n\n\t\tpath.setAttribute('pointer-events', options.pointerEvents || (options.interactive ? 'visiblePainted' : 'none'));\n\t},\n\n\t_updatePoly: function (layer, closed) {\n\t\tthis._setPath(layer, L.SVG.pointsToPath(layer._parts, closed));\n\t},\n\n\t_updateCircle: function (layer) {\n\t\tvar p = layer._point,\n\t\t    r = layer._radius,\n\t\t    r2 = layer._radiusY || r,\n\t\t    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';\n\n\t\t// drawing a circle with two half-arcs\n\t\tvar d = layer._empty() ? 'M0 0' :\n\t\t\t\t'M' + (p.x - r) + ',' + p.y +\n\t\t\t\tarc + (r * 2) + ',0 ' +\n\t\t\t\tarc + (-r * 2) + ',0 ';\n\n\t\tthis._setPath(layer, d);\n\t},\n\n\t_setPath: function (layer, path) {\n\t\tlayer._path.setAttribute('d', path);\n\t},\n\n\t// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n\t_bringToFront: function (layer) {\n\t\tL.DomUtil.toFront(layer._path);\n\t},\n\n\t_bringToBack: function (layer) {\n\t\tL.DomUtil.toBack(layer._path);\n\t}\n});\n\n\nL.extend(L.SVG, {\n\tcreate: function (name) {\n\t\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n\t},\n\n\t// generates SVG path string for multiple rings, with each ring turning into \"M..L..L..\" instructions\n\tpointsToPath: function (rings, closed) {\n\t\tvar str = '',\n\t\t    i, j, len, len2, points, p;\n\n\t\tfor (i = 0, len = rings.length; i < len; i++) {\n\t\t\tpoints = rings[i];\n\n\t\t\tfor (j = 0, len2 = points.length; j < len2; j++) {\n\t\t\t\tp = points[j];\n\t\t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n\t\t\t}\n\n\t\t\t// closes the ring for polygons; \"x\" is VML syntax\n\t\t\tstr += closed ? (L.Browser.svg ? 'z' : 'x') : '';\n\t\t}\n\n\t\t// SVG complains about empty path strings\n\t\treturn str || 'M0 0';\n\t}\n});\n\nL.Browser.svg = !!(document.createElementNS && L.SVG.create('svg').createSVGRect);\n\nL.svg = function (options) {\n\treturn L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null;\n};\n\n\n\n/*\n * Vector rendering for IE7-8 through VML.\n * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n */\n\nL.Browser.vml = !L.Browser.svg && (function () {\n\ttry {\n\t\tvar div = document.createElement('div');\n\t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\n\n\t\tvar shape = div.firstChild;\n\t\tshape.style.behavior = 'url(#default#VML)';\n\n\t\treturn shape && (typeof shape.adj === 'object');\n\n\t} catch (e) {\n\t\treturn false;\n\t}\n}());\n\n// redefine some SVG methods to handle VML syntax which is similar but with some differences\nL.SVG.include(!L.Browser.vml ? {} : {\n\n\t_initContainer: function () {\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-vml-container');\n\t},\n\n\t_update: function () {\n\t\tif (this._map._animatingZoom) { return; }\n\t\tL.Renderer.prototype._update.call(this);\n\t},\n\n\t_initPath: function (layer) {\n\t\tvar container = layer._container = L.SVG.create('shape');\n\n\t\tL.DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n\n\t\tcontainer.coordsize = '1 1';\n\n\t\tlayer._path = L.SVG.create('path');\n\t\tcontainer.appendChild(layer._path);\n\n\t\tthis._updateStyle(layer);\n\t},\n\n\t_addPath: function (layer) {\n\t\tvar container = layer._container;\n\t\tthis._container.appendChild(container);\n\n\t\tif (layer.options.interactive) {\n\t\t\tlayer.addInteractiveTarget(container);\n\t\t}\n\t},\n\n\t_removePath: function (layer) {\n\t\tvar container = layer._container;\n\t\tL.DomUtil.remove(container);\n\t\tlayer.removeInteractiveTarget(container);\n\t},\n\n\t_updateStyle: function (layer) {\n\t\tvar stroke = layer._stroke,\n\t\t    fill = layer._fill,\n\t\t    options = layer.options,\n\t\t    container = layer._container;\n\n\t\tcontainer.stroked = !!options.stroke;\n\t\tcontainer.filled = !!options.fill;\n\n\t\tif (options.stroke) {\n\t\t\tif (!stroke) {\n\t\t\t\tstroke = layer._stroke = L.SVG.create('stroke');\n\t\t\t}\n\t\t\tcontainer.appendChild(stroke);\n\t\t\tstroke.weight = options.weight + 'px';\n\t\t\tstroke.color = options.color;\n\t\t\tstroke.opacity = options.opacity;\n\n\t\t\tif (options.dashArray) {\n\t\t\t\tstroke.dashStyle = L.Util.isArray(options.dashArray) ?\n\t\t\t\t    options.dashArray.join(' ') :\n\t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\n\t\t\t} else {\n\t\t\t\tstroke.dashStyle = '';\n\t\t\t}\n\t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\n\t\t\tstroke.joinstyle = options.lineJoin;\n\n\t\t} else if (stroke) {\n\t\t\tcontainer.removeChild(stroke);\n\t\t\tlayer._stroke = null;\n\t\t}\n\n\t\tif (options.fill) {\n\t\t\tif (!fill) {\n\t\t\t\tfill = layer._fill = L.SVG.create('fill');\n\t\t\t}\n\t\t\tcontainer.appendChild(fill);\n\t\t\tfill.color = options.fillColor || options.color;\n\t\t\tfill.opacity = options.fillOpacity;\n\n\t\t} else if (fill) {\n\t\t\tcontainer.removeChild(fill);\n\t\t\tlayer._fill = null;\n\t\t}\n\t},\n\n\t_updateCircle: function (layer) {\n\t\tvar p = layer._point.round(),\n\t\t    r = Math.round(layer._radius),\n\t\t    r2 = Math.round(layer._radiusY || r);\n\n\t\tthis._setPath(layer, layer._empty() ? 'M0 0' :\n\t\t\t\t'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));\n\t},\n\n\t_setPath: function (layer, path) {\n\t\tlayer._path.v = path;\n\t},\n\n\t_bringToFront: function (layer) {\n\t\tL.DomUtil.toFront(layer._container);\n\t},\n\n\t_bringToBack: function (layer) {\n\t\tL.DomUtil.toBack(layer._container);\n\t}\n});\n\nif (L.Browser.vml) {\n\tL.SVG.create = (function () {\n\t\ttry {\n\t\t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n\t\t\treturn function (name) {\n\t\t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\n\t\t\t};\n\t\t} catch (e) {\n\t\t\treturn function (name) {\n\t\t\t\treturn document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n\t\t\t};\n\t\t}\n\t})();\n}\n\n\n\n/*\n * L.Canvas handles Canvas vector layers rendering and mouse events handling. All Canvas-specific code goes here.\n */\n\nL.Canvas = L.Renderer.extend({\n\n\tonAdd: function () {\n\t\tL.Renderer.prototype.onAdd.call(this);\n\n\t\tthis._layers = this._layers || {};\n\n\t\t// Redraw vectors since canvas is cleared upon removal,\n\t\t// in case of removing the renderer itself from the map.\n\t\tthis._draw();\n\t},\n\n\t_initContainer: function () {\n\t\tvar container = this._container = document.createElement('canvas');\n\n\t\tL.DomEvent\n\t\t\t.on(container, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this)\n\t\t\t.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this)\n\t\t\t.on(container, 'mouseout', this._handleMouseOut, this);\n\n\t\tthis._ctx = container.getContext('2d');\n\t},\n\n\t_update: function () {\n\t\tif (this._map._animatingZoom && this._bounds) { return; }\n\n\t\tthis._drawnLayers = {};\n\n\t\tL.Renderer.prototype._update.call(this);\n\n\t\tvar b = this._bounds,\n\t\t    container = this._container,\n\t\t    size = b.getSize(),\n\t\t    m = L.Browser.retina ? 2 : 1;\n\n\t\tL.DomUtil.setPosition(container, b.min);\n\n\t\t// set canvas size (also clearing it); use double size on retina\n\t\tcontainer.width = m * size.x;\n\t\tcontainer.height = m * size.y;\n\t\tcontainer.style.width = size.x + 'px';\n\t\tcontainer.style.height = size.y + 'px';\n\n\t\tif (L.Browser.retina) {\n\t\t\tthis._ctx.scale(2, 2);\n\t\t}\n\n\t\t// translate so we use the same path coordinates after canvas element moves\n\t\tthis._ctx.translate(-b.min.x, -b.min.y);\n\t},\n\n\t_initPath: function (layer) {\n\t\tthis._layers[L.stamp(layer)] = layer;\n\t},\n\n\t_addPath: L.Util.falseFn,\n\n\t_removePath: function (layer) {\n\t\tlayer._removed = true;\n\t\tthis._requestRedraw(layer);\n\t},\n\n\t_updatePath: function (layer) {\n\t\tthis._redrawBounds = layer._pxBounds;\n\t\tthis._draw(true);\n\t\tlayer._project();\n\t\tlayer._update();\n\t\tthis._draw();\n\t\tthis._redrawBounds = null;\n\t},\n\n\t_updateStyle: function (layer) {\n\t\tthis._requestRedraw(layer);\n\t},\n\n\t_requestRedraw: function (layer) {\n\t\tif (!this._map) { return; }\n\n\t\tvar padding = (layer.options.weight || 0) + 1;\n\t\tthis._redrawBounds = this._redrawBounds || new L.Bounds();\n\t\tthis._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n\t\tthis._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n\n\t\tthis._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this);\n\t},\n\n\t_redraw: function () {\n\t\tthis._redrawRequest = null;\n\n\t\tthis._draw(true); // clear layers in redraw bounds\n\t\tthis._draw(); // draw layers\n\n\t\tthis._redrawBounds = null;\n\t},\n\n\t_draw: function (clear) {\n\t\tthis._clear = clear;\n\t\tvar layer, bounds = this._redrawBounds;\n\t\tthis._ctx.save();\n\t\tif (bounds) {\n\t\t\tthis._ctx.beginPath();\n\t\t\tthis._ctx.rect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\n\t\t\tthis._ctx.clip();\n\t\t}\n\n\t\tfor (var id in this._layers) {\n\t\t\tlayer = this._layers[id];\n\t\t\tif (!bounds || layer._pxBounds.intersects(bounds)) {\n\t\t\t\tlayer._updatePath();\n\t\t\t}\n\t\t\tif (clear && layer._removed) {\n\t\t\t\tdelete layer._removed;\n\t\t\t\tdelete this._layers[id];\n\t\t\t}\n\t\t}\n\t\tthis._ctx.restore();  // Restore state before clipping.\n\t},\n\n\t_updatePoly: function (layer, closed) {\n\n\t\tvar i, j, len2, p,\n\t\t    parts = layer._parts,\n\t\t    len = parts.length,\n\t\t    ctx = this._ctx;\n\n\t\tif (!len) { return; }\n\n\t\tthis._drawnLayers[layer._leaflet_id] = layer;\n\n\t\tctx.beginPath();\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tfor (j = 0, len2 = parts[i].length; j < len2; j++) {\n\t\t\t\tp = parts[i][j];\n\t\t\t\tctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n\t\t\t}\n\t\t\tif (closed) {\n\t\t\t\tctx.closePath();\n\t\t\t}\n\t\t}\n\n\t\tthis._fillStroke(ctx, layer);\n\n\t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n\t},\n\n\t_updateCircle: function (layer) {\n\n\t\tif (layer._empty()) { return; }\n\n\t\tvar p = layer._point,\n\t\t    ctx = this._ctx,\n\t\t    r = layer._radius,\n\t\t    s = (layer._radiusY || r) / r;\n\n\t\tif (s !== 1) {\n\t\t\tctx.save();\n\t\t\tctx.scale(1, s);\n\t\t}\n\n\t\tctx.beginPath();\n\t\tctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n\n\t\tif (s !== 1) {\n\t\t\tctx.restore();\n\t\t}\n\n\t\tthis._fillStroke(ctx, layer);\n\t},\n\n\t_fillStroke: function (ctx, layer) {\n\t\tvar clear = this._clear,\n\t\t    options = layer.options;\n\n\t\tctx.globalCompositeOperation = clear ? 'destination-out' : 'source-over';\n\n\t\tif (options.fill) {\n\t\t\tctx.globalAlpha = clear ? 1 : options.fillOpacity;\n\t\t\tctx.fillStyle = options.fillColor || options.color;\n\t\t\tctx.fill(options.fillRule || 'evenodd');\n\t\t}\n\n\t\tif (options.stroke && options.weight !== 0) {\n\t\t\tctx.globalAlpha = clear ? 1 : options.opacity;\n\n\t\t\t// if clearing shape, do it with the previously drawn line width\n\t\t\tlayer._prevWeight = ctx.lineWidth = clear ? layer._prevWeight + 1 : options.weight;\n\n\t\t\tctx.strokeStyle = options.color;\n\t\t\tctx.lineCap = options.lineCap;\n\t\t\tctx.lineJoin = options.lineJoin;\n\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t// Canvas obviously doesn't have mouse events for individual drawn objects,\n\t// so we emulate that by calculating what's under the mouse on mousemove/click manually\n\n\t_onClick: function (e) {\n\t\tvar point = this._map.mouseEventToLayerPoint(e), layers = [];\n\n\t\tfor (var id in this._layers) {\n\t\t\tif (this._layers[id]._containsPoint(point)) {\n\t\t\t\tL.DomEvent._fakeStop(e);\n\t\t\t\tlayers.push(this._layers[id]);\n\t\t\t}\n\t\t}\n\t\tif (layers.length)  {\n\t\t\tthis._fireEvent(layers, e);\n\t\t}\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._map || this._map.dragging._draggable._moving || this._map._animatingZoom) { return; }\n\n\t\tvar point = this._map.mouseEventToLayerPoint(e);\n\t\tthis._handleMouseOut(e, point);\n\t\tthis._handleMouseHover(e, point);\n\t},\n\n\n\t_handleMouseOut: function (e, point) {\n\t\tvar layer = this._hoveredLayer;\n\t\tif (layer && (e.type === 'mouseout' || !layer._containsPoint(point))) {\n\t\t\t// if we're leaving the layer, fire mouseout\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-interactive');\n\t\t\tthis._fireEvent([layer], e, 'mouseout');\n\t\t\tthis._hoveredLayer = null;\n\t\t}\n\t},\n\n\t_handleMouseHover: function (e, point) {\n\t\tvar id, layer;\n\t\tif (!this._hoveredLayer) {\n\t\t\tfor (id in this._drawnLayers) {\n\t\t\t\tlayer = this._drawnLayers[id];\n\t\t\t\tif (layer.options.interactive && layer._containsPoint(point)) {\n\t\t\t\t\tL.DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor\n\t\t\t\t\tthis._fireEvent([layer], e, 'mouseover');\n\t\t\t\t\tthis._hoveredLayer = layer;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this._hoveredLayer) {\n\t\t\tthis._fireEvent([this._hoveredLayer], e);\n\t\t}\n\t},\n\n\t_fireEvent: function (layers, e, type) {\n\t\tthis._map._fireDOMEvent(e, type || e.type, layers);\n\t},\n\n\t// TODO _bringToFront & _bringToBack, pretty tricky\n\n\t_bringToFront: L.Util.falseFn,\n\t_bringToBack: L.Util.falseFn\n});\n\nL.Browser.canvas = (function () {\n\treturn !!document.createElement('canvas').getContext;\n}());\n\nL.canvas = function (options) {\n\treturn L.Browser.canvas ? new L.Canvas(options) : null;\n};\n\nL.Polyline.prototype._containsPoint = function (p, closed) {\n\tvar i, j, k, len, len2, part,\n\t    w = this._clickTolerance();\n\n\tif (!this._pxBounds.contains(p)) { return false; }\n\n\t// hit detection for polylines\n\tfor (i = 0, len = this._parts.length; i < len; i++) {\n\t\tpart = this._parts[i];\n\n\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n\t\t\tif (!closed && (j === 0)) { continue; }\n\n\t\t\tif (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n};\n\nL.Polygon.prototype._containsPoint = function (p) {\n\tvar inside = false,\n\t    part, p1, p2, i, j, k, len, len2;\n\n\tif (!this._pxBounds.contains(p)) { return false; }\n\n\t// ray casting algorithm for detecting if point is in polygon\n\tfor (i = 0, len = this._parts.length; i < len; i++) {\n\t\tpart = this._parts[i];\n\n\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n\t\t\tp1 = part[j];\n\t\t\tp2 = part[k];\n\n\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\n\t\t\t\tinside = !inside;\n\t\t\t}\n\t\t}\n\t}\n\n\t// also check if it's on polygon stroke\n\treturn inside || L.Polyline.prototype._containsPoint.call(this, p, true);\n};\n\nL.CircleMarker.prototype._containsPoint = function (p) {\n\treturn p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n};\n\n\n\n/*\r\n * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\r\n */\r\n\r\nL.GeoJSON = L.FeatureGroup.extend({\r\n\r\n\tinitialize: function (geojson, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\r\n\t\tif (geojson) {\r\n\t\t\tthis.addData(geojson);\r\n\t\t}\r\n\t},\r\n\r\n\taddData: function (geojson) {\r\n\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\r\n\t\t    i, len, feature;\r\n\r\n\t\tif (features) {\r\n\t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n\t\t\t\t// only add this if geometry or geometries are set and not null\r\n\t\t\t\tfeature = features[i];\r\n\t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n\t\t\t\t\tthis.addData(feature);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.filter && !options.filter(geojson)) { return this; }\r\n\r\n\t\tvar layer = L.GeoJSON.geometryToLayer(geojson, options);\r\n\t\tif (!layer) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\r\n\r\n\t\tlayer.defaultOptions = layer.options;\r\n\t\tthis.resetStyle(layer);\r\n\r\n\t\tif (options.onEachFeature) {\r\n\t\t\toptions.onEachFeature(geojson, layer);\r\n\t\t}\r\n\r\n\t\treturn this.addLayer(layer);\r\n\t},\r\n\r\n\tresetStyle: function (layer) {\r\n\t\t// reset any custom styles\r\n\t\tlayer.options = layer.defaultOptions;\r\n\t\tthis._setLayerStyle(layer, this.options.style);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\treturn this.eachLayer(function (layer) {\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}, this);\r\n\t},\r\n\r\n\t_setLayerStyle: function (layer, style) {\r\n\t\tif (typeof style === 'function') {\r\n\t\t\tstyle = style(layer.feature);\r\n\t\t}\r\n\t\tif (layer.setStyle) {\r\n\t\t\tlayer.setStyle(style);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.extend(L.GeoJSON, {\r\n\tgeometryToLayer: function (geojson, options) {\r\n\r\n\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n\t\t    coords = geometry ? geometry.coordinates : null,\r\n\t\t    layers = [],\r\n\t\t    pointToLayer = options && options.pointToLayer,\r\n\t\t    coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,\r\n\t\t    latlng, latlngs, i, len;\r\n\r\n\t\tif (!coords && !geometry) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tswitch (geometry.type) {\r\n\t\tcase 'Point':\r\n\t\t\tlatlng = coordsToLatLng(coords);\r\n\t\t\treturn pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\r\n\r\n\t\tcase 'MultiPoint':\r\n\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\t\tlatlng = coordsToLatLng(coords[i]);\r\n\t\t\t\tlayers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tcase 'LineString':\r\n\t\tcase 'MultiLineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, coordsToLatLng);\r\n\t\t\treturn new L.Polyline(latlngs, options);\r\n\r\n\t\tcase 'Polygon':\r\n\t\tcase 'MultiPolygon':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);\r\n\t\t\treturn new L.Polygon(latlngs, options);\r\n\r\n\t\tcase 'GeometryCollection':\r\n\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n\t\t\t\tvar layer = this.geometryToLayer({\r\n\t\t\t\t\tgeometry: geometry.geometries[i],\r\n\t\t\t\t\ttype: 'Feature',\r\n\t\t\t\t\tproperties: geojson.properties\r\n\t\t\t\t}, options);\r\n\r\n\t\t\t\tif (layer) {\r\n\t\t\t\t\tlayers.push(layer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t}\r\n\t},\r\n\r\n\tcoordsToLatLng: function (coords) {\r\n\t\treturn new L.LatLng(coords[1], coords[0], coords[2]);\r\n\t},\r\n\r\n\tcoordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {\r\n\t\tvar latlngs = [];\r\n\r\n\t\tfor (var i = 0, len = coords.length, latlng; i < len; i++) {\r\n\t\t\tlatlng = levelsDeep ?\r\n\t\t\t        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :\r\n\t\t\t        (coordsToLatLng || this.coordsToLatLng)(coords[i]);\r\n\r\n\t\t\tlatlngs.push(latlng);\r\n\t\t}\r\n\r\n\t\treturn latlngs;\r\n\t},\r\n\r\n\tlatLngToCoords: function (latlng) {\r\n\t\treturn latlng.alt !== undefined ?\r\n\t\t\t\t[latlng.lng, latlng.lat, latlng.alt] :\r\n\t\t\t\t[latlng.lng, latlng.lat];\r\n\t},\r\n\r\n\tlatLngsToCoords: function (latlngs, levelsDeep, closed) {\r\n\t\tvar coords = [];\r\n\r\n\t\tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n\t\t\tcoords.push(levelsDeep ?\r\n\t\t\t\tL.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) :\r\n\t\t\t\tL.GeoJSON.latLngToCoords(latlngs[i]));\r\n\t\t}\r\n\r\n\t\tif (!levelsDeep && closed) {\r\n\t\t\tcoords.push(coords[0]);\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tgetFeature: function (layer, newGeometry) {\r\n\t\treturn layer.feature ?\r\n\t\t\t\tL.extend({}, layer.feature, {geometry: newGeometry}) :\r\n\t\t\t\tL.GeoJSON.asFeature(newGeometry);\r\n\t},\r\n\r\n\tasFeature: function (geoJSON) {\r\n\t\tif (geoJSON.type === 'Feature') {\r\n\t\t\treturn geoJSON;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: 'Feature',\r\n\t\t\tproperties: {},\r\n\t\t\tgeometry: geoJSON\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar PointToGeoJSON = {\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Point',\r\n\t\t\tcoordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\r\n\t\t});\r\n\t}\r\n};\r\n\r\nL.Marker.include(PointToGeoJSON);\r\nL.Circle.include(PointToGeoJSON);\r\nL.CircleMarker.include(PointToGeoJSON);\r\n\r\nL.Polyline.prototype.toGeoJSON = function () {\r\n\tvar multi = !L.Polyline._flat(this._latlngs);\r\n\r\n\tvar coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);\r\n\r\n\treturn L.GeoJSON.getFeature(this, {\r\n\t\ttype: (multi ? 'Multi' : '') + 'LineString',\r\n\t\tcoordinates: coords\r\n\t});\r\n};\r\n\r\nL.Polygon.prototype.toGeoJSON = function () {\r\n\tvar holes = !L.Polyline._flat(this._latlngs),\r\n\t    multi = holes && !L.Polyline._flat(this._latlngs[0]);\r\n\r\n\tvar coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);\r\n\r\n\tif (!holes) {\r\n\t\tcoords = [coords];\r\n\t}\r\n\r\n\treturn L.GeoJSON.getFeature(this, {\r\n\t\ttype: (multi ? 'Multi' : '') + 'Polygon',\r\n\t\tcoordinates: coords\r\n\t});\r\n};\r\n\r\n\r\nL.LayerGroup.include({\r\n\ttoMultiPoint: function () {\r\n\t\tvar coords = [];\r\n\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tcoords.push(layer.toGeoJSON().geometry.coordinates);\r\n\t\t});\r\n\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'MultiPoint',\r\n\t\t\tcoordinates: coords\r\n\t\t});\r\n\t},\r\n\r\n\ttoGeoJSON: function () {\r\n\r\n\t\tvar type = this.feature && this.feature.geometry && this.feature.geometry.type;\r\n\r\n\t\tif (type === 'MultiPoint') {\r\n\t\t\treturn this.toMultiPoint();\r\n\t\t}\r\n\r\n\t\tvar isGeometryCollection = type === 'GeometryCollection',\r\n\t\t    jsons = [];\r\n\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tif (layer.toGeoJSON) {\r\n\t\t\t\tvar json = layer.toGeoJSON();\r\n\t\t\t\tjsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif (isGeometryCollection) {\r\n\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\tgeometries: jsons,\r\n\t\t\t\ttype: 'GeometryCollection'\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: 'FeatureCollection',\r\n\t\t\tfeatures: jsons\r\n\t\t};\r\n\t}\r\n});\r\n\r\nL.geoJson = function (geojson, options) {\r\n\treturn new L.GeoJSON(geojson, options);\r\n};\r\n\n\n\n/*\r\n * L.DomEvent contains functions for working with DOM events.\r\n * Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\r\n */\r\n\r\nvar eventsKey = '_leaflet_events';\r\n\r\nL.DomEvent = {\r\n\r\n\ton: function (obj, types, fn, context) {\r\n\r\n\t\tif (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\tthis._on(obj, type, types[type], fn);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\tthis._on(obj, types[i], fn, context);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\toff: function (obj, types, fn, context) {\r\n\r\n\t\tif (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\tthis._off(obj, type, types[type], fn);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\tthis._off(obj, types[i], fn, context);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_on: function (obj, type, fn, context) {\r\n\t\tvar id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : '');\r\n\r\n\t\tif (obj[eventsKey] && obj[eventsKey][id]) { return this; }\r\n\r\n\t\tvar handler = function (e) {\r\n\t\t\treturn fn.call(context || obj, e || window.event);\r\n\t\t};\r\n\r\n\t\tvar originalHandler = handler;\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\tthis.addPointerListener(obj, type, handler, id);\r\n\r\n\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {\r\n\t\t\tthis.addDoubleTapListener(obj, handler, id);\r\n\r\n\t\t} else if ('addEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.addEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\te = e || window.event;\r\n\t\t\t\t\tif (L.DomEvent._isExternalTarget(obj, e)) {\r\n\t\t\t\t\t\toriginalHandler(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tobj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tif (type === 'click' && L.Browser.android) {\r\n\t\t\t\t\thandler = function (e) {\r\n\t\t\t\t\t\treturn L.DomEvent._filterClick(e, originalHandler);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t}\r\n\r\n\t\t} else if ('attachEvent' in obj) {\r\n\t\t\tobj.attachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[eventsKey] = obj[eventsKey] || {};\r\n\t\tobj[eventsKey][id] = handler;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_off: function (obj, type, fn, context) {\r\n\r\n\t\tvar id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : ''),\r\n\t\t    handler = obj[eventsKey] && obj[eventsKey][id];\r\n\r\n\t\tif (!handler) { return this; }\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\tthis.removePointerListener(obj, type, id);\r\n\r\n\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {\r\n\t\t\tthis.removeDoubleTapListener(obj, id);\r\n\r\n\t\t} else if ('removeEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.removeEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tobj.removeEventListener(\r\n\t\t\t\t\ttype === 'mouseenter' ? 'mouseover' :\r\n\t\t\t\t\ttype === 'mouseleave' ? 'mouseout' : type, handler, false);\r\n\t\t\t}\r\n\r\n\t\t} else if ('detachEvent' in obj) {\r\n\t\t\tobj.detachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[eventsKey][id] = null;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopPropagation: function (e) {\r\n\r\n\t\tif (e.stopPropagation) {\r\n\t\t\te.stopPropagation();\r\n\t\t} else if (e.originalEvent) {  // In case of Leaflet event.\r\n\t\t\te.originalEvent._stopped = true;\r\n\t\t} else {\r\n\t\t\te.cancelBubble = true;\r\n\t\t}\r\n\t\tL.DomEvent._skipped(e);\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdisableScrollPropagation: function (el) {\r\n\t\treturn L.DomEvent.on(el, 'mousewheel MozMousePixelScroll', L.DomEvent.stopPropagation);\r\n\t},\r\n\r\n\tdisableClickPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tL.DomEvent.on(el, L.Draggable.START.join(' '), stop);\r\n\r\n\t\treturn L.DomEvent.on(el, {\r\n\t\t\tclick: L.DomEvent._fakeStop,\r\n\t\t\tdblclick: stop\r\n\t\t});\r\n\t},\r\n\r\n\tpreventDefault: function (e) {\r\n\r\n\t\tif (e.preventDefault) {\r\n\t\t\te.preventDefault();\r\n\t\t} else {\r\n\t\t\te.returnValue = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstop: function (e) {\r\n\t\treturn L.DomEvent\r\n\t\t\t.preventDefault(e)\r\n\t\t\t.stopPropagation(e);\r\n\t},\r\n\r\n\tgetMousePosition: function (e, container) {\r\n\t\tif (!container) {\r\n\t\t\treturn new L.Point(e.clientX, e.clientY);\r\n\t\t}\r\n\r\n\t\tvar rect = container.getBoundingClientRect();\r\n\r\n\t\treturn new L.Point(\r\n\t\t\te.clientX - rect.left - container.clientLeft,\r\n\t\t\te.clientY - rect.top - container.clientTop);\r\n\t},\r\n\r\n\tgetWheelDelta: function (e) {\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif (e.wheelDelta) {\r\n\t\t\tdelta = e.wheelDelta / 120;\r\n\t\t}\r\n\t\tif (e.detail) {\r\n\t\t\tdelta = -e.detail / 3;\r\n\t\t}\r\n\t\treturn delta;\r\n\t},\r\n\r\n\t_skipEvents: {},\r\n\r\n\t_fakeStop: function (e) {\r\n\t\t// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\r\n\t\tL.DomEvent._skipEvents[e.type] = true;\r\n\t},\r\n\r\n\t_skipped: function (e) {\r\n\t\tvar skipped = this._skipEvents[e.type];\r\n\t\t// reset when checking, as it's only used in map container and propagates outside of the map\r\n\t\tthis._skipEvents[e.type] = false;\r\n\t\treturn skipped;\r\n\t},\r\n\r\n\t// check if element really left/entered the event target (for mouseenter/mouseleave)\r\n\t_isExternalTarget: function (el, e) {\r\n\r\n\t\tvar related = e.relatedTarget;\r\n\r\n\t\tif (!related) { return true; }\r\n\r\n\t\ttry {\r\n\t\t\twhile (related && (related !== el)) {\r\n\t\t\t\trelated = related.parentNode;\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn (related !== el);\r\n\t},\r\n\r\n\t// this is a horrible workaround for a bug in Android where a single touch triggers two click events\r\n\t_filterClick: function (e, handler) {\r\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t    elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t// on the same event should be triggered far faster;\r\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\r\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tL.DomEvent._lastClick = timeStamp;\r\n\r\n\t\thandler(e);\r\n\t}\r\n};\r\n\r\nL.DomEvent.addListener = L.DomEvent.on;\r\nL.DomEvent.removeListener = L.DomEvent.off;\r\n\n\n\n/*\r\n * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\r\n */\r\n\r\nL.Draggable = L.Evented.extend({\r\n\r\n\tstatics: {\r\n\t\tSTART: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\r\n\t\tEND: {\r\n\t\t\tmousedown: 'mouseup',\r\n\t\t\ttouchstart: 'touchend',\r\n\t\t\tpointerdown: 'touchend',\r\n\t\t\tMSPointerDown: 'touchend'\r\n\t\t},\r\n\t\tMOVE: {\r\n\t\t\tmousedown: 'mousemove',\r\n\t\t\ttouchstart: 'touchmove',\r\n\t\t\tpointerdown: 'touchmove',\r\n\t\t\tMSPointerDown: 'touchmove'\r\n\t\t}\r\n\t},\r\n\r\n\tinitialize: function (element, dragStartTarget, preventOutline) {\r\n\t\tthis._element = element;\r\n\t\tthis._dragStartTarget = dragStartTarget || element;\r\n\t\tthis._preventOutline = preventOutline;\r\n\t},\r\n\r\n\tenable: function () {\r\n\t\tif (this._enabled) { return; }\r\n\r\n\t\tL.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);\r\n\r\n\t\tthis._enabled = true;\r\n\t},\r\n\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) { return; }\r\n\r\n\t\tL.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);\r\n\r\n\t\tthis._enabled = false;\r\n\t\tthis._moved = false;\r\n\t},\r\n\r\n\t_onDown: function (e) {\r\n\t\tthis._moved = false;\r\n\r\n\t\tif (L.DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) { return; }\r\n\r\n\t\tif (L.Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches) || !this._enabled) { return; }\r\n\t\tL.Draggable._dragging = true;  // Prevent dragging multiple objects at once.\r\n\r\n\t\tif (this._preventOutline) {\r\n\t\t\tL.DomUtil.preventOutline(this._element);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.disableImageDrag();\r\n\t\tL.DomUtil.disableTextSelection();\r\n\r\n\t\tif (this._moving) { return; }\r\n\r\n\t\tthis.fire('down');\r\n\r\n\t\tvar first = e.touches ? e.touches[0] : e;\r\n\r\n\t\tthis._startPoint = new L.Point(first.clientX, first.clientY);\r\n\t\tthis._startPos = this._newPos = L.DomUtil.getPosition(this._element);\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)\r\n\t\t    .on(document, L.Draggable.END[e.type], this._onUp, this);\r\n\t},\r\n\r\n\t_onMove: function (e) {\r\n\t\tif (e.touches && e.touches.length > 1) {\r\n\t\t\tthis._moved = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n\t\t    newPoint = new L.Point(first.clientX, first.clientY),\r\n\t\t    offset = newPoint.subtract(this._startPoint);\r\n\r\n\t\tif (!offset.x && !offset.y) { return; }\r\n\t\tif (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }\r\n\r\n\t\tL.DomEvent.preventDefault(e);\r\n\r\n\t\tif (!this._moved) {\r\n\t\t\tthis.fire('dragstart');\r\n\r\n\t\t\tthis._moved = true;\r\n\t\t\tthis._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\r\n\r\n\t\t\tL.DomUtil.addClass(document.body, 'leaflet-dragging');\r\n\r\n\t\t\tthis._lastTarget = e.target || e.srcElement;\r\n\t\t\tL.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t}\r\n\r\n\t\tthis._newPos = this._startPos.add(offset);\r\n\t\tthis._moving = true;\r\n\r\n\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\t\tthis._lastEvent = e;\r\n\t\tthis._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true);\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tvar e = {originalEvent: this._lastEvent};\r\n\t\tthis.fire('predrag', e);\r\n\t\tL.DomUtil.setPosition(this._element, this._newPos);\r\n\t\tthis.fire('drag', e);\r\n\t},\r\n\r\n\t_onUp: function () {\r\n\t\tL.DomUtil.removeClass(document.body, 'leaflet-dragging');\r\n\r\n\t\tif (this._lastTarget) {\r\n\t\t\tL.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t\tthis._lastTarget = null;\r\n\t\t}\r\n\r\n\t\tfor (var i in L.Draggable.MOVE) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(document, L.Draggable.MOVE[i], this._onMove, this)\r\n\t\t\t    .off(document, L.Draggable.END[i], this._onUp, this);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.enableImageDrag();\r\n\t\tL.DomUtil.enableTextSelection();\r\n\r\n\t\tif (this._moved && this._moving) {\r\n\t\t\t// ensure drag is not fired after dragend\r\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\r\n\t\t\tthis.fire('dragend', {\r\n\t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._moving = false;\r\n\t\tL.Draggable._dragging = false;\r\n\t}\r\n});\r\n\n\n\n/*\n\tL.Handler is a base class for handler classes that are used internally to inject\n\tinteraction features like dragging to classes like Map and Marker.\n*/\n\nL.Handler = L.Class.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t},\n\n\tenable: function () {\n\t\tif (this._enabled) { return; }\n\n\t\tthis._enabled = true;\n\t\tthis.addHooks();\n\t},\n\n\tdisable: function () {\n\t\tif (!this._enabled) { return; }\n\n\t\tthis._enabled = false;\n\t\tthis.removeHooks();\n\t},\n\n\tenabled: function () {\n\t\treturn !!this._enabled;\n\t}\n});\n\n\n\n/*\n * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdragging: true,\n\n\tinertia: !L.Browser.android23,\n\tinertiaDeceleration: 3400, // px/s^2\n\tinertiaMaxSpeed: Infinity, // px/s\n\teaseLinearity: 0.2,\n\n\t// TODO refactor, move to CRS\n\tworldCopyJump: false\n});\n\nL.Map.Drag = L.Handler.extend({\n\taddHooks: function () {\n\t\tif (!this._draggable) {\n\t\t\tvar map = this._map;\n\n\t\t\tthis._draggable = new L.Draggable(map._mapPane, map._container);\n\n\t\t\tthis._draggable.on({\n\t\t\t\tdown: this._onDown,\n\t\t\t\tdragstart: this._onDragStart,\n\t\t\t\tdrag: this._onDrag,\n\t\t\t\tdragend: this._onDragEnd\n\t\t\t}, this);\n\n\t\t\tthis._draggable.on('predrag', this._onPreDragLimit, this);\n\t\t\tif (map.options.worldCopyJump) {\n\t\t\t\tthis._draggable.on('predrag', this._onPreDragWrap, this);\n\t\t\t\tmap.on('zoomend', this._onZoomEnd, this);\n\n\t\t\t\tmap.whenReady(this._onZoomEnd, this);\n\t\t\t}\n\t\t}\n\t\tL.DomUtil.addClass(this._map._container, 'leaflet-grab');\n\t\tthis._draggable.enable();\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomUtil.removeClass(this._map._container, 'leaflet-grab');\n\t\tthis._draggable.disable();\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDown: function () {\n\t\tthis._map.stop();\n\t},\n\n\t_onDragStart: function () {\n\t\tvar map = this._map;\n\n\t\tif (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n\t\t\tvar bounds = L.latLngBounds(this._map.options.maxBounds);\n\n\t\t\tthis._offsetLimit = L.bounds(\n\t\t\t\tthis._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),\n\t\t\t\tthis._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)\n\t\t\t\t\t.add(this._map.getSize()));\n\n\t\t\tthis._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n\t\t} else {\n\t\t\tthis._offsetLimit = null;\n\t\t}\n\n\t\tmap\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\n\t\tif (map.options.inertia) {\n\t\t\tthis._positions = [];\n\t\t\tthis._times = [];\n\t\t}\n\t},\n\n\t_onDrag: function (e) {\n\t\tif (this._map.options.inertia) {\n\t\t\tvar time = this._lastTime = +new Date(),\n\t\t\t    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n\n\t\t\tthis._positions.push(pos);\n\t\t\tthis._times.push(time);\n\n\t\t\tif (time - this._times[0] > 50) {\n\t\t\t\tthis._positions.shift();\n\t\t\t\tthis._times.shift();\n\t\t\t}\n\t\t}\n\n\t\tthis._map\n\t\t    .fire('move', e)\n\t\t    .fire('drag', e);\n\t},\n\n\t_onZoomEnd: function () {\n\t\tvar pxCenter = this._map.getSize().divideBy(2),\n\t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n\t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n\t\tthis._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n\t},\n\n\t_viscousLimit: function (value, threshold) {\n\t\treturn value - (value - threshold) * this._viscosity;\n\t},\n\n\t_onPreDragLimit: function () {\n\t\tif (!this._viscosity || !this._offsetLimit) { return; }\n\n\t\tvar offset = this._draggable._newPos.subtract(this._draggable._startPos);\n\n\t\tvar limit = this._offsetLimit;\n\t\tif (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }\n\t\tif (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }\n\t\tif (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }\n\t\tif (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }\n\n\t\tthis._draggable._newPos = this._draggable._startPos.add(offset);\n\t},\n\n\t_onPreDragWrap: function () {\n\t\t// TODO refactor to be able to adjust map pane position after zoom\n\t\tvar worldWidth = this._worldWidth,\n\t\t    halfWidth = Math.round(worldWidth / 2),\n\t\t    dx = this._initialWorldOffset,\n\t\t    x = this._draggable._newPos.x,\n\t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n\t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n\t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n\t\tthis._draggable._absPos = this._draggable._newPos.clone();\n\t\tthis._draggable._newPos.x = newX;\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tvar map = this._map,\n\t\t    options = map.options,\n\n\t\t    noInertia = !options.inertia || this._times.length < 2;\n\n\t\tmap.fire('dragend', e);\n\n\t\tif (noInertia) {\n\t\t\tmap.fire('moveend');\n\n\t\t} else {\n\n\t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n\t\t\t    duration = (this._lastTime - this._times[0]) / 1000,\n\t\t\t    ease = options.easeLinearity,\n\n\t\t\t    speedVector = direction.multiplyBy(ease / duration),\n\t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n\t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n\t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n\t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n\t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n\t\t\tif (!offset.x && !offset.y) {\n\t\t\t\tmap.fire('moveend');\n\n\t\t\t} else {\n\t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n\t\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\t\tmap.panBy(offset, {\n\t\t\t\t\t\tduration: decelerationDuration,\n\t\t\t\t\t\teaseLinearity: ease,\n\t\t\t\t\t\tnoMoveStart: true,\n\t\t\t\t\t\tanimate: true\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\n\n\n/*\n * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdoubleClickZoom: true\n});\n\nL.Map.DoubleClickZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tthis._map.on('dblclick', this._onDoubleClick, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._map.off('dblclick', this._onDoubleClick, this);\n\t},\n\n\t_onDoubleClick: function (e) {\n\t\tvar map = this._map,\n\t\t    oldZoom = map.getZoom(),\n\t\t    zoom = e.originalEvent.shiftKey ? Math.ceil(oldZoom) - 1 : Math.floor(oldZoom) + 1;\n\n\t\tif (map.options.doubleClickZoom === 'center') {\n\t\t\tmap.setZoom(zoom);\n\t\t} else {\n\t\t\tmap.setZoomAround(e.containerPoint, zoom);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\n\n\n/*\n * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n */\n\nL.Map.mergeOptions({\n\tscrollWheelZoom: true,\n\twheelDebounceTime: 40\n});\n\nL.Map.ScrollWheelZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, {\n\t\t\tmousewheel: this._onWheelScroll,\n\t\t\tMozMousePixelScroll: L.DomEvent.preventDefault\n\t\t}, this);\n\n\t\tthis._delta = 0;\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, {\n\t\t\tmousewheel: this._onWheelScroll,\n\t\t\tMozMousePixelScroll: L.DomEvent.preventDefault\n\t\t}, this);\n\t},\n\n\t_onWheelScroll: function (e) {\n\t\tvar delta = L.DomEvent.getWheelDelta(e);\n\t\tvar debounce = this._map.options.wheelDebounceTime;\n\n\t\tthis._delta += delta;\n\t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n\t\tif (!this._startTime) {\n\t\t\tthis._startTime = +new Date();\n\t\t}\n\n\t\tvar left = Math.max(debounce - (+new Date() - this._startTime), 0);\n\n\t\tclearTimeout(this._timer);\n\t\tthis._timer = setTimeout(L.bind(this._performZoom, this), left);\n\n\t\tL.DomEvent.stop(e);\n\t},\n\n\t_performZoom: function () {\n\t\tvar map = this._map,\n\t\t    delta = this._delta,\n\t\t    zoom = map.getZoom();\n\n\t\tmap.stop(); // stop panning and fly animations if any\n\n\t\tdelta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\t\tdelta = Math.max(Math.min(delta, 4), -4);\n\t\tdelta = map._limitZoom(zoom + delta) - zoom;\n\n\t\tthis._delta = 0;\n\t\tthis._startTime = null;\n\n\t\tif (!delta) { return; }\n\n\t\tif (map.options.scrollWheelZoom === 'center') {\n\t\t\tmap.setZoom(zoom + delta);\n\t\t} else {\n\t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\n\n\n/*\r\n * Extends the event handling code with double tap support for mobile browsers.\r\n */\r\n\r\nL.extend(L.DomEvent, {\r\n\r\n\t_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\r\n\t_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\r\n\r\n\t// inspired by Zepto touch code by Thomas Fuchs\r\n\taddDoubleTapListener: function (obj, handler, id) {\r\n\t\tvar last, touch,\r\n\t\t    doubleTap = false,\r\n\t\t    delay = 250;\r\n\r\n\t\tfunction onTouchStart(e) {\r\n\t\t\tvar count;\r\n\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\tcount = L.DomEvent._pointersCount;\r\n\t\t\t} else {\r\n\t\t\t\tcount = e.touches.length;\r\n\t\t\t}\r\n\r\n\t\t\tif (count > 1) { return; }\r\n\r\n\t\t\tvar now = Date.now(),\r\n\t\t\t    delta = now - (last || now);\r\n\r\n\t\t\ttouch = e.touches ? e.touches[0] : e;\r\n\t\t\tdoubleTap = (delta > 0 && delta <= delay);\r\n\t\t\tlast = now;\r\n\t\t}\r\n\r\n\t\tfunction onTouchEnd() {\r\n\t\t\tif (doubleTap && !touch.cancelBubble) {\r\n\t\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\t\t// work around .type being readonly with MSPointer* events\r\n\t\t\t\t\tvar newTouch = {},\r\n\t\t\t\t\t    prop, i;\r\n\r\n\t\t\t\t\tfor (i in touch) {\r\n\t\t\t\t\t\tprop = touch[i];\r\n\t\t\t\t\t\tnewTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttouch = newTouch;\r\n\t\t\t\t}\r\n\t\t\t\ttouch.type = 'dblclick';\r\n\t\t\t\thandler(touch);\r\n\t\t\t\tlast = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar pre = '_leaflet_',\r\n\t\t    touchstart = this._touchstart,\r\n\t\t    touchend = this._touchend;\r\n\r\n\t\tobj[pre + touchstart + id] = onTouchStart;\r\n\t\tobj[pre + touchend + id] = onTouchEnd;\r\n\r\n\t\tobj.addEventListener(touchstart, onTouchStart, false);\r\n\t\tobj.addEventListener(touchend, onTouchEnd, false);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveDoubleTapListener: function (obj, id) {\r\n\t\tvar pre = '_leaflet_',\r\n\t\t    touchend = obj[pre + this._touchend + id];\r\n\r\n\t\tobj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\r\n\t\tobj.removeEventListener(this._touchend, touchend, false);\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n\n/*\n * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n */\n\nL.extend(L.DomEvent, {\n\n\tPOINTER_DOWN:   L.Browser.msPointer ? 'MSPointerDown'   : 'pointerdown',\n\tPOINTER_MOVE:   L.Browser.msPointer ? 'MSPointerMove'   : 'pointermove',\n\tPOINTER_UP:     L.Browser.msPointer ? 'MSPointerUp'     : 'pointerup',\n\tPOINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n\n\t_pointers: {},\n\t_pointersCount: 0,\n\n\t// Provides a touch events wrapper for (ms)pointer events.\n\t// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n\taddPointerListener: function (obj, type, handler, id) {\n\n\t\tif (type === 'touchstart') {\n\t\t\tthis._addPointerStart(obj, handler, id);\n\n\t\t} else if (type === 'touchmove') {\n\t\t\tthis._addPointerMove(obj, handler, id);\n\n\t\t} else if (type === 'touchend') {\n\t\t\tthis._addPointerEnd(obj, handler, id);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremovePointerListener: function (obj, type, id) {\n\t\tvar handler = obj['_leaflet_' + type + id];\n\n\t\tif (type === 'touchstart') {\n\t\t\tobj.removeEventListener(this.POINTER_DOWN, handler, false);\n\n\t\t} else if (type === 'touchmove') {\n\t\t\tobj.removeEventListener(this.POINTER_MOVE, handler, false);\n\n\t\t} else if (type === 'touchend') {\n\t\t\tobj.removeEventListener(this.POINTER_UP, handler, false);\n\t\t\tobj.removeEventListener(this.POINTER_CANCEL, handler, false);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_addPointerStart: function (obj, handler, id) {\n\t\tvar onDown = L.bind(function (e) {\n\t\t\tif (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n\t\t\t\tL.DomEvent.preventDefault(e);\n\t\t\t}\n\n\t\t\tthis._handlePointer(e, handler);\n\t\t}, this);\n\n\t\tobj['_leaflet_touchstart' + id] = onDown;\n\t\tobj.addEventListener(this.POINTER_DOWN, onDown, false);\n\n\t\t// need to keep track of what pointers and how many are active to provide e.touches emulation\n\t\tif (!this._pointerDocListener) {\n\t\t\tvar pointerUp = L.bind(this._globalPointerUp, this);\n\n\t\t\t// we listen documentElement as any drags that end by moving the touch off the screen get fired there\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_DOWN, L.bind(this._globalPointerDown, this), true);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_MOVE, L.bind(this._globalPointerMove, this), true);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_UP, pointerUp, true);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_CANCEL, pointerUp, true);\n\n\t\t\tthis._pointerDocListener = true;\n\t\t}\n\t},\n\n\t_globalPointerDown: function (e) {\n\t\tthis._pointers[e.pointerId] = e;\n\t\tthis._pointersCount++;\n\t},\n\n\t_globalPointerMove: function (e) {\n\t\tif (this._pointers[e.pointerId]) {\n\t\t\tthis._pointers[e.pointerId] = e;\n\t\t}\n\t},\n\n\t_globalPointerUp: function (e) {\n\t\tdelete this._pointers[e.pointerId];\n\t\tthis._pointersCount--;\n\t},\n\n\t_handlePointer: function (e, handler) {\n\t\te.touches = [];\n\t\tfor (var i in this._pointers) {\n\t\t\te.touches.push(this._pointers[i]);\n\t\t}\n\t\te.changedTouches = [e];\n\n\t\thandler(e);\n\t},\n\n\t_addPointerMove: function (obj, handler, id) {\n\t\tvar onMove = L.bind(function (e) {\n\t\t\t// don't fire touch moves when mouse isn't down\n\t\t\tif ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }\n\n\t\t\tthis._handlePointer(e, handler);\n\t\t}, this);\n\n\t\tobj['_leaflet_touchmove' + id] = onMove;\n\t\tobj.addEventListener(this.POINTER_MOVE, onMove, false);\n\t},\n\n\t_addPointerEnd: function (obj, handler, id) {\n\t\tvar onUp = L.bind(function (e) {\n\t\t\tthis._handlePointer(e, handler);\n\t\t}, this);\n\n\t\tobj['_leaflet_touchend' + id] = onUp;\n\t\tobj.addEventListener(this.POINTER_UP, onUp, false);\n\t\tobj.addEventListener(this.POINTER_CANCEL, onUp, false);\n\t}\n});\n\n\n\n/*\n * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n */\n\nL.Map.mergeOptions({\n\ttouchZoom: L.Browser.touch && !L.Browser.android23,\n\tbounceAtZoomLimits: true\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToContainerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToContainerPoint(e.touches[1]);\n\n\t\tthis._centerPoint = map.getSize()._divideBy(2);\n\t\tthis._startLatLng = map.containerPointToLatLng(this._centerPoint);\n\t\tif (map.options.touchZoom !== 'center') {\n\t\t\tthis._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n\t\t}\n\n\t\tthis._startDist = p1.distanceTo(p2);\n\t\tthis._startZoom = map.getZoom();\n\n\t\tthis._moved = false;\n\t\tthis._zooming = true;\n\n\t\tmap.stop();\n\n\t\tL.DomEvent\n\t\t    .on(document, 'touchmove', this._onTouchMove, this)\n\t\t    .on(document, 'touchend', this._onTouchEnd, this);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n\t\tvar map = this._map,\n\t\t    p1 = map.mouseEventToContainerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToContainerPoint(e.touches[1]),\n\t\t    scale = p1.distanceTo(p2) / this._startDist;\n\n\n\t\tthis._zoom = map.getScaleZoom(scale, this._startZoom);\n\n\t\tif (map.options.touchZoom === 'center') {\n\t\t\tthis._center = this._startLatLng;\n\t\t\tif (scale === 1) { return; }\n\t\t} else {\n\t\t\t// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n\t\t\tvar delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n\t\t\tif (scale === 1 && delta.x === 0 && delta.y === 0) { return; }\n\t\t\tthis._center = map.unproject(map.project(this._pinchStartLatLng).subtract(delta));\n\t\t}\n\n\t\tif (!map.options.bounceAtZoomLimits) {\n\t\t\tif ((this._zoom <= map.getMinZoom() && scale < 1) ||\n\t\t        (this._zoom >= map.getMaxZoom() && scale > 1)) { return; }\n\t\t}\n\n\t\tif (!this._moved) {\n\t\t\tmap._moveStart(true);\n\t\t\tthis._moved = true;\n\t\t}\n\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\tvar moveFn = L.bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});\n\t\tthis._animRequest = L.Util.requestAnimFrame(moveFn, this, true);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_onTouchEnd: function () {\n\t\tif (!this._moved || !this._zooming) {\n\t\t\tthis._zooming = false;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._zooming = false;\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\tL.DomEvent\n\t\t    .off(document, 'touchmove', this._onTouchMove)\n\t\t    .off(document, 'touchend', this._onTouchEnd);\n\n\t\tvar zoom = this._zoom;\n\t\tzoom = this._map._limitZoom(zoom - this._startZoom > 0 ? Math.ceil(zoom) : Math.floor(zoom));\n\n\n\t\tthis._map._animateZoom(this._center, zoom, true, true);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\n\n\n/*\n * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n */\n\nL.Map.mergeOptions({\n\ttap: true,\n\ttapTolerance: 15\n});\n\nL.Map.Tap = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\t_onDown: function (e) {\n\t\tif (!e.touches) { return; }\n\n\t\tL.DomEvent.preventDefault(e);\n\n\t\tthis._fireClick = true;\n\n\t\t// don't simulate click or track longpress if more than 1 touch\n\t\tif (e.touches.length > 1) {\n\t\t\tthis._fireClick = false;\n\t\t\tclearTimeout(this._holdTimeout);\n\t\t\treturn;\n\t\t}\n\n\t\tvar first = e.touches[0],\n\t\t    el = first.target;\n\n\t\tthis._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\n\t\t// if touching a link, highlight it\n\t\tif (el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\tL.DomUtil.addClass(el, 'leaflet-active');\n\t\t}\n\n\t\t// simulate long hold but setting a timeout\n\t\tthis._holdTimeout = setTimeout(L.bind(function () {\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._fireClick = false;\n\t\t\t\tthis._onUp();\n\t\t\t\tthis._simulateEvent('contextmenu', first);\n\t\t\t}\n\t\t}, this), 1000);\n\n\t\tthis._simulateEvent('mousedown', first);\n\n\t\tL.DomEvent.on(document, {\n\t\t\ttouchmove: this._onMove,\n\t\t\ttouchend: this._onUp\n\t\t}, this);\n\t},\n\n\t_onUp: function (e) {\n\t\tclearTimeout(this._holdTimeout);\n\n\t\tL.DomEvent.off(document, {\n\t\t\ttouchmove: this._onMove,\n\t\t\ttouchend: this._onUp\n\t\t}, this);\n\n\t\tif (this._fireClick && e && e.changedTouches) {\n\n\t\t\tvar first = e.changedTouches[0],\n\t\t\t    el = first.target;\n\n\t\t\tif (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\t\tL.DomUtil.removeClass(el, 'leaflet-active');\n\t\t\t}\n\n\t\t\tthis._simulateEvent('mouseup', first);\n\n\t\t\t// simulate click if the touch didn't move too much\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._simulateEvent('click', first);\n\t\t\t}\n\t\t}\n\t},\n\n\t_isTapValid: function () {\n\t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n\t},\n\n\t_onMove: function (e) {\n\t\tvar first = e.touches[0];\n\t\tthis._newPos = new L.Point(first.clientX, first.clientY);\n\t\tthis._simulateEvent('mousemove', first);\n\t},\n\n\t_simulateEvent: function (type, e) {\n\t\tvar simulatedEvent = document.createEvent('MouseEvents');\n\n\t\tsimulatedEvent._simulated = true;\n\t\te.target._simulatedClick = true;\n\n\t\tsimulatedEvent.initMouseEvent(\n\t\t        type, true, true, window, 1,\n\t\t        e.screenX, e.screenY,\n\t\t        e.clientX, e.clientY,\n\t\t        false, false, false, false, 0, null);\n\n\t\te.target.dispatchEvent(simulatedEvent);\n\t}\n});\n\nif (L.Browser.touch && !L.Browser.pointer) {\n\tL.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n}\n\n\n\n/*\n * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n  * (zoom to a selected bounding box), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tboxZoom: true\n});\n\nL.Map.BoxZoom = L.Handler.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._pane = map._panes.overlayPane;\n\t},\n\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);\n\t},\n\n\tmoved: function () {\n\t\treturn this._moved;\n\t},\n\n\t_resetState: function () {\n\t\tthis._moved = false;\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n\t\tthis._resetState();\n\n\t\tL.DomUtil.disableTextSelection();\n\t\tL.DomUtil.disableImageDrag();\n\n\t\tthis._startPoint = this._map.mouseEventToContainerPoint(e);\n\n\t\tL.DomEvent.on(document, {\n\t\t\tcontextmenu: L.DomEvent.stop,\n\t\t\tmousemove: this._onMouseMove,\n\t\t\tmouseup: this._onMouseUp,\n\t\t\tkeydown: this._onKeyDown\n\t\t}, this);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._moved) {\n\t\t\tthis._moved = true;\n\n\t\t\tthis._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._container);\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-crosshair');\n\n\t\t\tthis._map.fire('boxzoomstart');\n\t\t}\n\n\t\tthis._point = this._map.mouseEventToContainerPoint(e);\n\n\t\tvar bounds = new L.Bounds(this._point, this._startPoint),\n\t\t    size = bounds.getSize();\n\n\t\tL.DomUtil.setPosition(this._box, bounds.min);\n\n\t\tthis._box.style.width  = size.x + 'px';\n\t\tthis._box.style.height = size.y + 'px';\n\t},\n\n\t_finish: function () {\n\t\tif (this._moved) {\n\t\t\tL.DomUtil.remove(this._box);\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-crosshair');\n\t\t}\n\n\t\tL.DomUtil.enableTextSelection();\n\t\tL.DomUtil.enableImageDrag();\n\n\t\tL.DomEvent.off(document, {\n\t\t\tcontextmenu: L.DomEvent.stop,\n\t\t\tmousemove: this._onMouseMove,\n\t\t\tmouseup: this._onMouseUp,\n\t\t\tkeydown: this._onKeyDown\n\t\t}, this);\n\t},\n\n\t_onMouseUp: function (e) {\n\t\tif ((e.which !== 1) && (e.button !== 1)) { return; }\n\n\t\tthis._finish();\n\n\t\tif (!this._moved) { return; }\n\t\t// Postpone to next JS tick so internal click event handling\n\t\t// still see it as \"moved\".\n\t\tsetTimeout(L.bind(this._resetState, this), 0);\n\n\t\tvar bounds = new L.LatLngBounds(\n\t\t        this._map.containerPointToLatLng(this._startPoint),\n\t\t        this._map.containerPointToLatLng(this._point));\n\n\t\tthis._map\n\t\t\t.fitBounds(bounds)\n\t\t\t.fire('boxzoomend', {boxZoomBounds: bounds});\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tif (e.keyCode === 27) {\n\t\t\tthis._finish();\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\n\n\n/*\n * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tkeyboard: true,\n\tkeyboardPanOffset: 80,\n\tkeyboardZoomOffset: 1\n});\n\nL.Map.Keyboard = L.Handler.extend({\n\n\tkeyCodes: {\n\t\tleft:    [37],\n\t\tright:   [39],\n\t\tdown:    [40],\n\t\tup:      [38],\n\t\tzoomIn:  [187, 107, 61, 171],\n\t\tzoomOut: [189, 109, 54, 173]\n\t},\n\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\n\t\tthis._setPanOffset(map.options.keyboardPanOffset);\n\t\tthis._setZoomOffset(map.options.keyboardZoomOffset);\n\t},\n\n\taddHooks: function () {\n\t\tvar container = this._map._container;\n\n\t\t// make the container focusable by tabbing\n\t\tif (container.tabIndex <= 0) {\n\t\t\tcontainer.tabIndex = '0';\n\t\t}\n\n\t\tL.DomEvent.on(container, {\n\t\t\tfocus: this._onFocus,\n\t\t\tblur: this._onBlur,\n\t\t\tmousedown: this._onMouseDown\n\t\t}, this);\n\n\t\tthis._map.on({\n\t\t\tfocus: this._addHooks,\n\t\t\tblur: this._removeHooks\n\t\t}, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._removeHooks();\n\n\t\tL.DomEvent.off(this._map._container, {\n\t\t\tfocus: this._onFocus,\n\t\t\tblur: this._onBlur,\n\t\t\tmousedown: this._onMouseDown\n\t\t}, this);\n\n\t\tthis._map.off({\n\t\t\tfocus: this._addHooks,\n\t\t\tblur: this._removeHooks\n\t\t}, this);\n\t},\n\n\t_onMouseDown: function () {\n\t\tif (this._focused) { return; }\n\n\t\tvar body = document.body,\n\t\t    docEl = document.documentElement,\n\t\t    top = body.scrollTop || docEl.scrollTop,\n\t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n\t\tthis._map._container.focus();\n\n\t\twindow.scrollTo(left, top);\n\t},\n\n\t_onFocus: function () {\n\t\tthis._focused = true;\n\t\tthis._map.fire('focus');\n\t},\n\n\t_onBlur: function () {\n\t\tthis._focused = false;\n\t\tthis._map.fire('blur');\n\t},\n\n\t_setPanOffset: function (pan) {\n\t\tvar keys = this._panKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n\t\t\tkeys[codes.left[i]] = [-1 * pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n\t\t\tkeys[codes.right[i]] = [pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n\t\t\tkeys[codes.down[i]] = [0, pan];\n\t\t}\n\t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n\t\t\tkeys[codes.up[i]] = [0, -1 * pan];\n\t\t}\n\t},\n\n\t_setZoomOffset: function (zoom) {\n\t\tvar keys = this._zoomKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n\t\t\tkeys[codes.zoomIn[i]] = zoom;\n\t\t}\n\t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n\t\t\tkeys[codes.zoomOut[i]] = -zoom;\n\t\t}\n\t},\n\n\t_addHooks: function () {\n\t\tL.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_removeHooks: function () {\n\t\tL.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tif (e.altKey || e.ctrlKey || e.metaKey) { return; }\n\n\t\tvar key = e.keyCode,\n\t\t    map = this._map,\n\t\t    offset;\n\n\t\tif (key in this._panKeys) {\n\n\t\t\tif (map._panAnim && map._panAnim._inProgress) { return; }\n\n\t\t\toffset = this._panKeys[key];\n\t\t\tif (e.shiftKey) {\n\t\t\t\toffset = L.point(offset).multiplyBy(3);\n\t\t\t}\n\n\t\t\tmap.panBy(offset);\n\n\t\t\tif (map.options.maxBounds) {\n\t\t\t\tmap.panInsideBounds(map.options.maxBounds);\n\t\t\t}\n\n\t\t} else if (key in this._zoomKeys) {\n\t\t\tmap.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n\n\t\t} else if (key === 27) {\n\t\t\tmap.closePopup();\n\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tL.DomEvent.stop(e);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\n\n\n/*\n * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n */\n\nL.Handler.MarkerDrag = L.Handler.extend({\n\tinitialize: function (marker) {\n\t\tthis._marker = marker;\n\t},\n\n\taddHooks: function () {\n\t\tvar icon = this._marker._icon;\n\n\t\tif (!this._draggable) {\n\t\t\tthis._draggable = new L.Draggable(icon, icon, true);\n\t\t}\n\n\t\tthis._draggable.on({\n\t\t\tdragstart: this._onDragStart,\n\t\t\tdrag: this._onDrag,\n\t\t\tdragend: this._onDragEnd\n\t\t}, this).enable();\n\n\t\tL.DomUtil.addClass(icon, 'leaflet-marker-draggable');\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable.off({\n\t\t\tdragstart: this._onDragStart,\n\t\t\tdrag: this._onDrag,\n\t\t\tdragend: this._onDragEnd\n\t\t}, this).disable();\n\n\t\tif (this._marker._icon) {\n\t\t\tL.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n\t\t}\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tthis._marker\n\t\t    .closePopup()\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\t},\n\n\t_onDrag: function (e) {\n\t\tvar marker = this._marker,\n\t\t    shadow = marker._shadow,\n\t\t    iconPos = L.DomUtil.getPosition(marker._icon),\n\t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n\t\t// update shadow position\n\t\tif (shadow) {\n\t\t\tL.DomUtil.setPosition(shadow, iconPos);\n\t\t}\n\n\t\tmarker._latlng = latlng;\n\t\te.latlng = latlng;\n\n\t\tmarker\n\t\t    .fire('move', e)\n\t\t    .fire('drag', e);\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tthis._marker\n\t\t    .fire('moveend')\n\t\t    .fire('dragend', e);\n\t}\n});\n\n\n\n/*\r\n * L.Control is a base class for implementing map controls. Handles positioning.\r\n * All other controls extend from this class.\r\n */\r\n\r\nL.Control = L.Class.extend({\r\n\toptions: {\r\n\t\tposition: 'topright'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\t\treturn this.options.position;\r\n\t},\r\n\r\n\tsetPosition: function (position) {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.removeControl(this);\r\n\t\t}\r\n\r\n\t\tthis.options.position = position;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.addControl(this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tthis.remove();\r\n\t\tthis._map = map;\r\n\r\n\t\tvar container = this._container = this.onAdd(map),\r\n\t\t    pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-control');\r\n\r\n\t\tif (pos.indexOf('bottom') !== -1) {\r\n\t\t\tcorner.insertBefore(container, corner.firstChild);\r\n\t\t} else {\r\n\t\t\tcorner.appendChild(container);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremove: function () {\r\n\t\tif (!this._map) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tL.DomUtil.remove(this._container);\r\n\r\n\t\tif (this.onRemove) {\r\n\t\t\tthis.onRemove(this._map);\r\n\t\t}\r\n\r\n\t\tthis._map = null;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_refocusOnMap: function (e) {\r\n\t\t// if map exists and event is not a keyboard event\r\n\t\tif (this._map && e && e.screenX > 0 && e.screenY > 0) {\r\n\t\t\tthis._map.getContainer().focus();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.control = function (options) {\r\n\treturn new L.Control(options);\r\n};\r\n\r\n\r\n// adds control-related methods to L.Map\r\n\r\nL.Map.include({\r\n\taddControl: function (control) {\r\n\t\tcontrol.addTo(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveControl: function (control) {\r\n\t\tcontrol.remove();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initControlPos: function () {\r\n\t\tvar corners = this._controlCorners = {},\r\n\t\t    l = 'leaflet-',\r\n\t\t    container = this._controlContainer =\r\n\t\t            L.DomUtil.create('div', l + 'control-container', this._container);\r\n\r\n\t\tfunction createCorner(vSide, hSide) {\r\n\t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\r\n\t\t\tcorners[vSide + hSide] = L.DomUtil.create('div', className, container);\r\n\t\t}\r\n\r\n\t\tcreateCorner('top', 'left');\r\n\t\tcreateCorner('top', 'right');\r\n\t\tcreateCorner('bottom', 'left');\r\n\t\tcreateCorner('bottom', 'right');\r\n\t},\r\n\r\n\t_clearControlPos: function () {\r\n\t\tL.DomUtil.remove(this._controlContainer);\r\n\t}\r\n});\r\n\n\n\n/*\r\n * L.Control.Zoom is used for the default zoom buttons on the map.\r\n */\r\n\r\nL.Control.Zoom = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'topleft',\r\n\t\tzoomInText: '+',\r\n\t\tzoomInTitle: 'Zoom in',\r\n\t\tzoomOutText: '-',\r\n\t\tzoomOutTitle: 'Zoom out'\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tvar zoomName = 'leaflet-control-zoom',\r\n\t\t    container = L.DomUtil.create('div', zoomName + ' leaflet-bar'),\r\n\t\t    options = this.options;\r\n\r\n\t\tthis._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,\r\n\t\t        zoomName + '-in',  container, this._zoomIn);\r\n\t\tthis._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,\r\n\t\t        zoomName + '-out', container, this._zoomOut);\r\n\r\n\t\tthis._updateDisabled();\r\n\t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\t},\r\n\r\n\tdisable: function () {\r\n\t\tthis._disabled = true;\r\n\t\tthis._updateDisabled();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tenable: function () {\r\n\t\tthis._disabled = false;\r\n\t\tthis._updateDisabled();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_zoomIn: function (e) {\r\n\t\tif (!this._disabled) {\r\n\t\t\tthis._map.zoomIn(e.shiftKey ? 3 : 1);\r\n\t\t}\r\n\t},\r\n\r\n\t_zoomOut: function (e) {\r\n\t\tif (!this._disabled) {\r\n\t\t\tthis._map.zoomOut(e.shiftKey ? 3 : 1);\r\n\t\t}\r\n\t},\r\n\r\n\t_createButton: function (html, title, className, container, fn) {\r\n\t\tvar link = L.DomUtil.create('a', className, container);\r\n\t\tlink.innerHTML = html;\r\n\t\tlink.href = '#';\r\n\t\tlink.title = title;\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)\r\n\t\t    .on(link, 'click', L.DomEvent.stop)\r\n\t\t    .on(link, 'click', fn, this)\r\n\t\t    .on(link, 'click', this._refocusOnMap, this);\r\n\r\n\t\treturn link;\r\n\t},\r\n\r\n\t_updateDisabled: function () {\r\n\t\tvar map = this._map,\r\n\t\t    className = 'leaflet-disabled';\r\n\r\n\t\tL.DomUtil.removeClass(this._zoomInButton, className);\r\n\t\tL.DomUtil.removeClass(this._zoomOutButton, className);\r\n\r\n\t\tif (this._disabled || map._zoom === map.getMinZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomOutButton, className);\r\n\t\t}\r\n\t\tif (this._disabled || map._zoom === map.getMaxZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomInButton, className);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tzoomControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.zoomControl) {\r\n\t\tthis.zoomControl = new L.Control.Zoom();\r\n\t\tthis.addControl(this.zoomControl);\r\n\t}\r\n});\r\n\r\nL.control.zoom = function (options) {\r\n\treturn new L.Control.Zoom(options);\r\n};\r\n\n\n\n/*\r\n * L.Control.Attribution is used for displaying attribution on the map (added by default).\r\n */\r\n\r\nL.Control.Attribution = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'bottomright',\r\n\t\tprefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._attributions = {};\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-control-attribution');\r\n\t\tif (L.DomEvent) {\r\n\t\t\tL.DomEvent.disableClickPropagation(this._container);\r\n\t\t}\r\n\r\n\t\t// TODO ugly, refactor\r\n\t\tfor (var i in map._layers) {\r\n\t\t\tif (map._layers[i].getAttribution) {\r\n\t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tsetPrefix: function (prefix) {\r\n\t\tthis.options.prefix = prefix;\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddAttribution: function (text) {\r\n\t\tif (!text) { return this; }\r\n\r\n\t\tif (!this._attributions[text]) {\r\n\t\t\tthis._attributions[text] = 0;\r\n\t\t}\r\n\t\tthis._attributions[text]++;\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveAttribution: function (text) {\r\n\t\tif (!text) { return this; }\r\n\r\n\t\tif (this._attributions[text]) {\r\n\t\t\tthis._attributions[text]--;\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar attribs = [];\r\n\r\n\t\tfor (var i in this._attributions) {\r\n\t\t\tif (this._attributions[i]) {\r\n\t\t\t\tattribs.push(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar prefixAndAttribs = [];\r\n\r\n\t\tif (this.options.prefix) {\r\n\t\t\tprefixAndAttribs.push(this.options.prefix);\r\n\t\t}\r\n\t\tif (attribs.length) {\r\n\t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n\t\t}\r\n\r\n\t\tthis._container.innerHTML = prefixAndAttribs.join(' | ');\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tattributionControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.attributionControl) {\r\n\t\tthis.attributionControl = (new L.Control.Attribution()).addTo(this);\r\n\t}\r\n});\r\n\r\nL.control.attribution = function (options) {\r\n\treturn new L.Control.Attribution(options);\r\n};\r\n\n\n\n/*\n * L.Control.Scale is used for displaying metric/imperial scale on the map.\n */\n\nL.Control.Scale = L.Control.extend({\n\toptions: {\n\t\tposition: 'bottomleft',\n\t\tmaxWidth: 100,\n\t\tmetric: true,\n\t\timperial: true\n\t\t// updateWhenIdle: false\n\t},\n\n\tonAdd: function (map) {\n\t\tvar className = 'leaflet-control-scale',\n\t\t    container = L.DomUtil.create('div', className),\n\t\t    options = this.options;\n\n\t\tthis._addScales(options, className + '-line', container);\n\n\t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t\tmap.whenReady(this._update, this);\n\n\t\treturn container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t},\n\n\t_addScales: function (options, className, container) {\n\t\tif (options.metric) {\n\t\t\tthis._mScale = L.DomUtil.create('div', className, container);\n\t\t}\n\t\tif (options.imperial) {\n\t\t\tthis._iScale = L.DomUtil.create('div', className, container);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tvar map = this._map,\n\t\t    y = map.getSize().y / 2;\n\n\t\tvar maxMeters = map.distance(\n\t\t\t\tmap.containerPointToLatLng([0, y]),\n\t\t\t\tmap.containerPointToLatLng([this.options.maxWidth, y]));\n\n\t\tthis._updateScales(maxMeters);\n\t},\n\n\t_updateScales: function (maxMeters) {\n\t\tif (this.options.metric && maxMeters) {\n\t\t\tthis._updateMetric(maxMeters);\n\t\t}\n\t\tif (this.options.imperial && maxMeters) {\n\t\t\tthis._updateImperial(maxMeters);\n\t\t}\n\t},\n\n\t_updateMetric: function (maxMeters) {\n\t\tvar meters = this._getRoundNum(maxMeters),\n\t\t    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\n\t\tthis._updateScale(this._mScale, label, meters / maxMeters);\n\t},\n\n\t_updateImperial: function (maxMeters) {\n\t\tvar maxFeet = maxMeters * 3.2808399,\n\t\t    maxMiles, miles, feet;\n\n\t\tif (maxFeet > 5280) {\n\t\t\tmaxMiles = maxFeet / 5280;\n\t\t\tmiles = this._getRoundNum(maxMiles);\n\t\t\tthis._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n\n\t\t} else {\n\t\t\tfeet = this._getRoundNum(maxFeet);\n\t\t\tthis._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n\t\t}\n\t},\n\n\t_updateScale: function (scale, text, ratio) {\n\t\tscale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n\t\tscale.innerHTML = text;\n\t},\n\n\t_getRoundNum: function (num) {\n\t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n\t\t    d = num / pow10;\n\n\t\td = d >= 10 ? 10 :\n\t\t    d >= 5 ? 5 :\n\t\t    d >= 3 ? 3 :\n\t\t    d >= 2 ? 2 : 1;\n\n\t\treturn pow10 * d;\n\t}\n});\n\nL.control.scale = function (options) {\n\treturn new L.Control.Scale(options);\n};\n\n\n\n/*\r\n * L.Control.Layers is a control to allow users to switch between different layers on the map.\r\n */\r\n\r\nL.Control.Layers = L.Control.extend({\r\n\toptions: {\r\n\t\tcollapsed: true,\r\n\t\tposition: 'topright',\r\n\t\tautoZIndex: true,\r\n\t\thideSingleBase: false\r\n\t},\r\n\r\n\tinitialize: function (baseLayers, overlays, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._lastZIndex = 0;\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tfor (var i in baseLayers) {\r\n\t\t\tthis._addLayer(baseLayers[i], i);\r\n\t\t}\r\n\r\n\t\tfor (i in overlays) {\r\n\t\t\tthis._addLayer(overlays[i], i, true);\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._initLayout();\r\n\t\tthis._update();\r\n\r\n\t\tthis._map = map;\r\n\t\tmap.on('zoomend', this._checkDisabledLayers, this);\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function () {\r\n\t\tthis._map.off('zoomend', this._checkDisabledLayers, this);\r\n\t},\r\n\r\n\taddBaseLayer: function (layer, name) {\r\n\t\tthis._addLayer(layer, name);\r\n\t\treturn this._update();\r\n\t},\r\n\r\n\taddOverlay: function (layer, name) {\r\n\t\tthis._addLayer(layer, name, true);\r\n\t\treturn this._update();\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tlayer.off('add remove', this._onLayerChange, this);\r\n\r\n\t\tdelete this._layers[L.stamp(layer)];\r\n\t\treturn this._update();\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar className = 'leaflet-control-layers',\r\n\t\t    container = this._container = L.DomUtil.create('div', className);\r\n\r\n\t\t// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\r\n\t\tcontainer.setAttribute('aria-haspopup', true);\r\n\r\n\t\tL.DomEvent.disableClickPropagation(container);\r\n\t\tif (!L.Browser.touch) {\r\n\t\t\tL.DomEvent.disableScrollPropagation(container);\r\n\t\t}\r\n\r\n\t\tvar form = this._form = L.DomUtil.create('form', className + '-list');\r\n\r\n\t\tif (this.options.collapsed) {\r\n\t\t\tif (!L.Browser.android) {\r\n\t\t\t\tL.DomEvent.on(container, {\r\n\t\t\t\t\tmouseenter: this._expand,\r\n\t\t\t\t\tmouseleave: this._collapse\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\r\n\t\t\tvar link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\r\n\t\t\tlink.href = '#';\r\n\t\t\tlink.title = 'Layers';\r\n\r\n\t\t\tif (L.Browser.touch) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(link, 'click', L.DomEvent.stop)\r\n\t\t\t\t    .on(link, 'click', this._expand, this);\r\n\t\t\t} else {\r\n\t\t\t\tL.DomEvent.on(link, 'focus', this._expand, this);\r\n\t\t\t}\r\n\r\n\t\t\t// work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033\r\n\t\t\tL.DomEvent.on(form, 'click', function () {\r\n\t\t\t\tsetTimeout(L.bind(this._onInputClick, this), 0);\r\n\t\t\t}, this);\r\n\r\n\t\t\tthis._map.on('click', this._collapse, this);\r\n\t\t\t// TODO keyboard accessibility\r\n\t\t} else {\r\n\t\t\tthis._expand();\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList = L.DomUtil.create('div', className + '-base', form);\r\n\t\tthis._separator = L.DomUtil.create('div', className + '-separator', form);\r\n\t\tthis._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\r\n\r\n\t\tcontainer.appendChild(form);\r\n\t},\r\n\r\n\t_addLayer: function (layer, name, overlay) {\r\n\t\tlayer.on('add remove', this._onLayerChange, this);\r\n\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tthis._layers[id] = {\r\n\t\t\tlayer: layer,\r\n\t\t\tname: name,\r\n\t\t\toverlay: overlay\r\n\t\t};\r\n\r\n\t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n\t\t\tthis._lastZIndex++;\r\n\t\t\tlayer.setZIndex(this._lastZIndex);\r\n\t\t}\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._container) { return this; }\r\n\r\n\t\tL.DomUtil.empty(this._baseLayersList);\r\n\t\tL.DomUtil.empty(this._overlaysList);\r\n\r\n\t\tvar baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tobj = this._layers[i];\r\n\t\t\tthis._addItem(obj);\r\n\t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n\t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n\t\t\tbaseLayersCount += !obj.overlay ? 1 : 0;\r\n\t\t}\r\n\r\n\t\t// Hide base layers section if there's only one layer.\r\n\t\tif (this.options.hideSingleBase) {\r\n\t\t\tbaseLayersPresent = baseLayersPresent && baseLayersCount > 1;\r\n\t\t\tthis._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\r\n\t\t}\r\n\r\n\t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_onLayerChange: function (e) {\r\n\t\tif (!this._handlingClick) {\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tvar obj = this._layers[L.stamp(e.target)];\r\n\r\n\t\tvar type = obj.overlay ?\r\n\t\t\t(e.type === 'add' ? 'overlayadd' : 'overlayremove') :\r\n\t\t\t(e.type === 'add' ? 'baselayerchange' : null);\r\n\r\n\t\tif (type) {\r\n\t\t\tthis._map.fire(type, obj);\r\n\t\t}\r\n\t},\r\n\r\n\t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\r\n\t_createRadioElement: function (name, checked) {\r\n\r\n\t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' +\r\n\t\t\t\tname + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\r\n\r\n\t\tvar radioFragment = document.createElement('div');\r\n\t\tradioFragment.innerHTML = radioHtml;\r\n\r\n\t\treturn radioFragment.firstChild;\r\n\t},\r\n\r\n\t_addItem: function (obj) {\r\n\t\tvar label = document.createElement('label'),\r\n\t\t    checked = this._map.hasLayer(obj.layer),\r\n\t\t    input;\r\n\r\n\t\tif (obj.overlay) {\r\n\t\t\tinput = document.createElement('input');\r\n\t\t\tinput.type = 'checkbox';\r\n\t\t\tinput.className = 'leaflet-control-layers-selector';\r\n\t\t\tinput.defaultChecked = checked;\r\n\t\t} else {\r\n\t\t\tinput = this._createRadioElement('leaflet-base-layers', checked);\r\n\t\t}\r\n\r\n\t\tinput.layerId = L.stamp(obj.layer);\r\n\r\n\t\tL.DomEvent.on(input, 'click', this._onInputClick, this);\r\n\r\n\t\tvar name = document.createElement('span');\r\n\t\tname.innerHTML = ' ' + obj.name;\r\n\r\n\t\t// Helps from preventing layer control flicker when checkboxes are disabled\r\n\t\t// https://github.com/Leaflet/Leaflet/issues/2771\r\n\t\tvar holder = document.createElement('div');\r\n\r\n\t\tlabel.appendChild(holder);\r\n\t\tholder.appendChild(input);\r\n\t\tholder.appendChild(name);\r\n\r\n\t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n\t\tcontainer.appendChild(label);\r\n\r\n\t\tthis._checkDisabledLayers();\r\n\t\treturn label;\r\n\t},\r\n\r\n\t_onInputClick: function () {\r\n\t\tvar inputs = this._form.getElementsByTagName('input'),\r\n\t\t    input, layer, hasLayer;\r\n\t\tvar addedLayers = [],\r\n\t\t    removedLayers = [];\r\n\r\n\t\tthis._handlingClick = true;\r\n\r\n\t\tfor (var i = inputs.length - 1; i >= 0; i--) {\r\n\t\t\tinput = inputs[i];\r\n\t\t\tlayer = this._layers[input.layerId].layer;\r\n\t\t\thasLayer = this._map.hasLayer(layer);\r\n\r\n\t\t\tif (input.checked && !hasLayer) {\r\n\t\t\t\taddedLayers.push(layer);\r\n\r\n\t\t\t} else if (!input.checked && hasLayer) {\r\n\t\t\t\tremovedLayers.push(layer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Bugfix issue 2318: Should remove all old layers before readding new ones\r\n\t\tfor (i = 0; i < removedLayers.length; i++) {\r\n\t\t\tthis._map.removeLayer(removedLayers[i]);\r\n\t\t}\r\n\t\tfor (i = 0; i < addedLayers.length; i++) {\r\n\t\t\tthis._map.addLayer(addedLayers[i]);\r\n\t\t}\r\n\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tthis._refocusOnMap();\r\n\t},\r\n\r\n\t_expand: function () {\r\n\t\tL.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\r\n\t\tthis._form.style.height = null;\r\n\t\tvar acceptableHeight = this._map._size.y - (this._container.offsetTop + 50);\r\n\t\tif (acceptableHeight < this._form.clientHeight) {\r\n\t\t\tL.DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');\r\n\t\t\tthis._form.style.height = acceptableHeight + 'px';\r\n\t\t} else {\r\n\t\t\tL.DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');\r\n\t\t}\r\n\t\tthis._checkDisabledLayers();\r\n\t},\r\n\r\n\t_collapse: function () {\r\n\t\tL.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');\r\n\t},\r\n\r\n\t_checkDisabledLayers: function () {\r\n\t\tvar inputs = this._form.getElementsByTagName('input'),\r\n\t\t    input,\r\n\t\t    layer,\r\n\t\t    zoom = this._map.getZoom();\r\n\r\n\t\tfor (var i = inputs.length - 1; i >= 0; i--) {\r\n\t\t\tinput = inputs[i];\r\n\t\t\tlayer = this._layers[input.layerId].layer;\r\n\t\t\tinput.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||\r\n\t\t\t                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);\r\n\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.control.layers = function (baseLayers, overlays, options) {\r\n\treturn new L.Control.Layers(baseLayers, overlays, options);\r\n};\r\n\n\n\n/*\n * L.PosAnimation powers Leaflet pan animations internally.\n */\n\nL.PosAnimation = L.Evented.extend({\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._duration = duration || 0.25;\n\t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n\t\tthis._startPos = L.DomUtil.getPosition(el);\n\t\tthis._offset = newPos.subtract(this._startPos);\n\t\tthis._startTime = +new Date();\n\n\t\tthis.fire('start');\n\n\t\tthis._animate();\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\tthis._step(true);\n\t\tthis._complete();\n\t},\n\n\t_animate: function () {\n\t\t// animation loop\n\t\tthis._animId = L.Util.requestAnimFrame(this._animate, this);\n\t\tthis._step();\n\t},\n\n\t_step: function (round) {\n\t\tvar elapsed = (+new Date()) - this._startTime,\n\t\t    duration = this._duration * 1000;\n\n\t\tif (elapsed < duration) {\n\t\t\tthis._runFrame(this._easeOut(elapsed / duration), round);\n\t\t} else {\n\t\t\tthis._runFrame(1);\n\t\t\tthis._complete();\n\t\t}\n\t},\n\n\t_runFrame: function (progress, round) {\n\t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n\t\tif (round) {\n\t\t\tpos._round();\n\t\t}\n\t\tL.DomUtil.setPosition(this._el, pos);\n\n\t\tthis.fire('step');\n\t},\n\n\t_complete: function () {\n\t\tL.Util.cancelAnimFrame(this._animId);\n\n\t\tthis._inProgress = false;\n\t\tthis.fire('end');\n\t},\n\n\t_easeOut: function (t) {\n\t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n\t}\n});\n\n\n\n/*\n * Extends L.Map to handle panning animations.\n */\n\nL.Map.include({\n\n\tsetView: function (center, zoom, options) {\n\n\t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n\t\tcenter = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n\t\toptions = options || {};\n\n\t\tthis.stop();\n\n\t\tif (this._loaded && !options.reset && options !== true) {\n\n\t\t\tif (options.animate !== undefined) {\n\t\t\t\toptions.zoom = L.extend({animate: options.animate}, options.zoom);\n\t\t\t\toptions.pan = L.extend({animate: options.animate, duration: options.duration}, options.pan);\n\t\t\t}\n\n\t\t\t// try animating pan or zoom\n\t\t\tvar moved = (this._zoom !== zoom) ?\n\t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\n\t\t\t\tthis._tryAnimatedPan(center, options.pan);\n\n\t\t\tif (moved) {\n\t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\n\t\t\t\tclearTimeout(this._sizeTimer);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// animation didn't start, just reset the map view\n\t\tthis._resetView(center, zoom);\n\n\t\treturn this;\n\t},\n\n\tpanBy: function (offset, options) {\n\t\toffset = L.point(offset).round();\n\t\toptions = options || {};\n\n\t\tif (!offset.x && !offset.y) {\n\t\t\treturn this.fire('moveend');\n\t\t}\n\t\t// If we pan too far, Chrome gets issues with tiles\n\t\t// and makes them disappear or appear in the wrong place (slightly offset) #2602\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) {\n\t\t\tthis._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!this._panAnim) {\n\t\t\tthis._panAnim = new L.PosAnimation();\n\n\t\t\tthis._panAnim.on({\n\t\t\t\t'step': this._onPanTransitionStep,\n\t\t\t\t'end': this._onPanTransitionEnd\n\t\t\t}, this);\n\t\t}\n\n\t\t// don't fire movestart if animating inertia\n\t\tif (!options.noMoveStart) {\n\t\t\tthis.fire('movestart');\n\t\t}\n\n\t\t// animate pan unless animate: false specified\n\t\tif (options.animate !== false) {\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n\n\t\t\tvar newPos = this._getMapPanePos().subtract(offset);\n\t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n\t\t} else {\n\t\t\tthis._rawPanBy(offset);\n\t\t\tthis.fire('move').fire('moveend');\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_onPanTransitionStep: function () {\n\t\tthis.fire('move');\n\t},\n\n\t_onPanTransitionEnd: function () {\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n\t\tthis.fire('moveend');\n\t},\n\n\t_tryAnimatedPan: function (center, options) {\n\t\t// difference between the new and current centers in pixels\n\t\tvar offset = this._getCenterOffset(center)._floor();\n\n\t\t// don't animate too far unless animate: true specified in options\n\t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis.panBy(offset, options);\n\n\t\treturn true;\n\t}\n});\n\n\n\n/*\n * Extends L.Map to handle zoom animations.\n */\n\nL.Map.mergeOptions({\n\tzoomAnimation: true,\n\tzoomAnimationThreshold: 4\n});\n\nvar zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera;\n\nif (zoomAnimated) {\n\n\tL.Map.addInitHook(function () {\n\t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\t\tthis._zoomAnimated = this.options.zoomAnimation;\n\n\t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\n\t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\t\tif (this._zoomAnimated) {\n\n\t\t\tthis._createAnimProxy();\n\n\t\t\tL.DomEvent.on(this._proxy, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n\t\t}\n\t});\n}\n\nL.Map.include(!zoomAnimated ? {} : {\n\n\t_createAnimProxy: function () {\n\n\t\tvar proxy = this._proxy = L.DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');\n\t\tthis._panes.mapPane.appendChild(proxy);\n\n\t\tthis.on('zoomanim', function (e) {\n\t\t\tvar prop = L.DomUtil.TRANSFORM,\n\t\t\t    transform = proxy.style[prop];\n\n\t\t\tL.DomUtil.setTransform(proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\n\n\t\t\t// workaround for case when transform is the same and so transitionend event is not fired\n\t\t\tif (transform === proxy.style[prop] && this._animatingZoom) {\n\t\t\t\tthis._onZoomTransitionEnd();\n\t\t\t}\n\t\t}, this);\n\n\t\tthis.on('load moveend', function () {\n\t\t\tvar c = this.getCenter(),\n\t\t\t    z = this.getZoom();\n\t\t\tL.DomUtil.setTransform(proxy, this.project(c, z), this.getZoomScale(z, 1));\n\t\t}, this);\n\t},\n\n\t_catchTransitionEnd: function (e) {\n\t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n\t\t\tthis._onZoomTransitionEnd();\n\t\t}\n\t},\n\n\t_nothingToAnimate: function () {\n\t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n\t},\n\n\t_tryAnimatedZoom: function (center, zoom, options) {\n\n\t\tif (this._animatingZoom) { return true; }\n\n\t\toptions = options || {};\n\n\t\t// don't animate if disabled, not supported or zoom difference is too large\n\t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\n\t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\n\n\t\t// offset is the pixel coords of the zoom origin relative to the current center\n\t\tvar scale = this.getZoomScale(zoom),\n\t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\n\n\t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis\n\t\t\t    ._moveStart(true)\n\t\t\t    ._animateZoom(center, zoom, true);\n\t\t}, this);\n\n\t\treturn true;\n\t},\n\n\t_animateZoom: function (center, zoom, startAnim, noUpdate) {\n\t\tif (startAnim) {\n\t\t\tthis._animatingZoom = true;\n\n\t\t\t// remember what center/zoom to set after animation\n\t\t\tthis._animateToCenter = center;\n\t\t\tthis._animateToZoom = zoom;\n\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\t\t}\n\n\t\tthis.fire('zoomanim', {\n\t\t\tcenter: center,\n\t\t\tzoom: zoom,\n\t\t\tnoUpdate: noUpdate\n\t\t});\n\n\t\t// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n\t\tsetTimeout(L.bind(this._onZoomTransitionEnd, this), 250);\n\t},\n\n\t_onZoomTransitionEnd: function () {\n\t\tif (!this._animatingZoom) { return; }\n\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\t// This anim frame should prevent an obscure iOS webkit tile loading race condition.\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis._animatingZoom = false;\n\n\t\t\tthis\n\t\t\t\t._move(this._animateToCenter, this._animateToZoom)\n\t\t\t\t._moveEnd(true);\n\t\t}, this);\n\t}\n});\n\n\n\n\nL.Map.include({\n\tflyTo: function (targetCenter, targetZoom, options) {\n\n\t\toptions = options || {};\n\t\tif (options.animate === false || !L.Browser.any3d) {\n\t\t\treturn this.setView(targetCenter, targetZoom, options);\n\t\t}\n\n\t\tthis.stop();\n\n\t\tvar from = this.project(this.getCenter()),\n\t\t    to = this.project(targetCenter),\n\t\t    size = this.getSize(),\n\t\t    startZoom = this._zoom;\n\n\t\ttargetCenter = L.latLng(targetCenter);\n\t\ttargetZoom = targetZoom === undefined ? startZoom : targetZoom;\n\n\t\tvar w0 = Math.max(size.x, size.y),\n\t\t    w1 = w0 * this.getZoomScale(startZoom, targetZoom),\n\t\t    u1 = (to.distanceTo(from)) || 1,\n\t\t    rho = 1.42,\n\t\t    rho2 = rho * rho;\n\n\t\tfunction r(i) {\n\t\t\tvar b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);\n\t\t\treturn Math.log(Math.sqrt(b * b + 1) - b);\n\t\t}\n\n\t\tfunction sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }\n\t\tfunction cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }\n\t\tfunction tanh(n) { return sinh(n) / cosh(n); }\n\n\t\tvar r0 = r(0);\n\n\t\tfunction w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }\n\t\tfunction u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }\n\n\t\tfunction easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }\n\n\t\tvar start = Date.now(),\n\t\t    S = (r(1) - r0) / rho,\n\t\t    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n\n\t\tfunction frame() {\n\t\t\tvar t = (Date.now() - start) / duration,\n\t\t\t    s = easeOut(t) * S;\n\n\t\t\tif (t <= 1) {\n\t\t\t\tthis._flyToFrame = L.Util.requestAnimFrame(frame, this);\n\n\t\t\t\tthis._move(\n\t\t\t\t\tthis.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),\n\t\t\t\t\tthis.getScaleZoom(w0 / w(s), startZoom),\n\t\t\t\t\t{flyTo: true});\n\n\t\t\t} else {\n\t\t\t\tthis\n\t\t\t\t\t._move(targetCenter, targetZoom)\n\t\t\t\t\t._moveEnd(true);\n\t\t\t}\n\t\t}\n\n\t\tthis._moveStart(true);\n\n\t\tframe.call(this);\n\t\treturn this;\n\t},\n\n\tflyToBounds: function (bounds, options) {\n\t\tvar target = this._getBoundsCenterZoom(bounds, options);\n\t\treturn this.flyTo(target.center, target.zoom, options);\n\t}\n});\n\n\n\n/*\r\n * Provides L.Map with convenient shortcuts for using browser geolocation features.\r\n */\r\n\r\nL.Map.include({\r\n\t_defaultLocateOptions: {\r\n\t\ttimeout: 10000,\r\n\t\twatch: false\r\n\t\t// setView: false\r\n\t\t// maxZoom: <Number>\r\n\t\t// maximumAge: 0\r\n\t\t// enableHighAccuracy: false\r\n\t},\r\n\r\n\tlocate: function (options) {\r\n\r\n\t\toptions = this._locateOptions = L.extend({}, this._defaultLocateOptions, options);\r\n\r\n\t\tif (!('geolocation' in navigator)) {\r\n\t\t\tthis._handleGeolocationError({\r\n\t\t\t\tcode: 0,\r\n\t\t\t\tmessage: 'Geolocation not supported.'\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar onResponse = L.bind(this._handleGeolocationResponse, this),\r\n\t\t    onError = L.bind(this._handleGeolocationError, this);\r\n\r\n\t\tif (options.watch) {\r\n\t\t\tthis._locationWatchId =\r\n\t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n\t\t} else {\r\n\t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopLocate: function () {\r\n\t\tif (navigator.geolocation && navigator.geolocation.clearWatch) {\r\n\t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n\t\t}\r\n\t\tif (this._locateOptions) {\r\n\t\t\tthis._locateOptions.setView = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_handleGeolocationError: function (error) {\r\n\t\tvar c = error.code,\r\n\t\t    message = error.message ||\r\n\t\t            (c === 1 ? 'permission denied' :\r\n\t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n\t\tif (this._locateOptions.setView && !this._loaded) {\r\n\t\t\tthis.fitWorld();\r\n\t\t}\r\n\r\n\t\tthis.fire('locationerror', {\r\n\t\t\tcode: c,\r\n\t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n\t\t});\r\n\t},\r\n\r\n\t_handleGeolocationResponse: function (pos) {\r\n\t\tvar lat = pos.coords.latitude,\r\n\t\t    lng = pos.coords.longitude,\r\n\t\t    latlng = new L.LatLng(lat, lng),\r\n\t\t    bounds = latlng.toBounds(pos.coords.accuracy),\r\n\t\t    options = this._locateOptions;\r\n\r\n\t\tif (options.setView) {\r\n\t\t\tvar zoom = this.getBoundsZoom(bounds);\r\n\t\t\tthis.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tbounds: bounds,\r\n\t\t\ttimestamp: pos.timestamp\r\n\t\t};\r\n\r\n\t\tfor (var i in pos.coords) {\r\n\t\t\tif (typeof pos.coords[i] === 'number') {\r\n\t\t\t\tdata[i] = pos.coords[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.fire('locationfound', data);\r\n\t}\r\n});\r\n\n\n}(window, document));\n//# sourceMappingURL=leaflet-src.map","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n","'use strict';\n\n// Polyfills\nrequire('whatwg-fetch');\n\n// Leaflet, map libraries and Tangram\nvar L = require('leaflet');\nrequire('leaflet-hash');\nrequire('leaflet.locatecontrol')\nrequire('leaflet-geocoder-mapzen');\n// require('drmonty-leaflet-awesome-markers');\n\nvar Tangram = (typeof window !== \"undefined\" ? window['Tangram'] : typeof global !== \"undefined\" ? global['Tangram'] : null); // via browserify-shim\n\nvar SEARCH_API_KEY = 'search-KqgQGdk';\n\n// Set this manually inside a bundle\nL.Icon.Default.imagePath = 'site/images';\n\n// Leaflet\nvar map = L.map('map', {\n  zoomControl: false,\n  worldCopyJump: true\n}).setView([40.7259, -73.9805], 12);\n\n// URL Hash\nvar hash = new L.Hash(map);\n\n// Zoom controls\nL.control.zoom({ position: 'topright' }).addTo(map);\n\n// Locate me control\nvar locator = L.control.locate({\n  position: 'topright',\n  follow: false,\n  showPopup: false,\n  keepCurrentZoomLevel: true\n}).addTo(map)\n\n// Tangram\nvar layer = Tangram.leafletLayer({\n  scene: 'site/outdoor-style.yaml',\n  attribution: '&copy; OSM contributors'\n}).addTo(map);\n\n// Search\nvar geocoder = L.control.geocoder(SEARCH_API_KEY, {\n  expanded: true\n}).addTo(map);\n\n// Reverse\nvar markers = [];\n\nmap.on('click', function (e) {\n  var latlng = e.latlng;\n  var reverse = 'https://search.mapzen.com/v1/reverse?point.lat=' + latlng.lat + '&point.lon=' + latlng.lng + '&size=1&layers=address&api_key=' + SEARCH_API_KEY;\n\n  // Add a marker on click immediately\n  removeMarkers();\n  var marker = new L.marker(latlng);\n  markers.push(marker);\n  map.addLayer(marker);\n  map.panTo(latlng);\n\n  // Reverse geocode and then display things based on it\n  window.fetch(reverse)\n    .then(function (response) {\n      if (!response.ok) {\n        throw new Error('status code: ' + response.status);\n      }\n\n      return response.json();\n    })\n    .then(function (response) {\n      var label = response.features[0].properties.label;\n      marker.bindPopup(label).openPopup();\n    })\n    .catch(function (error) {\n      console.log('error getting reverse geocode. ' + error);\n    });\n\n  function removeMarkers () {\n    for (var i = 0; i < markers.length; i++) {\n      map.removeLayer(markers[i]);\n    }\n    markers = [];\n  };\n});\n\n// Hashes update parent if iframed\nwindow.addEventListener('hashchange', function () {\n  parent.postMessage(window.location.hash, '*');\n});\n\n// Debug\nwindow.map = map;\n"],"sourceRoot":"/source/"}